/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to2;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CalctexPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/editor.ts
var import_language = require("@codemirror/language");
var import_state = require("@codemirror/state");
var import_view2 = require("@codemirror/view");

// src/widget.ts
var import_view = require("@codemirror/view");
var ResultWidget = class extends import_view.WidgetType {
  constructor(view, index, text) {
    super();
    this.view = view;
    this.index = index;
    this.text = text;
  }
  toDOM(_view) {
    document.removeEventListener("keydown", this.keyListener, true);
    const div = document.createElement("span");
    div.className = "result-text";
    this.insertLocation = this.index;
    this.resultText = this.text;
    div.innerText = this.text;
    this.keyListener = (event) => {
      if (event.key !== CalctexPlugin.INSTANCE.settings.completionTriggerKey) return;
      event.preventDefault();
      this.insertToDOM();
    };
    document.addEventListener("keydown", this.keyListener, true);
    div.onclick = () => {
      this.insertToDOM();
    };
    return div;
  }
  destroy(dom) {
    document.removeEventListener("keydown", this.keyListener, true);
    dom.remove();
  }
  insertToDOM() {
    const transaction = this.view.state.update({
      changes: {
        from: this.insertLocation,
        to: this.insertLocation,
        insert: this.resultText
      },
      selection: {
        anchor: this.insertLocation + this.resultText.length,
        head: this.insertLocation + this.resultText.length
      }
    });
    this.view.dispatch(transaction);
    document.removeEventListener("keydown", this.keyListener, true);
  }
};

// node_modules/@cortex-js/compute-engine/dist/compute-engine.min.esm.js
var Se = Math.cosh || function(e12) {
  return Math.abs(e12) < 1e-9 ? 1 - e12 : (Math.exp(e12) + Math.exp(-e12)) * 0.5;
};
var Ue = Math.sinh || function(e12) {
  return Math.abs(e12) < 1e-9 ? e12 : (Math.exp(e12) - Math.exp(-e12)) * 0.5;
};
var uc = function(e12) {
  var n = Math.PI / 4;
  if (-n > e12 || e12 > n) return Math.cos(e12) - 1;
  var i = e12 * e12;
  return i * (i * (i * (i * (i * (i * (i * (i / 20922789888e3 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
};
var lc = function(e12, n) {
  var i = Math.abs(e12), t = Math.abs(n);
  return i < 3e3 && t < 3e3 ? Math.sqrt(i * i + t * t) : (i < t ? (i = t, t = e12 / n) : t = n / e12, i * Math.sqrt(1 + t * t));
};
var Ti = function() {
  throw SyntaxError("Invalid Param");
};
function ms(e12, n) {
  var i = Math.abs(e12), t = Math.abs(n);
  return e12 === 0 ? Math.log(t) : n === 0 ? Math.log(i) : i < 3e3 && t < 3e3 ? Math.log(e12 * e12 + n * n) * 0.5 : (e12 = e12 / 2, n = n / 2, 0.5 * Math.log(e12 * e12 + n * n) + Math.LN2);
}
var fc = function(e12, n) {
  var i = { re: 0, im: 0 };
  if (e12 == null) i.re = i.im = 0;
  else if (n !== void 0) i.re = e12, i.im = n;
  else switch (typeof e12) {
    case "object":
      if ("im" in e12 && "re" in e12) i.re = e12.re, i.im = e12.im;
      else if ("abs" in e12 && "arg" in e12) {
        if (!Number.isFinite(e12.abs) && Number.isFinite(e12.arg)) return $.INFINITY;
        i.re = e12.abs * Math.cos(e12.arg), i.im = e12.abs * Math.sin(e12.arg);
      } else if ("r" in e12 && "phi" in e12) {
        if (!Number.isFinite(e12.r) && Number.isFinite(e12.phi)) return $.INFINITY;
        i.re = e12.r * Math.cos(e12.phi), i.im = e12.r * Math.sin(e12.phi);
      } else e12.length === 2 ? (i.re = e12[0], i.im = e12[1]) : Ti();
      break;
    case "string":
      i.im = i.re = 0;
      var t = e12.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g), r = 1, s = 0;
      t === null && Ti();
      for (var o = 0; o < t.length; o++) {
        var a = t[o];
        a === " " || a === "	" || a === `
` || (a === "+" ? r++ : a === "-" ? s++ : a === "i" || a === "I" ? (r + s === 0 && Ti(), t[o + 1] !== " " && !isNaN(Number(t[o + 1])) ? (i.im += parseFloat((s % 2 ? "-" : "") + t[o + 1]), o++) : i.im += parseFloat((s % 2 ? "-" : "") + "1"), r = s = 0) : ((r + s === 0 || isNaN(Number(a))) && Ti(), t[o + 1] === "i" || t[o + 1] === "I" ? (i.im += parseFloat((s % 2 ? "-" : "") + a), o++) : i.re += parseFloat((s % 2 ? "-" : "") + a), r = s = 0));
      }
      r + s > 0 && Ti();
      break;
    case "number":
      i.im = 0, i.re = e12;
      break;
    default:
      Ti();
  }
  return isNaN(i.re) || isNaN(i.im), i;
};
var $ = class e {
  constructor(n, i) {
    this.re = 0, this.im = 0;
    var t = fc(n, i);
    this.re = t.re, this.im = t.im;
  }
  sign() {
    var n = this.abs();
    return new e(this.re / n, this.im / n);
  }
  add(n, i) {
    var t = new e(n, i);
    return this.isInfinite() && t.isInfinite() ? e.NAN : this.isInfinite() || t.isInfinite() ? e.INFINITY : new e(this.re + t.re, this.im + t.im);
  }
  sub(n, i) {
    var t = new e(n, i);
    return this.isInfinite() && t.isInfinite() ? e.NAN : this.isInfinite() || t.isInfinite() ? e.INFINITY : new e(this.re - t.re, this.im - t.im);
  }
  mul(n, i) {
    var t = new e(n, i);
    return this.isInfinite() && t.isZero() || this.isZero() && t.isInfinite() ? e.NAN : this.isInfinite() || t.isInfinite() ? e.INFINITY : t.im === 0 && this.im === 0 ? new e(this.re * t.re, 0) : new e(this.re * t.re - this.im * t.im, this.re * t.im + this.im * t.re);
  }
  div(n, i) {
    var t = new e(n, i);
    if (this.isZero() && t.isZero() || this.isInfinite() && t.isInfinite()) return e.NAN;
    if (this.isInfinite() || t.isZero()) return e.INFINITY;
    if (this.isZero() || t.isInfinite()) return e.ZERO;
    n = this.re, i = this.im;
    var r = t.re, s = t.im, o, a;
    return s === 0 ? new e(n / r, i / r) : Math.abs(r) < Math.abs(s) ? (a = r / s, o = r * a + s, new e((n * a + i) / o, (i * a - n) / o)) : (a = s / r, o = s * a + r, new e((n + i * a) / o, (i - n * a) / o));
  }
  pow(n, i) {
    var t = new e(n, i);
    if (n = this.re, i = this.im, t.isZero()) return e.ONE;
    if (t.im === 0) {
      if (i === 0 && n > 0) return new e(Math.pow(n, t.re), 0);
      if (n === 0) switch ((t.re % 4 + 4) % 4) {
        case 0:
          return new e(Math.pow(i, t.re), 0);
        case 1:
          return new e(0, Math.pow(i, t.re));
        case 2:
          return new e(-Math.pow(i, t.re), 0);
        case 3:
          return new e(0, -Math.pow(i, t.re));
      }
    }
    if (n === 0 && i === 0 && t.re > 0 && t.im >= 0) return e.ZERO;
    var r = Math.atan2(i, n), s = ms(n, i);
    return n = Math.exp(t.re * s - t.im * r), i = t.im * s + t.re * r, new e(n * Math.cos(i), n * Math.sin(i));
  }
  sqrt() {
    var n = this.re, i = this.im, t = this.abs(), r, s;
    if (n >= 0) {
      if (i === 0) return new e(Math.sqrt(n), 0);
      r = 0.5 * Math.sqrt(2 * (t + n));
    } else r = Math.abs(i) / Math.sqrt(2 * (t - n));
    return n <= 0 ? s = 0.5 * Math.sqrt(2 * (t - n)) : s = Math.abs(i) / Math.sqrt(2 * (t + n)), new e(r, i < 0 ? -s : s);
  }
  exp() {
    var n = Math.exp(this.re);
    return this.im, new e(n * Math.cos(this.im), n * Math.sin(this.im));
  }
  expm1() {
    var n = this.re, i = this.im;
    return new e(Math.expm1(n) * Math.cos(i) + uc(i), Math.exp(n) * Math.sin(i));
  }
  log() {
    var n = this.re, i = this.im;
    return i === 0 && n > 0, new e(ms(n, i), Math.atan2(i, n));
  }
  abs() {
    return lc(this.re, this.im);
  }
  arg() {
    return Math.atan2(this.im, this.re);
  }
  sin() {
    var n = this.re, i = this.im;
    return new e(Math.sin(n) * Se(i), Math.cos(n) * Ue(i));
  }
  cos() {
    var n = this.re, i = this.im;
    return new e(Math.cos(n) * Se(i), -Math.sin(n) * Ue(i));
  }
  tan() {
    var n = 2 * this.re, i = 2 * this.im, t = Math.cos(n) + Se(i);
    return new e(Math.sin(n) / t, Ue(i) / t);
  }
  cot() {
    var n = 2 * this.re, i = 2 * this.im, t = Math.cos(n) - Se(i);
    return new e(-Math.sin(n) / t, Ue(i) / t);
  }
  sec() {
    var n = this.re, i = this.im, t = 0.5 * Se(2 * i) + 0.5 * Math.cos(2 * n);
    return new e(Math.cos(n) * Se(i) / t, Math.sin(n) * Ue(i) / t);
  }
  csc() {
    var n = this.re, i = this.im, t = 0.5 * Se(2 * i) - 0.5 * Math.cos(2 * n);
    return new e(Math.sin(n) * Se(i) / t, -Math.cos(n) * Ue(i) / t);
  }
  asin() {
    var n = this.re, i = this.im, t = new e(i * i - n * n + 1, -2 * n * i).sqrt(), r = new e(t.re - i, t.im + n).log();
    return new e(r.im, -r.re);
  }
  acos() {
    var n = this.re, i = this.im, t = new e(i * i - n * n + 1, -2 * n * i).sqrt(), r = new e(t.re - i, t.im + n).log();
    return new e(Math.PI / 2 - r.im, r.re);
  }
  atan() {
    var n = this.re, i = this.im;
    if (n === 0) {
      if (i === 1) return new e(0, 1 / 0);
      if (i === -1) return new e(0, -1 / 0);
    }
    var t = n * n + (1 - i) * (1 - i), r = new e((1 - i * i - n * n) / t, -2 * n / t).log();
    return new e(-0.5 * r.im, 0.5 * r.re);
  }
  acot() {
    var n = this.re, i = this.im;
    if (i === 0) return new e(Math.atan2(1, n), 0);
    var t = n * n + i * i;
    return t !== 0 ? new e(n / t, -i / t).atan() : new e(n !== 0 ? n / 0 : 0, i !== 0 ? -i / 0 : 0).atan();
  }
  asec() {
    var n = this.re, i = this.im;
    if (n === 0 && i === 0) return new e(0, 1 / 0);
    var t = n * n + i * i;
    return t !== 0 ? new e(n / t, -i / t).acos() : new e(n !== 0 ? n / 0 : 0, i !== 0 ? -i / 0 : 0).acos();
  }
  acsc() {
    var n = this.re, i = this.im;
    if (n === 0 && i === 0) return new e(Math.PI / 2, 1 / 0);
    var t = n * n + i * i;
    return t !== 0 ? new e(n / t, -i / t).asin() : new e(n !== 0 ? n / 0 : 0, i !== 0 ? -i / 0 : 0).asin();
  }
  sinh() {
    var n = this.re, i = this.im;
    return new e(Ue(n) * Math.cos(i), Se(n) * Math.sin(i));
  }
  cosh() {
    var n = this.re, i = this.im;
    return new e(Se(n) * Math.cos(i), Ue(n) * Math.sin(i));
  }
  tanh() {
    var n = 2 * this.re, i = 2 * this.im, t = Se(n) + Math.cos(i);
    return new e(Ue(n) / t, Math.sin(i) / t);
  }
  coth() {
    var n = 2 * this.re, i = 2 * this.im, t = Se(n) - Math.cos(i);
    return new e(Ue(n) / t, -Math.sin(i) / t);
  }
  csch() {
    var n = this.re, i = this.im, t = Math.cos(2 * i) - Se(2 * n);
    return new e(-2 * Ue(n) * Math.cos(i) / t, 2 * Se(n) * Math.sin(i) / t);
  }
  sech() {
    var n = this.re, i = this.im, t = Math.cos(2 * i) + Se(2 * n);
    return new e(2 * Se(n) * Math.cos(i) / t, -2 * Ue(n) * Math.sin(i) / t);
  }
  asinh() {
    var n = this.im;
    this.im = -this.re, this.re = n;
    var i = this.asin();
    return this.re = -this.im, this.im = n, n = i.re, i.re = -i.im, i.im = n, i;
  }
  acosh() {
    var n = this.acos();
    if (n.im <= 0) {
      var i = n.re;
      n.re = -n.im, n.im = i;
    } else {
      var i = n.im;
      n.im = -n.re, n.re = i;
    }
    return n;
  }
  atanh() {
    var n = this.re, i = this.im, t = n > 1 && i === 0, r = 1 - n, s = 1 + n, o = r * r + i * i, a = o !== 0 ? new e((s * r - i * i) / o, (i * r + s * i) / o) : new e(n !== -1 ? n / 0 : 0, i !== 0 ? i / 0 : 0), u = a.re;
    return a.re = ms(a.re, a.im) / 2, a.im = Math.atan2(a.im, u) / 2, t && (a.im = -a.im), a;
  }
  acoth() {
    var n = this.re, i = this.im;
    if (n === 0 && i === 0) return new e(0, Math.PI / 2);
    var t = n * n + i * i;
    return t !== 0 ? new e(n / t, -i / t).atanh() : new e(n !== 0 ? n / 0 : 0, i !== 0 ? -i / 0 : 0).atanh();
  }
  acsch() {
    var n = this.re, i = this.im;
    if (i === 0) return new e(n !== 0 ? Math.log(n + Math.sqrt(n * n + 1)) : 1 / 0, 0);
    var t = n * n + i * i;
    return t !== 0 ? new e(n / t, -i / t).asinh() : new e(n !== 0 ? n / 0 : 0, i !== 0 ? -i / 0 : 0).asinh();
  }
  asech() {
    var n = this.re, i = this.im;
    if (this.isZero()) return e.INFINITY;
    var t = n * n + i * i;
    return t !== 0 ? new e(n / t, -i / t).acosh() : new e(n !== 0 ? n / 0 : 0, i !== 0 ? -i / 0 : 0).acosh();
  }
  inverse() {
    if (this.isZero()) return e.INFINITY;
    if (this.isInfinite()) return e.ZERO;
    var n = this.re, i = this.im, t = n * n + i * i;
    return new e(n / t, -i / t);
  }
  conjugate() {
    return new e(this.re, -this.im);
  }
  neg() {
    return new e(-this.re, -this.im);
  }
  ceil(n) {
    return n = Math.pow(10, n || 0), new e(Math.ceil(this.re * n) / n, Math.ceil(this.im * n) / n);
  }
  floor(n) {
    return n = Math.pow(10, n || 0), new e(Math.floor(this.re * n) / n, Math.floor(this.im * n) / n);
  }
  round(n) {
    return n = Math.pow(10, n || 0), new e(Math.round(this.re * n) / n, Math.round(this.im * n) / n);
  }
  equals(n, i) {
    var t = new e(n, i);
    return Math.abs(t.re - this.re) <= e.EPSILON && Math.abs(t.im - this.im) <= e.EPSILON;
  }
  clone() {
    return new e(this.re, this.im);
  }
  toString() {
    var n = this.re, i = this.im, t = "";
    return this.isNaN() ? "NaN" : this.isInfinite() ? "Infinity" : (Math.abs(n) < e.EPSILON && (n = 0), Math.abs(i) < e.EPSILON && (i = 0), i === 0 ? t + n : (n !== 0 ? (t += n, t += " ", i < 0 ? (i = -i, t += "-") : t += "+", t += " ") : i < 0 && (i = -i, t += "-"), i !== 1 && (t += i), t + "i"));
  }
  toVector() {
    return [this.re, this.im];
  }
  valueOf() {
    return this.im === 0 ? this.re : null;
  }
  isNaN() {
    return isNaN(this.re) || isNaN(this.im);
  }
  isZero() {
    return this.im === 0 && this.re === 0;
  }
  isFinite() {
    return isFinite(this.re) && isFinite(this.im);
  }
  isInfinite() {
    return !(this.isNaN() || this.isFinite());
  }
};
$.ZERO = new $(0, 0);
$.ONE = new $(1, 0);
$.I = new $(0, 1);
$.PI = new $(Math.PI, 0);
$.E = new $(Math.E, 0);
$.INFINITY = new $(1 / 0, 1 / 0);
$.NAN = new $(NaN, NaN);
$.EPSILON = 1e-15;
var Si = 9e15;
var qn = 1e9;
var hs = "0123456789abcdef";
var ur = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
var lr = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
var gs = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -Si, maxE: Si, crypto: false };
var ha;
var Tn;
var w = true;
var cr = "[DecimalError] ";
var Fn = cr + "Invalid argument: ";
var ga = cr + "Precision limit exceeded";
var xa = cr + "crypto unavailable";
var ya = "[object Decimal]";
var _e = Math.floor;
var he = Math.pow;
var cc = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
var pc = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
var dc = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
var ba = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var nn = 1e7;
var B = 7;
var mc = 9007199254740991;
var hc = ur.length - 1;
var xs = lr.length - 1;
var g = { toStringTag: ya };
g.absoluteValue = g.abs = function() {
  var e12 = new this.constructor(this);
  return e12.s < 0 && (e12.s = 1), S(e12);
};
g.ceil = function() {
  return S(new this.constructor(this), this.e + 1, 2);
};
g.clampedTo = g.clamp = function(e12, n) {
  var i, t = this, r = t.constructor;
  if (e12 = new r(e12), n = new r(n), !e12.s || !n.s) return new r(NaN);
  if (e12.gt(n)) throw Error(Fn + n);
  return i = t.cmp(e12), i < 0 ? e12 : t.cmp(n) > 0 ? n : new r(t);
};
g.comparedTo = g.cmp = function(e12) {
  var n, i, t, r, s = this, o = s.d, a = (e12 = new s.constructor(e12)).d, u = s.s, l = e12.s;
  if (!o || !a) return !u || !l ? NaN : u !== l ? u : o === a ? 0 : !o ^ u < 0 ? 1 : -1;
  if (!o[0] || !a[0]) return o[0] ? u : a[0] ? -l : 0;
  if (u !== l) return u;
  if (s.e !== e12.e) return s.e > e12.e ^ u < 0 ? 1 : -1;
  for (t = o.length, r = a.length, n = 0, i = t < r ? t : r; n < i; ++n) if (o[n] !== a[n]) return o[n] > a[n] ^ u < 0 ? 1 : -1;
  return t === r ? 0 : t > r ^ u < 0 ? 1 : -1;
};
g.cosine = g.cos = function() {
  var e12, n, i = this, t = i.constructor;
  return i.d ? i.d[0] ? (e12 = t.precision, n = t.rounding, t.precision = e12 + Math.max(i.e, i.sd()) + B, t.rounding = 1, i = gc(t, Sa(t, i)), t.precision = e12, t.rounding = n, S(Tn == 2 || Tn == 3 ? i.neg() : i, e12, n, true)) : new t(1) : new t(NaN);
};
g.cubeRoot = g.cbrt = function() {
  var e12, n, i, t, r, s, o, a, u, l, f = this, c = f.constructor;
  if (!f.isFinite() || f.isZero()) return new c(f);
  for (w = false, s = f.s * he(f.s * f, 1 / 3), !s || Math.abs(s) == 1 / 0 ? (i = Ne(f.d), e12 = f.e, (s = (e12 - i.length + 1) % 3) && (i += s == 1 || s == -2 ? "0" : "00"), s = he(i, 1 / 3), e12 = _e((e12 + 1) / 3) - (e12 % 3 == (e12 < 0 ? -1 : 2)), s == 1 / 0 ? i = "5e" + e12 : (i = s.toExponential(), i = i.slice(0, i.indexOf("e") + 1) + e12), t = new c(i), t.s = f.s) : t = new c(s.toString()), o = (e12 = c.precision) + 3; ; ) if (a = t, u = a.times(a).times(a), l = u.plus(f), t = j(l.plus(f).times(a), l.plus(u), o + 2, 1), Ne(a.d).slice(0, o) === (i = Ne(t.d)).slice(0, o)) if (i = i.slice(o - 3, o + 1), i == "9999" || !r && i == "4999") {
    if (!r && (S(a, e12 + 1, 0), a.times(a).times(a).eq(f))) {
      t = a;
      break;
    }
    o += 4, r = 1;
  } else {
    (!+i || !+i.slice(1) && i.charAt(0) == "5") && (S(t, e12 + 1, 1), n = !t.times(t).times(t).eq(f));
    break;
  }
  return w = true, S(t, e12, c.rounding, n);
};
g.decimalPlaces = g.dp = function() {
  var e12, n = this.d, i = NaN;
  if (n) {
    if (e12 = n.length - 1, i = (e12 - _e(this.e / B)) * B, e12 = n[e12], e12) for (; e12 % 10 == 0; e12 /= 10) i--;
    i < 0 && (i = 0);
  }
  return i;
};
g.dividedBy = g.div = function(e12) {
  return j(this, new this.constructor(e12));
};
g.dividedToIntegerBy = g.divToInt = function(e12) {
  var n = this, i = n.constructor;
  return S(j(n, new i(e12), 0, 1, 1), i.precision, i.rounding);
};
g.equals = g.eq = function(e12) {
  return this.cmp(e12) === 0;
};
g.floor = function() {
  return S(new this.constructor(this), this.e + 1, 3);
};
g.greaterThan = g.gt = function(e12) {
  return this.cmp(e12) > 0;
};
g.greaterThanOrEqualTo = g.gte = function(e12) {
  var n = this.cmp(e12);
  return n == 1 || n === 0;
};
g.hyperbolicCosine = g.cosh = function() {
  var e12, n, i, t, r, s = this, o = s.constructor, a = new o(1);
  if (!s.isFinite()) return new o(s.s ? 1 / 0 : NaN);
  if (s.isZero()) return a;
  i = o.precision, t = o.rounding, o.precision = i + Math.max(s.e, s.sd()) + 4, o.rounding = 1, r = s.d.length, r < 32 ? (e12 = Math.ceil(r / 3), n = (1 / dr(4, e12)).toString()) : (e12 = 16, n = "2.3283064365386962890625e-10"), s = _i(o, 1, s.times(n), new o(1), true);
  for (var u, l = e12, f = new o(8); l--; ) u = s.times(s), s = a.minus(u.times(f.minus(u.times(f))));
  return S(s, o.precision = i, o.rounding = t, true);
};
g.hyperbolicSine = g.sinh = function() {
  var e12, n, i, t, r = this, s = r.constructor;
  if (!r.isFinite() || r.isZero()) return new s(r);
  if (n = s.precision, i = s.rounding, s.precision = n + Math.max(r.e, r.sd()) + 4, s.rounding = 1, t = r.d.length, t < 3) r = _i(s, 2, r, r, true);
  else {
    e12 = 1.4 * Math.sqrt(t), e12 = e12 > 16 ? 16 : e12 | 0, r = r.times(1 / dr(5, e12)), r = _i(s, 2, r, r, true);
    for (var o, a = new s(5), u = new s(16), l = new s(20); e12--; ) o = r.times(r), r = r.times(a.plus(o.times(u.times(o).plus(l))));
  }
  return s.precision = n, s.rounding = i, S(r, n, i, true);
};
g.hyperbolicTangent = g.tanh = function() {
  var e12, n, i = this, t = i.constructor;
  return i.isFinite() ? i.isZero() ? new t(i) : (e12 = t.precision, n = t.rounding, t.precision = e12 + 7, t.rounding = 1, j(i.sinh(), i.cosh(), t.precision = e12, t.rounding = n)) : new t(i.s);
};
g.inverseCosine = g.acos = function() {
  var e12 = this, n = e12.constructor, i = e12.abs().cmp(1), t = n.precision, r = n.rounding;
  return i !== -1 ? i === 0 ? e12.isNeg() ? ln(n, t, r) : new n(0) : new n(NaN) : e12.isZero() ? ln(n, t + 4, r).times(0.5) : (n.precision = t + 6, n.rounding = 1, e12 = new n(1).minus(e12).div(e12.plus(1)).sqrt().atan(), n.precision = t, n.rounding = r, e12.times(2));
};
g.inverseHyperbolicCosine = g.acosh = function() {
  var e12, n, i = this, t = i.constructor;
  return i.lte(1) ? new t(i.eq(1) ? 0 : NaN) : i.isFinite() ? (e12 = t.precision, n = t.rounding, t.precision = e12 + Math.max(Math.abs(i.e), i.sd()) + 4, t.rounding = 1, w = false, i = i.times(i).minus(1).sqrt().plus(i), w = true, t.precision = e12, t.rounding = n, i.ln()) : new t(i);
};
g.inverseHyperbolicSine = g.asinh = function() {
  var e12, n, i = this, t = i.constructor;
  return !i.isFinite() || i.isZero() ? new t(i) : (e12 = t.precision, n = t.rounding, t.precision = e12 + 2 * Math.max(Math.abs(i.e), i.sd()) + 6, t.rounding = 1, w = false, i = i.times(i).plus(1).sqrt().plus(i), w = true, t.precision = e12, t.rounding = n, i.ln());
};
g.inverseHyperbolicTangent = g.atanh = function() {
  var e12, n, i, t, r = this, s = r.constructor;
  return r.isFinite() ? r.e >= 0 ? new s(r.abs().eq(1) ? r.s / 0 : r.isZero() ? r : NaN) : (e12 = s.precision, n = s.rounding, t = r.sd(), Math.max(t, e12) < 2 * -r.e - 1 ? S(new s(r), e12, n, true) : (s.precision = i = t - r.e, r = j(r.plus(1), new s(1).minus(r), i + e12, 1), s.precision = e12 + 4, s.rounding = 1, r = r.ln(), s.precision = e12, s.rounding = n, r.times(0.5))) : new s(NaN);
};
g.inverseSine = g.asin = function() {
  var e12, n, i, t, r = this, s = r.constructor;
  return r.isZero() ? new s(r) : (n = r.abs().cmp(1), i = s.precision, t = s.rounding, n !== -1 ? n === 0 ? (e12 = ln(s, i + 4, t).times(0.5), e12.s = r.s, e12) : new s(NaN) : (s.precision = i + 6, s.rounding = 1, r = r.div(new s(1).minus(r.times(r)).sqrt().plus(1)).atan(), s.precision = i, s.rounding = t, r.times(2)));
};
g.inverseTangent = g.atan = function() {
  var e12, n, i, t, r, s, o, a, u, l = this, f = l.constructor, c = f.precision, p = f.rounding;
  if (l.isFinite()) {
    if (l.isZero()) return new f(l);
    if (l.abs().eq(1) && c + 4 <= xs) return o = ln(f, c + 4, p).times(0.25), o.s = l.s, o;
  } else {
    if (!l.s) return new f(NaN);
    if (c + 4 <= xs) return o = ln(f, c + 4, p).times(0.5), o.s = l.s, o;
  }
  for (f.precision = a = c + 10, f.rounding = 1, i = Math.min(28, a / B + 2 | 0), e12 = i; e12; --e12) l = l.div(l.times(l).plus(1).sqrt().plus(1));
  for (w = false, n = Math.ceil(a / B), t = 1, u = l.times(l), o = new f(l), r = l; e12 !== -1; ) if (r = r.times(u), s = o.minus(r.div(t += 2)), r = r.times(u), o = s.plus(r.div(t += 2)), o.d[n] !== void 0) for (e12 = n; o.d[e12] === s.d[e12] && e12--; ) ;
  return i && (o = o.times(2 << i - 1)), w = true, S(o, f.precision = c, f.rounding = p, true);
};
g.isFinite = function() {
  return !!this.d;
};
g.isInteger = g.isInt = function() {
  return !!this.d && _e(this.e / B) > this.d.length - 2;
};
g.isNaN = function() {
  return !this.s;
};
g.isNegative = g.isNeg = function() {
  return this.s < 0;
};
g.isPositive = g.isPos = function() {
  return this.s > 0;
};
g.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
g.lessThan = g.lt = function(e12) {
  return this.cmp(e12) < 0;
};
g.lessThanOrEqualTo = g.lte = function(e12) {
  return this.cmp(e12) < 1;
};
g.logarithm = g.log = function(e12) {
  var n, i, t, r, s, o, a, u, l = this, f = l.constructor, c = f.precision, p = f.rounding, m = 5;
  if (e12 == null) e12 = new f(10), n = true;
  else {
    if (e12 = new f(e12), i = e12.d, e12.s < 0 || !i || !i[0] || e12.eq(1)) return new f(NaN);
    n = e12.eq(10);
  }
  if (i = l.d, l.s < 0 || !i || !i[0] || l.eq(1)) return new f(i && !i[0] ? -1 / 0 : l.s != 1 ? NaN : i ? 0 : 1 / 0);
  if (n) if (i.length > 1) s = true;
  else {
    for (r = i[0]; r % 10 === 0; ) r /= 10;
    s = r !== 1;
  }
  if (w = false, a = c + m, o = Ln(l, a), t = n ? fr(f, a + 10) : Ln(e12, a), u = j(o, t, a, 1), ht(u.d, r = c, p)) do
    if (a += 10, o = Ln(l, a), t = n ? fr(f, a + 10) : Ln(e12, a), u = j(o, t, a, 1), !s) {
      +Ne(u.d).slice(r + 1, r + 15) + 1 == 1e14 && (u = S(u, c + 1, 0));
      break;
    }
  while (ht(u.d, r += 10, p));
  return w = true, S(u, c, p);
};
g.minus = g.sub = function(e12) {
  var n, i, t, r, s, o, a, u, l, f, c, p, m = this, y = m.constructor;
  if (e12 = new y(e12), !m.d || !e12.d) return !m.s || !e12.s ? e12 = new y(NaN) : m.d ? e12.s = -e12.s : e12 = new y(e12.d || m.s !== e12.s ? m : NaN), e12;
  if (m.s != e12.s) return e12.s = -e12.s, m.plus(e12);
  if (l = m.d, p = e12.d, a = y.precision, u = y.rounding, !l[0] || !p[0]) {
    if (p[0]) e12.s = -e12.s;
    else if (l[0]) e12 = new y(m);
    else return new y(u === 3 ? -0 : 0);
    return w ? S(e12, a, u) : e12;
  }
  if (i = _e(e12.e / B), f = _e(m.e / B), l = l.slice(), s = f - i, s) {
    for (c = s < 0, c ? (n = l, s = -s, o = p.length) : (n = p, i = f, o = l.length), t = Math.max(Math.ceil(a / B), o) + 2, s > t && (s = t, n.length = 1), n.reverse(), t = s; t--; ) n.push(0);
    n.reverse();
  } else {
    for (t = l.length, o = p.length, c = t < o, c && (o = t), t = 0; t < o; t++) if (l[t] != p[t]) {
      c = l[t] < p[t];
      break;
    }
    s = 0;
  }
  for (c && (n = l, l = p, p = n, e12.s = -e12.s), o = l.length, t = p.length - o; t > 0; --t) l[o++] = 0;
  for (t = p.length; t > s; ) {
    if (l[--t] < p[t]) {
      for (r = t; r && l[--r] === 0; ) l[r] = nn - 1;
      --l[r], l[t] += nn;
    }
    l[t] -= p[t];
  }
  for (; l[--o] === 0; ) l.pop();
  for (; l[0] === 0; l.shift()) --i;
  return l[0] ? (e12.d = l, e12.e = pr(l, i), w ? S(e12, a, u) : e12) : new y(u === 3 ? -0 : 0);
};
g.modulo = g.mod = function(e12) {
  var n, i = this, t = i.constructor;
  return e12 = new t(e12), !i.d || !e12.s || e12.d && !e12.d[0] ? new t(NaN) : !e12.d || i.d && !i.d[0] ? S(new t(i), t.precision, t.rounding) : (w = false, t.modulo == 9 ? (n = j(i, e12.abs(), 0, 3, 1), n.s *= e12.s) : n = j(i, e12, 0, t.modulo, 1), n = n.times(e12), w = true, i.minus(n));
};
g.naturalExponential = g.exp = function() {
  return ys(this);
};
g.naturalLogarithm = g.ln = function() {
  return Ln(this);
};
g.negated = g.neg = function() {
  var e12 = new this.constructor(this);
  return e12.s = -e12.s, S(e12);
};
g.plus = g.add = function(e12) {
  var n, i, t, r, s, o, a, u, l, f, c = this, p = c.constructor;
  if (e12 = new p(e12), !c.d || !e12.d) return !c.s || !e12.s ? e12 = new p(NaN) : c.d || (e12 = new p(e12.d || c.s === e12.s ? c : NaN)), e12;
  if (c.s != e12.s) return e12.s = -e12.s, c.minus(e12);
  if (l = c.d, f = e12.d, a = p.precision, u = p.rounding, !l[0] || !f[0]) return f[0] || (e12 = new p(c)), w ? S(e12, a, u) : e12;
  if (s = _e(c.e / B), t = _e(e12.e / B), l = l.slice(), r = s - t, r) {
    for (r < 0 ? (i = l, r = -r, o = f.length) : (i = f, t = s, o = l.length), s = Math.ceil(a / B), o = s > o ? s + 1 : o + 1, r > o && (r = o, i.length = 1), i.reverse(); r--; ) i.push(0);
    i.reverse();
  }
  for (o = l.length, r = f.length, o - r < 0 && (r = o, i = f, f = l, l = i), n = 0; r; ) n = (l[--r] = l[r] + f[r] + n) / nn | 0, l[r] %= nn;
  for (n && (l.unshift(n), ++t), o = l.length; l[--o] == 0; ) l.pop();
  return e12.d = l, e12.e = pr(l, t), w ? S(e12, a, u) : e12;
};
g.precision = g.sd = function(e12) {
  var n, i = this;
  if (e12 !== void 0 && e12 !== !!e12 && e12 !== 1 && e12 !== 0) throw Error(Fn + e12);
  return i.d ? (n = Ea(i.d), e12 && i.e + 1 > n && (n = i.e + 1)) : n = NaN, n;
};
g.round = function() {
  var e12 = this, n = e12.constructor;
  return S(new n(e12), e12.e + 1, n.rounding);
};
g.sine = g.sin = function() {
  var e12, n, i = this, t = i.constructor;
  return i.isFinite() ? i.isZero() ? new t(i) : (e12 = t.precision, n = t.rounding, t.precision = e12 + Math.max(i.e, i.sd()) + B, t.rounding = 1, i = yc(t, Sa(t, i)), t.precision = e12, t.rounding = n, S(Tn > 2 ? i.neg() : i, e12, n, true)) : new t(NaN);
};
g.squareRoot = g.sqrt = function() {
  var e12, n, i, t, r, s, o = this, a = o.d, u = o.e, l = o.s, f = o.constructor;
  if (l !== 1 || !a || !a[0]) return new f(!l || l < 0 && (!a || a[0]) ? NaN : a ? o : 1 / 0);
  for (w = false, l = Math.sqrt(+o), l == 0 || l == 1 / 0 ? (n = Ne(a), (n.length + u) % 2 == 0 && (n += "0"), l = Math.sqrt(n), u = _e((u + 1) / 2) - (u < 0 || u % 2), l == 1 / 0 ? n = "5e" + u : (n = l.toExponential(), n = n.slice(0, n.indexOf("e") + 1) + u), t = new f(n)) : t = new f(l.toString()), i = (u = f.precision) + 3; ; ) if (s = t, t = s.plus(j(o, s, i + 2, 1)).times(0.5), Ne(s.d).slice(0, i) === (n = Ne(t.d)).slice(0, i)) if (n = n.slice(i - 3, i + 1), n == "9999" || !r && n == "4999") {
    if (!r && (S(s, u + 1, 0), s.times(s).eq(o))) {
      t = s;
      break;
    }
    i += 4, r = 1;
  } else {
    (!+n || !+n.slice(1) && n.charAt(0) == "5") && (S(t, u + 1, 1), e12 = !t.times(t).eq(o));
    break;
  }
  return w = true, S(t, u, f.rounding, e12);
};
g.tangent = g.tan = function() {
  var e12, n, i = this, t = i.constructor;
  return i.isFinite() ? i.isZero() ? new t(i) : (e12 = t.precision, n = t.rounding, t.precision = e12 + 10, t.rounding = 1, i = i.sin(), i.s = 1, i = j(i, new t(1).minus(i.times(i)).sqrt(), e12 + 10, 0), t.precision = e12, t.rounding = n, S(Tn == 2 || Tn == 4 ? i.neg() : i, e12, n, true)) : new t(NaN);
};
g.times = g.mul = function(e12) {
  var n, i, t, r, s, o, a, u, l, f = this, c = f.constructor, p = f.d, m = (e12 = new c(e12)).d;
  if (e12.s *= f.s, !p || !p[0] || !m || !m[0]) return new c(!e12.s || p && !p[0] && !m || m && !m[0] && !p ? NaN : !p || !m ? e12.s / 0 : e12.s * 0);
  for (i = _e(f.e / B) + _e(e12.e / B), u = p.length, l = m.length, u < l && (s = p, p = m, m = s, o = u, u = l, l = o), s = [], o = u + l, t = o; t--; ) s.push(0);
  for (t = l; --t >= 0; ) {
    for (n = 0, r = u + t; r > t; ) a = s[r] + m[t] * p[r - t - 1] + n, s[r--] = a % nn | 0, n = a / nn | 0;
    s[r] = (s[r] + n) % nn | 0;
  }
  for (; !s[--o]; ) s.pop();
  return n ? ++i : s.shift(), e12.d = s, e12.e = pr(s, i), w ? S(e12, c.precision, c.rounding) : e12;
};
g.toBinary = function(e12, n) {
  return bs(this, 2, e12, n);
};
g.toDecimalPlaces = g.toDP = function(e12, n) {
  var i = this, t = i.constructor;
  return i = new t(i), e12 === void 0 ? i : (Re(e12, 0, qn), n === void 0 ? n = t.rounding : Re(n, 0, 8), S(i, e12 + i.e + 1, n));
};
g.toExponential = function(e12, n) {
  var i, t = this, r = t.constructor;
  return e12 === void 0 ? i = fn(t, true) : (Re(e12, 0, qn), n === void 0 ? n = r.rounding : Re(n, 0, 8), t = S(new r(t), e12 + 1, n), i = fn(t, true, e12 + 1)), t.isNeg() && !t.isZero() ? "-" + i : i;
};
g.toFixed = function(e12, n) {
  var i, t, r = this, s = r.constructor;
  return e12 === void 0 ? i = fn(r) : (Re(e12, 0, qn), n === void 0 ? n = s.rounding : Re(n, 0, 8), t = S(new s(r), e12 + r.e + 1, n), i = fn(t, false, e12 + t.e + 1)), r.isNeg() && !r.isZero() ? "-" + i : i;
};
g.toFraction = function(e12) {
  var n, i, t, r, s, o, a, u, l, f, c, p, m = this, y = m.d, x = m.constructor;
  if (!y) return new x(m);
  if (l = i = new x(1), t = u = new x(0), n = new x(t), s = n.e = Ea(y) - m.e - 1, o = s % B, n.d[0] = he(10, o < 0 ? B + o : o), e12 == null) e12 = s > 0 ? n : l;
  else {
    if (a = new x(e12), !a.isInt() || a.lt(l)) throw Error(Fn + a);
    e12 = a.gt(n) ? s > 0 ? n : l : a;
  }
  for (w = false, a = new x(Ne(y)), f = x.precision, x.precision = s = y.length * B * 2; c = j(a, n, 0, 1, 1), r = i.plus(c.times(t)), r.cmp(e12) != 1; ) i = t, t = r, r = l, l = u.plus(c.times(r)), u = r, r = n, n = a.minus(c.times(r)), a = r;
  return r = j(e12.minus(i), t, 0, 1, 1), u = u.plus(r.times(l)), i = i.plus(r.times(t)), u.s = l.s = m.s, p = j(l, t, s, 1).minus(m).abs().cmp(j(u, i, s, 1).minus(m).abs()) < 1 ? [l, t] : [u, i], x.precision = f, w = true, p;
};
g.toHexadecimal = g.toHex = function(e12, n) {
  return bs(this, 16, e12, n);
};
g.toNearest = function(e12, n) {
  var i = this, t = i.constructor;
  if (i = new t(i), e12 == null) {
    if (!i.d) return i;
    e12 = new t(1), n = t.rounding;
  } else {
    if (e12 = new t(e12), n === void 0 ? n = t.rounding : Re(n, 0, 8), !i.d) return e12.s ? i : e12;
    if (!e12.d) return e12.s && (e12.s = i.s), e12;
  }
  return e12.d[0] ? (w = false, i = j(i, e12, 0, n, 1).times(e12), w = true, S(i)) : (e12.s = i.s, i = e12), i;
};
g.toNumber = function() {
  return +this;
};
g.toOctal = function(e12, n) {
  return bs(this, 8, e12, n);
};
g.toPower = g.pow = function(e12) {
  var n, i, t, r, s, o, a = this, u = a.constructor, l = +(e12 = new u(e12));
  if (!a.d || !e12.d || !a.d[0] || !e12.d[0]) return new u(he(+a, l));
  if (a = new u(a), a.eq(1)) return a;
  if (t = u.precision, s = u.rounding, e12.eq(1)) return S(a, t, s);
  if (n = _e(e12.e / B), n >= e12.d.length - 1 && (i = l < 0 ? -l : l) <= mc) return r = Na(u, a, i, t), e12.s < 0 ? new u(1).div(r) : S(r, t, s);
  if (o = a.s, o < 0) {
    if (n < e12.d.length - 1) return new u(NaN);
    if (e12.d[n] & 1 || (o = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1) return a.s = o, a;
  }
  return i = he(+a, l), n = i == 0 || !isFinite(i) ? _e(l * (Math.log("0." + Ne(a.d)) / Math.LN10 + a.e + 1)) : new u(i + "").e, n > u.maxE + 1 || n < u.minE - 1 ? new u(n > 0 ? o / 0 : 0) : (w = false, u.rounding = a.s = 1, i = Math.min(12, (n + "").length), r = ys(e12.times(Ln(a, t + i)), t), r.d && (r = S(r, t + 5, 1), ht(r.d, t, s) && (n = t + 10, r = S(ys(e12.times(Ln(a, n + i)), n), n + 5, 1), +Ne(r.d).slice(t + 1, t + 15) + 1 == 1e14 && (r = S(r, t + 1, 0)))), r.s = o, w = true, u.rounding = s, S(r, t, s));
};
g.toPrecision = function(e12, n) {
  var i, t = this, r = t.constructor;
  return e12 === void 0 ? i = fn(t, t.e <= r.toExpNeg || t.e >= r.toExpPos) : (Re(e12, 1, qn), n === void 0 ? n = r.rounding : Re(n, 0, 8), t = S(new r(t), e12, n), i = fn(t, e12 <= t.e || t.e <= r.toExpNeg, e12)), t.isNeg() && !t.isZero() ? "-" + i : i;
};
g.toSignificantDigits = g.toSD = function(e12, n) {
  var i = this, t = i.constructor;
  return e12 === void 0 ? (e12 = t.precision, n = t.rounding) : (Re(e12, 1, qn), n === void 0 ? n = t.rounding : Re(n, 0, 8)), S(new t(i), e12, n);
};
g.toString = function() {
  var e12 = this, n = e12.constructor, i = fn(e12, e12.e <= n.toExpNeg || e12.e >= n.toExpPos);
  return e12.isNeg() && !e12.isZero() ? "-" + i : i;
};
g.truncated = g.trunc = function() {
  return S(new this.constructor(this), this.e + 1, 1);
};
g.valueOf = g.toJSON = function() {
  var e12 = this, n = e12.constructor, i = fn(e12, e12.e <= n.toExpNeg || e12.e >= n.toExpPos);
  return e12.isNeg() ? "-" + i : i;
};
function Ne(e12) {
  var n, i, t, r = e12.length - 1, s = "", o = e12[0];
  if (r > 0) {
    for (s += o, n = 1; n < r; n++) t = e12[n] + "", i = B - t.length, i && (s += On(i)), s += t;
    o = e12[n], t = o + "", i = B - t.length, i && (s += On(i));
  } else if (o === 0) return "0";
  for (; o % 10 === 0; ) o /= 10;
  return s + o;
}
function Re(e12, n, i) {
  if (e12 !== ~~e12 || e12 < n || e12 > i) throw Error(Fn + e12);
}
function ht(e12, n, i, t) {
  var r, s, o, a;
  for (s = e12[0]; s >= 10; s /= 10) --n;
  return --n < 0 ? (n += B, r = 0) : (r = Math.ceil((n + 1) / B), n %= B), s = he(10, B - n), a = e12[r] % s | 0, t == null ? n < 3 ? (n == 0 ? a = a / 100 | 0 : n == 1 && (a = a / 10 | 0), o = i < 4 && a == 99999 || i > 3 && a == 49999 || a == 5e4 || a == 0) : o = (i < 4 && a + 1 == s || i > 3 && a + 1 == s / 2) && (e12[r + 1] / s / 100 | 0) == he(10, n - 2) - 1 || (a == s / 2 || a == 0) && (e12[r + 1] / s / 100 | 0) == 0 : n < 4 ? (n == 0 ? a = a / 1e3 | 0 : n == 1 ? a = a / 100 | 0 : n == 2 && (a = a / 10 | 0), o = (t || i < 4) && a == 9999 || !t && i > 3 && a == 4999) : o = ((t || i < 4) && a + 1 == s || !t && i > 3 && a + 1 == s / 2) && (e12[r + 1] / s / 1e3 | 0) == he(10, n - 3) - 1, o;
}
function or(e12, n, i) {
  for (var t, r = [0], s, o = 0, a = e12.length; o < a; ) {
    for (s = r.length; s--; ) r[s] *= n;
    for (r[0] += hs.indexOf(e12.charAt(o++)), t = 0; t < r.length; t++) r[t] > i - 1 && (r[t + 1] === void 0 && (r[t + 1] = 0), r[t + 1] += r[t] / i | 0, r[t] %= i);
  }
  return r.reverse();
}
function gc(e12, n) {
  var i, t, r;
  if (n.isZero()) return n;
  t = n.d.length, t < 32 ? (i = Math.ceil(t / 3), r = (1 / dr(4, i)).toString()) : (i = 16, r = "2.3283064365386962890625e-10"), e12.precision += i, n = _i(e12, 1, n.times(r), new e12(1));
  for (var s = i; s--; ) {
    var o = n.times(n);
    n = o.times(o).minus(o).times(8).plus(1);
  }
  return e12.precision -= i, n;
}
var j = /* @__PURE__ */ function() {
  function e12(t, r, s) {
    var o, a = 0, u = t.length;
    for (t = t.slice(); u--; ) o = t[u] * r + a, t[u] = o % s | 0, a = o / s | 0;
    return a && t.unshift(a), t;
  }
  function n(t, r, s, o) {
    var a, u;
    if (s != o) u = s > o ? 1 : -1;
    else for (a = u = 0; a < s; a++) if (t[a] != r[a]) {
      u = t[a] > r[a] ? 1 : -1;
      break;
    }
    return u;
  }
  function i(t, r, s, o) {
    for (var a = 0; s--; ) t[s] -= a, a = t[s] < r[s] ? 1 : 0, t[s] = a * o + t[s] - r[s];
    for (; !t[0] && t.length > 1; ) t.shift();
  }
  return function(t, r, s, o, a, u) {
    var l, f, c, p, m, y, x, E, _, R, I, q, be, Ee, vi, tr, mt, ps, en, rr, sr = t.constructor, ds = t.s == r.s ? 1 : -1, Te = t.d, W = r.d;
    if (!Te || !Te[0] || !W || !W[0]) return new sr(!t.s || !r.s || (Te ? W && Te[0] == W[0] : !W) ? NaN : Te && Te[0] == 0 || !W ? ds * 0 : ds / 0);
    for (u ? (m = 1, f = t.e - r.e) : (u = nn, m = B, f = _e(t.e / m) - _e(r.e / m)), en = W.length, mt = Te.length, _ = new sr(ds), R = _.d = [], c = 0; W[c] == (Te[c] || 0); c++) ;
    if (W[c] > (Te[c] || 0) && f--, s == null ? (Ee = s = sr.precision, o = sr.rounding) : a ? Ee = s + (t.e - r.e) + 1 : Ee = s, Ee < 0) R.push(1), y = true;
    else {
      if (Ee = Ee / m + 2 | 0, c = 0, en == 1) {
        for (p = 0, W = W[0], Ee++; (c < mt || p) && Ee--; c++) vi = p * u + (Te[c] || 0), R[c] = vi / W | 0, p = vi % W | 0;
        y = p || c < mt;
      } else {
        for (p = u / (W[0] + 1) | 0, p > 1 && (W = e12(W, p, u), Te = e12(Te, p, u), en = W.length, mt = Te.length), tr = en, I = Te.slice(0, en), q = I.length; q < en; ) I[q++] = 0;
        rr = W.slice(), rr.unshift(0), ps = W[0], W[1] >= u / 2 && ++ps;
        do
          p = 0, l = n(W, I, en, q), l < 0 ? (be = I[0], en != q && (be = be * u + (I[1] || 0)), p = be / ps | 0, p > 1 ? (p >= u && (p = u - 1), x = e12(W, p, u), E = x.length, q = I.length, l = n(x, I, E, q), l == 1 && (p--, i(x, en < E ? rr : W, E, u))) : (p == 0 && (l = p = 1), x = W.slice()), E = x.length, E < q && x.unshift(0), i(I, x, q, u), l == -1 && (q = I.length, l = n(W, I, en, q), l < 1 && (p++, i(I, en < q ? rr : W, q, u))), q = I.length) : l === 0 && (p++, I = [0]), R[c++] = p, l && I[0] ? I[q++] = Te[tr] || 0 : (I = [Te[tr]], q = 1);
        while ((tr++ < mt || I[0] !== void 0) && Ee--);
        y = I[0] !== void 0;
      }
      R[0] || R.shift();
    }
    if (m == 1) _.e = f, ha = y;
    else {
      for (c = 1, p = R[0]; p >= 10; p /= 10) c++;
      _.e = c + f * m - 1, S(_, a ? s + _.e + 1 : s, o, y);
    }
    return _;
  };
}();
function S(e12, n, i, t) {
  var r, s, o, a, u, l, f, c, p, m = e12.constructor;
  e: if (n != null) {
    if (c = e12.d, !c) return e12;
    for (r = 1, a = c[0]; a >= 10; a /= 10) r++;
    if (s = n - r, s < 0) s += B, o = n, f = c[p = 0], u = f / he(10, r - o - 1) % 10 | 0;
    else if (p = Math.ceil((s + 1) / B), a = c.length, p >= a) if (t) {
      for (; a++ <= p; ) c.push(0);
      f = u = 0, r = 1, s %= B, o = s - B + 1;
    } else break e;
    else {
      for (f = a = c[p], r = 1; a >= 10; a /= 10) r++;
      s %= B, o = s - B + r, u = o < 0 ? 0 : f / he(10, r - o - 1) % 10 | 0;
    }
    if (t = t || n < 0 || c[p + 1] !== void 0 || (o < 0 ? f : f % he(10, r - o - 1)), l = i < 4 ? (u || t) && (i == 0 || i == (e12.s < 0 ? 3 : 2)) : u > 5 || u == 5 && (i == 4 || t || i == 6 && (s > 0 ? o > 0 ? f / he(10, r - o) : 0 : c[p - 1]) % 10 & 1 || i == (e12.s < 0 ? 8 : 7)), n < 1 || !c[0]) return c.length = 0, l ? (n -= e12.e + 1, c[0] = he(10, (B - n % B) % B), e12.e = -n || 0) : c[0] = e12.e = 0, e12;
    if (s == 0 ? (c.length = p, a = 1, p--) : (c.length = p + 1, a = he(10, B - s), c[p] = o > 0 ? (f / he(10, r - o) % he(10, o) | 0) * a : 0), l) for (; ; ) if (p == 0) {
      for (s = 1, o = c[0]; o >= 10; o /= 10) s++;
      for (o = c[0] += a, a = 1; o >= 10; o /= 10) a++;
      s != a && (e12.e++, c[0] == nn && (c[0] = 1));
      break;
    } else {
      if (c[p] += a, c[p] != nn) break;
      c[p--] = 0, a = 1;
    }
    for (s = c.length; c[--s] === 0; ) c.pop();
  }
  return w && (e12.e > m.maxE ? (e12.d = null, e12.e = NaN) : e12.e < m.minE && (e12.e = 0, e12.d = [0])), e12;
}
function fn(e12, n, i) {
  if (!e12.isFinite()) return Ta(e12);
  var t, r = e12.e, s = Ne(e12.d), o = s.length;
  return n ? (i && (t = i - o) > 0 ? s = s.charAt(0) + "." + s.slice(1) + On(t) : o > 1 && (s = s.charAt(0) + "." + s.slice(1)), s = s + (e12.e < 0 ? "e" : "e+") + e12.e) : r < 0 ? (s = "0." + On(-r - 1) + s, i && (t = i - o) > 0 && (s += On(t))) : r >= o ? (s += On(r + 1 - o), i && (t = i - r - 1) > 0 && (s = s + "." + On(t))) : ((t = r + 1) < o && (s = s.slice(0, t) + "." + s.slice(t)), i && (t = i - o) > 0 && (r + 1 === o && (s += "."), s += On(t))), s;
}
function pr(e12, n) {
  var i = e12[0];
  for (n *= B; i >= 10; i /= 10) n++;
  return n;
}
function fr(e12, n, i) {
  if (n > hc) throw w = true, i && (e12.precision = i), Error(ga);
  return S(new e12(ur), n, 1, true);
}
function ln(e12, n, i) {
  if (n > xs) throw Error(ga);
  return S(new e12(lr), n, i, true);
}
function Ea(e12) {
  var n = e12.length - 1, i = n * B + 1;
  if (n = e12[n], n) {
    for (; n % 10 == 0; n /= 10) i--;
    for (n = e12[0]; n >= 10; n /= 10) i++;
  }
  return i;
}
function On(e12) {
  for (var n = ""; e12--; ) n += "0";
  return n;
}
function Na(e12, n, i, t) {
  var r, s = new e12(1), o = Math.ceil(t / B + 4);
  for (w = false; ; ) {
    if (i % 2 && (s = s.times(n), da(s.d, o) && (r = true)), i = _e(i / 2), i === 0) {
      i = s.d.length - 1, r && s.d[i] === 0 && ++s.d[i];
      break;
    }
    n = n.times(n), da(n.d, o);
  }
  return w = true, s;
}
function pa(e12) {
  return e12.d[e12.d.length - 1] & 1;
}
function va(e12, n, i) {
  for (var t, r, s = new e12(n[0]), o = 0; ++o < n.length; ) {
    if (r = new e12(n[o]), !r.s) {
      s = r;
      break;
    }
    t = s.cmp(r), (t === i || t === 0 && s.s === i) && (s = r);
  }
  return s;
}
function ys(e12, n) {
  var i, t, r, s, o, a, u, l = 0, f = 0, c = 0, p = e12.constructor, m = p.rounding, y = p.precision;
  if (!e12.d || !e12.d[0] || e12.e > 17) return new p(e12.d ? e12.d[0] ? e12.s < 0 ? 0 : 1 / 0 : 1 : e12.s ? e12.s < 0 ? 0 : e12 : NaN);
  for (n == null ? (w = false, u = y) : u = n, a = new p(0.03125); e12.e > -2; ) e12 = e12.times(a), c += 5;
  for (t = Math.log(he(2, c)) / Math.LN10 * 2 + 5 | 0, u += t, i = s = o = new p(1), p.precision = u; ; ) {
    if (s = S(s.times(e12), u, 1), i = i.times(++f), a = o.plus(j(s, i, u, 1)), Ne(a.d).slice(0, u) === Ne(o.d).slice(0, u)) {
      for (r = c; r--; ) o = S(o.times(o), u, 1);
      if (n == null) if (l < 3 && ht(o.d, u - t, m, l)) p.precision = u += 10, i = s = a = new p(1), f = 0, l++;
      else return S(o, p.precision = y, m, w = true);
      else return p.precision = y, o;
    }
    o = a;
  }
}
function Ln(e12, n) {
  var i, t, r, s, o, a, u, l, f, c, p, m = 1, y = 10, x = e12, E = x.d, _ = x.constructor, R = _.rounding, I = _.precision;
  if (x.s < 0 || !E || !E[0] || !x.e && E[0] == 1 && E.length == 1) return new _(E && !E[0] ? -1 / 0 : x.s != 1 ? NaN : E ? 0 : x);
  if (n == null ? (w = false, f = I) : f = n, _.precision = f += y, i = Ne(E), t = i.charAt(0), Math.abs(s = x.e) < 15e14) {
    for (; t < 7 && t != 1 || t == 1 && i.charAt(1) > 3; ) x = x.times(e12), i = Ne(x.d), t = i.charAt(0), m++;
    s = x.e, t > 1 ? (x = new _("0." + i), s++) : x = new _(t + "." + i.slice(1));
  } else return l = fr(_, f + 2, I).times(s + ""), x = Ln(new _(t + "." + i.slice(1)), f - y).plus(l), _.precision = I, n == null ? S(x, I, R, w = true) : x;
  for (c = x, u = o = x = j(x.minus(1), x.plus(1), f, 1), p = S(x.times(x), f, 1), r = 3; ; ) {
    if (o = S(o.times(p), f, 1), l = u.plus(j(o, new _(r), f, 1)), Ne(l.d).slice(0, f) === Ne(u.d).slice(0, f)) if (u = u.times(2), s !== 0 && (u = u.plus(fr(_, f + 2, I).times(s + ""))), u = j(u, new _(m), f, 1), n == null) if (ht(u.d, f - y, R, a)) _.precision = f += y, l = o = x = j(c.minus(1), c.plus(1), f, 1), p = S(x.times(x), f, 1), r = a = 1;
    else return S(u, _.precision = I, R, w = true);
    else return _.precision = I, u;
    u = l, r += 2;
  }
}
function Ta(e12) {
  return String(e12.s * e12.s / 0);
}
function ar(e12, n) {
  var i, t, r;
  for ((i = n.indexOf(".")) > -1 && (n = n.replace(".", "")), (t = n.search(/e/i)) > 0 ? (i < 0 && (i = t), i += +n.slice(t + 1), n = n.substring(0, t)) : i < 0 && (i = n.length), t = 0; n.charCodeAt(t) === 48; t++) ;
  for (r = n.length; n.charCodeAt(r - 1) === 48; --r) ;
  if (n = n.slice(t, r), n) {
    if (r -= t, e12.e = i = i - t - 1, e12.d = [], t = (i + 1) % B, i < 0 && (t += B), t < r) {
      for (t && e12.d.push(+n.slice(0, t)), r -= B; t < r; ) e12.d.push(+n.slice(t, t += B));
      n = n.slice(t), t = B - n.length;
    } else t -= r;
    for (; t--; ) n += "0";
    e12.d.push(+n), w && (e12.e > e12.constructor.maxE ? (e12.d = null, e12.e = NaN) : e12.e < e12.constructor.minE && (e12.e = 0, e12.d = [0]));
  } else e12.e = 0, e12.d = [0];
  return e12;
}
function xc(e12, n) {
  var i, t, r, s, o, a, u, l, f;
  if (n.indexOf("_") > -1) {
    if (n = n.replace(/(\d)_(?=\d)/g, "$1"), ba.test(n)) return ar(e12, n);
  } else if (n === "Infinity" || n === "NaN") return +n || (e12.s = NaN), e12.e = NaN, e12.d = null, e12;
  if (pc.test(n)) i = 16, n = n.toLowerCase();
  else if (cc.test(n)) i = 2;
  else if (dc.test(n)) i = 8;
  else throw Error(Fn + n);
  for (s = n.search(/p/i), s > 0 ? (u = +n.slice(s + 1), n = n.substring(2, s)) : n = n.slice(2), s = n.indexOf("."), o = s >= 0, t = e12.constructor, o && (n = n.replace(".", ""), a = n.length, s = a - s, r = Na(t, new t(i), s, s * 2)), l = or(n, i, nn), f = l.length - 1, s = f; l[s] === 0; --s) l.pop();
  return s < 0 ? new t(e12.s * 0) : (e12.e = pr(l, f), e12.d = l, w = false, o && (e12 = j(e12, r, a * 4)), u && (e12 = e12.times(Math.abs(u) < 54 ? he(2, u) : M.pow(2, u))), w = true, e12);
}
function yc(e12, n) {
  var i, t = n.d.length;
  if (t < 3) return n.isZero() ? n : _i(e12, 2, n, n);
  i = 1.4 * Math.sqrt(t), i = i > 16 ? 16 : i | 0, n = n.times(1 / dr(5, i)), n = _i(e12, 2, n, n);
  for (var r, s = new e12(5), o = new e12(16), a = new e12(20); i--; ) r = n.times(n), n = n.times(s.plus(r.times(o.times(r).minus(a))));
  return n;
}
function _i(e12, n, i, t, r) {
  var s, o, a, u, l = 1, f = e12.precision, c = Math.ceil(f / B);
  for (w = false, u = i.times(i), a = new e12(t); ; ) {
    if (o = j(a.times(u), new e12(n++ * n++), f, 1), a = r ? t.plus(o) : t.minus(o), t = j(o.times(u), new e12(n++ * n++), f, 1), o = a.plus(t), o.d[c] !== void 0) {
      for (s = c; o.d[s] === a.d[s] && s--; ) ;
      if (s == -1) break;
    }
    s = a, a = t, t = o, o = s, l++;
  }
  return w = true, o.d.length = c + 1, o;
}
function dr(e12, n) {
  for (var i = e12; --n; ) i *= e12;
  return i;
}
function Sa(e12, n) {
  var i, t = n.s < 0, r = ln(e12, e12.precision, 1), s = r.times(0.5);
  if (n = n.abs(), n.lte(s)) return Tn = t ? 4 : 1, n;
  if (i = n.divToInt(r), i.isZero()) Tn = t ? 3 : 2;
  else {
    if (n = n.minus(i.times(r)), n.lte(s)) return Tn = pa(i) ? t ? 2 : 3 : t ? 4 : 1, n;
    Tn = pa(i) ? t ? 1 : 4 : t ? 3 : 2;
  }
  return n.minus(r).abs();
}
function bs(e12, n, i, t) {
  var r, s, o, a, u, l, f, c, p, m = e12.constructor, y = i !== void 0;
  if (y ? (Re(i, 1, qn), t === void 0 ? t = m.rounding : Re(t, 0, 8)) : (i = m.precision, t = m.rounding), !e12.isFinite()) f = Ta(e12);
  else {
    for (f = fn(e12), o = f.indexOf("."), y ? (r = 2, n == 16 ? i = i * 4 - 3 : n == 8 && (i = i * 3 - 2)) : r = n, o >= 0 && (f = f.replace(".", ""), p = new m(1), p.e = f.length - o, p.d = or(fn(p), 10, r), p.e = p.d.length), c = or(f, 10, r), s = u = c.length; c[--u] == 0; ) c.pop();
    if (!c[0]) f = y ? "0p+0" : "0";
    else {
      if (o < 0 ? s-- : (e12 = new m(e12), e12.d = c, e12.e = s, e12 = j(e12, p, i, t, 0, r), c = e12.d, s = e12.e, l = ha), o = c[i], a = r / 2, l = l || c[i + 1] !== void 0, l = t < 4 ? (o !== void 0 || l) && (t === 0 || t === (e12.s < 0 ? 3 : 2)) : o > a || o === a && (t === 4 || l || t === 6 && c[i - 1] & 1 || t === (e12.s < 0 ? 8 : 7)), c.length = i, l) for (; ++c[--i] > r - 1; ) c[i] = 0, i || (++s, c.unshift(1));
      for (u = c.length; !c[u - 1]; --u) ;
      for (o = 0, f = ""; o < u; o++) f += hs.charAt(c[o]);
      if (y) {
        if (u > 1) if (n == 16 || n == 8) {
          for (o = n == 16 ? 4 : 3, --u; u % o; u++) f += "0";
          for (c = or(f, r, n), u = c.length; !c[u - 1]; --u) ;
          for (o = 1, f = "1."; o < u; o++) f += hs.charAt(c[o]);
        } else f = f.charAt(0) + "." + f.slice(1);
        f = f + (s < 0 ? "p" : "p+") + s;
      } else if (s < 0) {
        for (; ++s; ) f = "0" + f;
        f = "0." + f;
      } else if (++s > u) for (s -= u; s--; ) f += "0";
      else s < u && (f = f.slice(0, s) + "." + f.slice(s));
    }
    f = (n == 16 ? "0x" : n == 2 ? "0b" : n == 8 ? "0o" : "") + f;
  }
  return e12.s < 0 ? "-" + f : f;
}
function da(e12, n) {
  if (e12.length > n) return e12.length = n, true;
}
function bc(e12) {
  return new this(e12).abs();
}
function Ec(e12) {
  return new this(e12).acos();
}
function Nc(e12) {
  return new this(e12).acosh();
}
function vc(e12, n) {
  return new this(e12).plus(n);
}
function Tc(e12) {
  return new this(e12).asin();
}
function Sc(e12) {
  return new this(e12).asinh();
}
function _c(e12) {
  return new this(e12).atan();
}
function Ic(e12) {
  return new this(e12).atanh();
}
function Bc(e12, n) {
  e12 = new this(e12), n = new this(n);
  var i, t = this.precision, r = this.rounding, s = t + 4;
  return !e12.s || !n.s ? i = new this(NaN) : !e12.d && !n.d ? (i = ln(this, s, 1).times(n.s > 0 ? 0.25 : 0.75), i.s = e12.s) : !n.d || e12.isZero() ? (i = n.s < 0 ? ln(this, t, r) : new this(0), i.s = e12.s) : !e12.d || n.isZero() ? (i = ln(this, s, 1).times(0.5), i.s = e12.s) : n.s < 0 ? (this.precision = s, this.rounding = 1, i = this.atan(j(e12, n, s, 1)), n = ln(this, s, 1), this.precision = t, this.rounding = r, i = e12.s < 0 ? i.minus(n) : i.plus(n)) : i = this.atan(j(e12, n, s, 1)), i;
}
function kc(e12) {
  return new this(e12).cbrt();
}
function wc(e12) {
  return S(e12 = new this(e12), e12.e + 1, 2);
}
function Dc(e12, n, i) {
  return new this(e12).clamp(n, i);
}
function Ac(e12) {
  if (!e12 || typeof e12 != "object") throw Error(cr + "Object expected");
  var n, i, t, r = e12.defaults === true, s = ["precision", 1, qn, "rounding", 0, 8, "toExpNeg", -Si, 0, "toExpPos", 0, Si, "maxE", 0, Si, "minE", -Si, 0, "modulo", 0, 9];
  for (n = 0; n < s.length; n += 3) if (i = s[n], r && (this[i] = gs[i]), (t = e12[i]) !== void 0) if (_e(t) === t && t >= s[n + 1] && t <= s[n + 2]) this[i] = t;
  else throw Error(Fn + i + ": " + t);
  if (i = "crypto", r && (this[i] = gs[i]), (t = e12[i]) !== void 0) if (t === true || t === false || t === 0 || t === 1) if (t) if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) this[i] = true;
  else throw Error(xa);
  else this[i] = false;
  else throw Error(Fn + i + ": " + t);
  return this;
}
function Rc(e12) {
  return new this(e12).cos();
}
function Mc(e12) {
  return new this(e12).cosh();
}
function _a(e12) {
  var n, i, t;
  function r(s) {
    var o, a, u, l = this;
    if (!(l instanceof r)) return new r(s);
    if (l.constructor = r, ma(s)) {
      l.s = s.s, w ? !s.d || s.e > r.maxE ? (l.e = NaN, l.d = null) : s.e < r.minE ? (l.e = 0, l.d = [0]) : (l.e = s.e, l.d = s.d.slice()) : (l.e = s.e, l.d = s.d ? s.d.slice() : s.d);
      return;
    }
    if (u = typeof s, u === "number") {
      if (s === 0) {
        l.s = 1 / s < 0 ? -1 : 1, l.e = 0, l.d = [0];
        return;
      }
      if (s < 0 ? (s = -s, l.s = -1) : l.s = 1, s === ~~s && s < 1e7) {
        for (o = 0, a = s; a >= 10; a /= 10) o++;
        w ? o > r.maxE ? (l.e = NaN, l.d = null) : o < r.minE ? (l.e = 0, l.d = [0]) : (l.e = o, l.d = [s]) : (l.e = o, l.d = [s]);
        return;
      }
      if (s * 0 !== 0) {
        s || (l.s = NaN), l.e = NaN, l.d = null;
        return;
      }
      return ar(l, s.toString());
    }
    if (u === "string") return (a = s.charCodeAt(0)) === 45 ? (s = s.slice(1), l.s = -1) : (a === 43 && (s = s.slice(1)), l.s = 1), ba.test(s) ? ar(l, s) : xc(l, s);
    if (u === "bigint") return s < 0 ? (s = -s, l.s = -1) : l.s = 1, ar(l, s.toString());
    throw Error(Fn + s);
  }
  if (r.prototype = g, r.ROUND_UP = 0, r.ROUND_DOWN = 1, r.ROUND_CEIL = 2, r.ROUND_FLOOR = 3, r.ROUND_HALF_UP = 4, r.ROUND_HALF_DOWN = 5, r.ROUND_HALF_EVEN = 6, r.ROUND_HALF_CEIL = 7, r.ROUND_HALF_FLOOR = 8, r.EUCLID = 9, r.config = r.set = Ac, r.clone = _a, r.isDecimal = ma, r.abs = bc, r.acos = Ec, r.acosh = Nc, r.add = vc, r.asin = Tc, r.asinh = Sc, r.atan = _c, r.atanh = Ic, r.atan2 = Bc, r.cbrt = kc, r.ceil = wc, r.clamp = Dc, r.cos = Rc, r.cosh = Mc, r.div = Cc, r.exp = Pc, r.floor = Oc, r.hypot = Lc, r.ln = Fc, r.log = qc, r.log10 = Vc, r.log2 = $c, r.max = zc, r.min = Gc, r.mod = Uc, r.mul = jc, r.pow = Zc, r.random = Hc, r.round = Wc, r.sign = Jc, r.sin = Yc, r.sinh = Qc, r.sqrt = Xc, r.sub = Kc, r.sum = ep, r.tan = np, r.tanh = ip, r.trunc = tp, e12 === void 0 && (e12 = {}), e12 && e12.defaults !== true) for (t = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], n = 0; n < t.length; ) e12.hasOwnProperty(i = t[n++]) || (e12[i] = this[i]);
  return r.config(e12), r;
}
function Cc(e12, n) {
  return new this(e12).div(n);
}
function Pc(e12) {
  return new this(e12).exp();
}
function Oc(e12) {
  return S(e12 = new this(e12), e12.e + 1, 3);
}
function Lc() {
  var e12, n, i = new this(0);
  for (w = false, e12 = 0; e12 < arguments.length; ) if (n = new this(arguments[e12++]), n.d) i.d && (i = i.plus(n.times(n)));
  else {
    if (n.s) return w = true, new this(1 / 0);
    i = n;
  }
  return w = true, i.sqrt();
}
function ma(e12) {
  return e12 instanceof M || e12 && e12.toStringTag === ya || false;
}
function Fc(e12) {
  return new this(e12).ln();
}
function qc(e12, n) {
  return new this(e12).log(n);
}
function $c(e12) {
  return new this(e12).log(2);
}
function Vc(e12) {
  return new this(e12).log(10);
}
function zc() {
  return va(this, arguments, -1);
}
function Gc() {
  return va(this, arguments, 1);
}
function Uc(e12, n) {
  return new this(e12).mod(n);
}
function jc(e12, n) {
  return new this(e12).mul(n);
}
function Zc(e12, n) {
  return new this(e12).pow(n);
}
function Hc(e12) {
  var n, i, t, r, s = 0, o = new this(1), a = [];
  if (e12 === void 0 ? e12 = this.precision : Re(e12, 1, qn), t = Math.ceil(e12 / B), this.crypto) if (crypto.getRandomValues) for (n = crypto.getRandomValues(new Uint32Array(t)); s < t; ) r = n[s], r >= 429e7 ? n[s] = crypto.getRandomValues(new Uint32Array(1))[0] : a[s++] = r % 1e7;
  else if (crypto.randomBytes) {
    for (n = crypto.randomBytes(t *= 4); s < t; ) r = n[s] + (n[s + 1] << 8) + (n[s + 2] << 16) + ((n[s + 3] & 127) << 24), r >= 214e7 ? crypto.randomBytes(4).copy(n, s) : (a.push(r % 1e7), s += 4);
    s = t / 4;
  } else throw Error(xa);
  else for (; s < t; ) a[s++] = Math.random() * 1e7 | 0;
  for (t = a[--s], e12 %= B, t && e12 && (r = he(10, B - e12), a[s] = (t / r | 0) * r); a[s] === 0; s--) a.pop();
  if (s < 0) i = 0, a = [0];
  else {
    for (i = -1; a[0] === 0; i -= B) a.shift();
    for (t = 1, r = a[0]; r >= 10; r /= 10) t++;
    t < B && (i -= B - t);
  }
  return o.e = i, o.d = a, o;
}
function Wc(e12) {
  return S(e12 = new this(e12), e12.e + 1, this.rounding);
}
function Jc(e12) {
  return e12 = new this(e12), e12.d ? e12.d[0] ? e12.s : 0 * e12.s : e12.s || NaN;
}
function Yc(e12) {
  return new this(e12).sin();
}
function Qc(e12) {
  return new this(e12).sinh();
}
function Xc(e12) {
  return new this(e12).sqrt();
}
function Kc(e12, n) {
  return new this(e12).sub(n);
}
function ep() {
  var e12 = 0, n = arguments, i = new this(n[e12]);
  for (w = false; i.s && ++e12 < n.length; ) i = i.plus(n[e12]);
  return w = true, S(i, this.precision, this.rounding);
}
function np(e12) {
  return new this(e12).tan();
}
function ip(e12) {
  return new this(e12).tanh();
}
function tp(e12) {
  return S(e12 = new this(e12), e12.e + 1, 1);
}
g[Symbol.for("nodejs.util.inspect.custom")] = g.toString;
g[Symbol.toStringTag] = "Decimal";
var M = g.constructor = _a(gs);
ur = new M(ur);
lr = new M(lr);
var mr = ["number", "finite_number", "complex", "finite_complex", "imaginary", "real", "finite_real", "rational", "finite_rational", "integer", "finite_integer", "non_finite_number"];
var hr = ["collection", "list", "set", "tuple", "map"];
var gr = ["scalar", ...mr, "boolean", "string"];
var Es = ["value", ...hr, ...gr];
var Ns = ["expression", "symbol", "function", ...Es];
var $n = ["any", "unknown", "nothing", "never", "error", ...Ns];
var Ia = 3;
var Ba = 1;
var ka = 2;
var rp = 4;
var sp = 5;
var op = 6;
var ap = 7;
var up = 8;
var lp = 9;
var fp = 10;
function ne(e12, n = 0) {
  if (typeof e12 == "string") return e12;
  let i = "";
  switch (e12.kind) {
    case "value":
      typeof e12.value == "string" ? i = `"${e12.value}"` : typeof e12.value == "boolean" ? i = e12.value ? "true" : "false" : i = e12.value.toString();
      break;
    case "reference":
      i = e12.ref;
      break;
    case "negation":
      i = `!${ne(e12.type, Ia)}`;
      break;
    case "union":
      i = e12.types.map((u) => ne(u, Ba)).join(" | ");
      break;
    case "intersection":
      i = e12.types.map((u) => ne(u, ka)).join(" & ");
      break;
    case "list":
      if (e12.dimensions && v(e12.elements, "number")) {
        if (e12.dimensions === void 0) e12.elements === "number" && (i = "tensor");
        else if (e12.dimensions.length === 1) e12.elements === "number" ? e12.dimensions[0] < 0 ? i = "vector" : i = `vector<${e12.dimensions[0]}>` : e12.dimensions[0] < 0 ? i = `vector<${ne(e12.elements)}>` : i = `vector<${ne(e12.elements)}^${e12.dimensions[0]}>`;
        else if (e12.dimensions.length === 2) {
          let u = e12.dimensions;
          e12.elements === "number" ? u[0] < 0 && u[1] < 0 ? i = "matrix" : i = `matrix<${u[0]}x${u[1]}>` : u[0] < 0 && u[1] < 0 ? i = `matrix<${ne(e12.elements)}>` : i = `matrix<${ne(e12.elements)}^(${u[0]}x${u[1]})>`;
        }
      }
      if (!i) {
        let u = e12.dimensions ? e12.dimensions.length === 1 ? `^${e12.dimensions[0].toString()}` : `^(${e12.dimensions.join("x")})` : "";
        i = `list<${ne(e12.elements)}${u}>`;
      }
      break;
    case "map":
      i = `map<${Object.entries(e12.elements).map(([u, l]) => `${u}: ${ne(l)}`).join(", ")}>`;
      break;
    case "set":
      i = `set<${ne(e12.elements)}>`;
      break;
    case "collection":
      i = `collection<${ne(e12.elements)}>`;
      break;
    case "tuple":
      if (e12.elements.length === 0) i = "tuple";
      else if (e12.elements.length === 1) {
        let [u] = e12.elements;
        i = `tuple<${gt(u)}>`;
      } else i = "tuple<" + e12.elements.map((u) => gt(u)).join(", ") + ">";
      break;
    case "signature":
      let r = e12.args ? e12.args.map((u) => gt(u)).join(", ") : "", s = e12.optArgs ? e12.optArgs.map((u) => gt(u) + "?").join(", ") : "", o = e12.restArg ? `...${gt(e12.restArg)}` : "";
      i = `(${[r, s, o].filter((u) => u).join(", ")}) -> ${ne(e12.result)}`;
      break;
    default:
      i = "error";
  }
  return n > 0 && n > cp(e12.kind) ? `(${i})` : i;
}
function gt(e12) {
  return e12.name ? `${e12.name}: ${ne(e12.type)}` : ne(e12.type);
}
function cp(e12) {
  switch (e12) {
    case "negation":
      return Ia;
    case "union":
      return Ba;
    case "intersection":
      return ka;
    case "list":
      return rp;
    case "map":
      return sp;
    case "set":
      return op;
    case "collection":
      return ap;
    case "tuple":
      return up;
    case "signature":
      return lp;
    case "value":
      return fp;
    default:
      return 0;
  }
}
function pp(e12, n) {
  return e12 === n ? e12 : e12 === "nothing" || n === "nothing" ? "nothing" : e12 === "any" ? n : n === "any" ? e12 : e12 === "never" ? n : n === "never" ? e12 : e12 === "unknown" ? n : n === "unknown" || v(e12, n) ? e12 : v(n, e12) ? n : Da(e12, n);
}
function dp(e12, n) {
  return e12 === n ? e12 : e12 === "any" || n === "any" ? "any" : e12 === "never" ? n : n === "never" ? e12 : e12 === "unknown" ? n : n === "unknown" ? e12 : e12 === "nothing" ? n : n === "nothing" ? e12 : v(e12, n) ? n : v(n, e12) ? e12 : Da(e12, n);
}
function wa(...e12) {
  return e12.length === 0 ? "nothing" : e12.length === 1 ? e12[0] : e12.reduce(pp);
}
function ke(...e12) {
  return e12.length === 0 ? "nothing" : e12.length === 1 ? e12[0] : e12.reduce(dp);
}
function Xn(e12) {
  return e12 = typeof e12 == "string" ? k(e12) : e12, typeof e12 != "string" && e12.kind === "signature";
}
function Kn(e12) {
  if (e12) {
    if (e12 === "function") return "any";
    if (typeof e12 != "string" && e12.kind === "signature") return e12.result;
  }
}
function ei(e12) {
  if (e12 === "collection") return "any";
  if (typeof e12 != "string") {
    if (e12.kind === "collection" || e12.kind === "list") return e12.elements;
    if (e12.kind === "map") return k(`tuple<string, ${ke(...Object.values(e12.elements))}>`);
    if (e12.kind === "set") return e12.elements;
    if (e12.kind === "tuple") return ke(...e12.elements.map((n) => n.type));
  }
}
function Sn(e12) {
  return typeof e12 == "string" ? $n.includes(e12) : typeof e12 != "object" || !("kind" in e12) ? false : e12.kind === "signature" || e12.kind === "union" || e12.kind === "intersection" || e12.kind === "negation" || e12.kind === "tuple" || e12.kind === "list" || e12.kind === "map" || e12.kind === "set" || e12.kind === "function" || e12.kind === "collection" || e12.kind === "reference";
}
function Da(e12, n) {
  return e12 === n ? e12 : e12 === "any" || n === "any" ? "any" : e12 === "never" ? n : n === "never" ? e12 : e12 === "unknown" ? n : n === "unknown" ? e12 : e12 === "nothing" ? n : n === "nothing" ? e12 : le(e12, n, "non_finite_number") ? "non_finite_number" : le(e12, n, "finite_integer") ? "finite_integer" : le(e12, n, "integer") ? "integer" : le(e12, n, "finite_rational") ? "finite_rational" : le(e12, n, "rational") ? "rational" : le(e12, n, "finite_real") ? "finite_real" : le(e12, n, "real") ? "real" : le(e12, n, "imaginary") ? "imaginary" : le(e12, n, "finite_complex") ? "finite_complex" : le(e12, n, "complex") ? "complex" : le(e12, n, "finite_number") ? "finite_number" : le(e12, n, "number") ? "number" : le(e12, n, "list") ? "list" : le(e12, n, "map") ? "map" : le(e12, n, "set") ? "set" : le(e12, n, "tuple") ? "tuple" : le(e12, n, "collection") ? "collection" : le(e12, n, "scalar") ? "scalar" : le(e12, n, "value") ? "value" : le(e12, n, "function") ? "function" : le(e12, n, "expression") ? "expression" : "any";
}
function le(e12, n, i) {
  return !!(v(e12, i) && v(n, i));
}
function mp(e12, n) {
  if (e12 === n) return 0;
  if (e12.length === 0) return n.length;
  if (n.length === 0) return e12.length;
  let i = Array.from({ length: e12.length + 1 }, (r, s) => s), t = new Array(e12.length + 1);
  for (let r = 1; r <= n.length; r++) {
    t[0] = r;
    for (let s = 1; s <= e12.length; s++) {
      let o = e12[s - 1] === n[r - 1] ? 0 : 1;
      t[s] = Math.min(i[s] + 1, t[s - 1] + 1, i[s - 1] + o);
    }
    [i, t] = [t, i];
  }
  return i[e12.length];
}
function Aa(e12, n) {
  let t = null, r = 1 / 0, s = e12.length;
  for (let o of n) {
    if (Math.abs(s - o.length) > 3) continue;
    let a = mp(e12, o);
    if (a === 0) return o;
    a <= 3 && a < r && (r = a, t = o);
  }
  return t;
}
var vs = class {
  constructor(n, i) {
    var _a2, _b;
    this.buffer = n, this.pos = 0, this._valueParser = (_a2 = i == null ? void 0 : i.value) != null ? _a2 : () => null, this._typeParser = (_b = i == null ? void 0 : i.type) != null ? _b : () => null;
  }
  error(...n) {
    throw new Error(`
Invalid type
|   ${this.buffer}
|   ${" ".repeat(this.pos)}^
|   
|   ${n.join(`
|   `)}
`);
  }
  peek() {
    return this.buffer[this.pos];
  }
  consume() {
    return this.buffer[this.pos++];
  }
  match(n) {
    if (n.length === 1 && this.buffer[this.pos] === n) return this.pos++, true;
    let i = this.pos;
    return this.buffer.slice(i, i + n.length) === n ? (this.pos += n.length, true) : false;
  }
  skipWhitespace() {
    for (; this.pos < this.buffer.length && /\s/.test(this.buffer[this.pos]); ) this.pos++;
  }
  isEOF() {
    return this.pos >= this.buffer.length;
  }
  parseValue() {
    this.skipWhitespace();
    let n = this._valueParser(this);
    return n === null ? null : { kind: "value", value: n };
  }
  parseTypeReference() {
    this.skipWhitespace();
    let n = this._typeParser(this);
    return n === null ? null : { kind: "reference", ref: n };
  }
  parsePrimitiveType() {
    this.skipWhitespace(), this.isEOF() && this.error("Unexpected end of input");
    for (let n of $n) if (this.match(n)) return n;
    return null;
  }
  parseArguments() {
    var _a2;
    let n = [], i = [];
    for (; ; ) {
      let o = this.parseNamedElement();
      if (o === null || (this.match("?") ? i.push(o) : (i.length > 0 && this.error("Optional arguments must come after required arguments"), n.push(o)), this.skipWhitespace(), !this.match(","))) break;
    }
    let t = this.pos, r = (_a2 = this.parseRestArgument()) != null ? _a2 : void 0;
    r && i.length > 0 && (this.pos = t, this.error("Optional arguments cannot be followed by a rest argument"));
    let s = Ra([...n, ...i, ...r ? [r] : []]);
    return s && this.error(`Duplicate argument name "${s}"`), [n, i, r];
  }
  parseRestArgument() {
    var _a2, _b;
    let n = this.pos, i = this.parseName();
    if (this.skipWhitespace(), !this.match("...")) return this.pos = n, null;
    let t = (_a2 = this.parsePrimitiveType()) != null ? _a2 : this.parseGroup();
    if (!t && !i && (this.pos = n, this.match("...") && this.parseName())) {
      let r = (_b = this.parsePrimitiveType()) != null ? _b : this.parseGroup();
      this.pos = n, this.error("The rest argument indicator is placed before the type, not the name", `Use "${i}: ...${r ? ne(r) : "number"}"`);
    }
    return this.skipWhitespace(), this.match(":") && this.error('Unexpected ":" after rest argument. Use "x: ...number"'), t != null ? t : t = "any", i ? { name: i, type: t } : { type: t };
  }
  parseFunctionSignature() {
    var _a2;
    let n = [], i = [], t;
    this.skipWhitespace();
    let r = this.pos;
    if (!this.match("()")) {
      if (this.match("(")) {
        if ([n, i, t] = this.parseArguments(), this.skipWhitespace(), !this.match(")")) return t && (this.parseNamedElement() && (this.pos = r, this.error("The rest argument must be the last argument")), this.error("The rest argument must have a valid type")), i.length > 0 && (this.parseNamedElement() && this.error("Optional arguments cannot be followed by required arguments"), this.skipWhitespace(), r = this.pos, this.match("->") && (this.pos = r, this.error('Expected ")" to close the argument list')), this.error("Expected an argument")), this.pos = r, null;
      } else if (t = (_a2 = this.parseRestArgument()) != null ? _a2 : void 0, (t == null ? void 0 : t.name) && (this.pos = r, this.error("Named arguments must be enclosed in parentheses")), !t) return this.pos = r, null;
    }
    if (this.skipWhitespace(), !this.match("->")) return this.pos = r, null;
    let s = this.parseType();
    return s === null && this.error("Expected a return type.", "Use `any` for any type, `nothing` for no return value, or `never` for a function that never returns"), n.length === 0 && (n = void 0), i.length === 0 && (i = void 0), { kind: "signature", args: n, optArgs: i, restArg: t, result: s };
  }
  parsePositiveIntegerLiteral() {
    let n = 0;
    for (this.skipWhitespace(); /[0-9]/.test(this.peek()); ) n = n * 10 + parseInt(this.consume());
    return n === 0 ? null : n;
  }
  parseOptionalDimension() {
    let n = this.parsePositiveIntegerLiteral();
    return n === null && this.match("?") && (n = -1), n;
  }
  parseDimensions() {
    let n = this.pos, i = this.match("("), t = [], r = this.parseOptionalDimension();
    if (r === null) {
      this.pos = n;
      return;
    }
    do {
      if (t.push(r), this.skipWhitespace(), !this.match("x")) break;
      this.skipWhitespace(), r = this.parseOptionalDimension(), r === null && this.error("Expected a positive integer literal or `?`.", "For example : `matrix<integer^2x3>` or `matrix<integer^?x?>`");
    } while (true);
    return this.skipWhitespace(), i && !this.match(")") && this.error('Expected ")".', "For example `matrix<integer^(2x3)>`"), t;
  }
  parseList() {
    var _a2;
    if (this.skipWhitespace(), this.match("list<")) {
      let t = this.parseDimensions();
      if (t !== void 0) return this.skipWhitespace(), this.match(">") || this.error('Expected ">".', "For example `list<2x3>`"), { kind: "list", elements: "any", dimensions: t };
      let r = this.parseType();
      return r && this.match("^") && (t = this.parseDimensions(), t === void 0 && this.error("Expected dimensions after `^`.", "For example `list<number^2x3>`")), this.skipWhitespace(), this.match(">") || this.error('Expected ">".', "For example `list<number>`"), { kind: "list", elements: r != null ? r : "any", dimensions: t };
    }
    if (this.match("list(") && this.error("Use `list<type>` instead of `list(type)`.", "For example `list<number>`"), this.match("vector<")) {
      let t = this.parseType(), r;
      if (t && this.match("^")) {
        let s = this.parsePositiveIntegerLiteral();
        s === null && this.error("Expected a positive integer literal.", "For example `vector<3>`", "Use `vector` for a vector of unknown size"), r = [s];
      } else t || (t = "number", r = this.parseDimensions());
      return this.skipWhitespace(), this.match(">") || this.error('Expected ">"', "For example `vector<integer>`"), { kind: "list", elements: t, dimensions: r };
    }
    if (this.match("vector(") && this.error("Use `vector<...>` instead of `vector(...)`.", "For example `vector<3>` or `vector<integer^3>`"), this.match("vector")) return { kind: "list", elements: "number" };
    if (this.match("matrix<")) {
      let t = this.parseType(), r;
      return t && this.match("^") ? (r = this.parseDimensions(), r === void 0 && this.error("Expected dimensions", "For example `matrix<number^2x3>`", "Use `matrix` for a matrix of unknown size")) : t || (t = "number", r = this.parseDimensions()), this.match(">") || this.error('Expected ">".', "For example `matrix<integer>`"), { kind: "list", elements: t, dimensions: r };
    }
    if (this.match("matrix(") && this.error("Use `matrix<...>` instead of `matrix(...)`.", "For example `matrix<3x2>` or `matrix<integer^3x2>`"), this.match("matrix")) return { kind: "list", elements: "number", dimensions: [-1, -1] };
    if (this.match("tensor<")) {
      let t = (_a2 = this.parseType()) != null ? _a2 : "number";
      return this.match(">") || this.error('Expected ">".', "For example `tensor<number>`"), { kind: "list", elements: t, dimensions: void 0 };
    }
    if (this.match("tensor")) return { kind: "list", elements: "number", dimensions: void 0 };
    if (!this.match("list<")) return null;
    let n = this.parseType();
    n === null && this.error('Expected a type. Use "[any]" for a collection of any type');
    let i = this.match("^") ? this.parseDimensions() : void 0;
    return this.skipWhitespace(), this.match(">") || this.error('Expected ">".', "For example `list<number^2x3>`"), { kind: "list", elements: n, dimensions: i };
  }
  parseName() {
    let n = this.pos;
    if (this.skipWhitespace(), this.isEOF() || !/[a-zA-Z_]/.test(this.peek())) return null;
    let i = "";
    for (; !this.isEOF() && /[a-zA-Z0-9_]/.test(this.peek()); ) i += this.consume();
    if (this.skipWhitespace(), !this.match(":")) {
      if (this.match("?:")) {
        let t = this.parseType();
        t && this.error("Optional qualifier must come after the type", `Use "${i}: ${ne(t)}?"`), this.error("Optional qualifier must come after the type", `Use "${i}: number?"`);
      }
      return this.pos = n, null;
    }
    return i;
  }
  parseKey() {
    if (this.skipWhitespace(), this.isEOF()) return null;
    let n = "";
    if (this.match("`")) {
      for (; this.peek() !== "`"; ) this.isEOF() && this.error("Expected closing backtick"), this.match("\\`") ? n += "`" : n += this.consume();
      return n;
    }
    for (; !this.isEOF() && !/[:\s]/.test(this.peek()); ) n += this.consume();
    return n;
  }
  parseNamedElement() {
    let n = this.pos, i = this.parseName();
    if (i !== null) {
      let r = this.parseType();
      if (r === null) {
        if (this.skipWhitespace(), this.match("...")) return this.pos = n, null;
        this.pos = n, this.error(`Expected a valid type after "${i}:"`);
      }
      return this.skipWhitespace(), this.match("->") && (this.pos = n, this.error("Single named argument must be enclosed in parentheses")), { name: i, type: r };
    }
    let t = this.parseType();
    return t === null ? (this.pos = n, null) : { type: t };
  }
  parseTupleElements() {
    let n = [], i = this.pos, t = this.parseNamedElement();
    if (t === null) return [];
    for (; n.push(t), this.skipWhitespace(), !!this.match(","); ) i = this.pos, t = this.parseNamedElement(), t === null && (this.pos = i, this.error("Expected a type or unexpected comma"));
    let r = Ra(n);
    return r && this.error(`Duplicate tuple named element "${r}"`), n;
  }
  parseTuple() {
    if (this.skipWhitespace(), !this.match("tuple<")) return this.match("tuple(") && this.error("Use `tuple<type>` instead of `tuple(type)`.", "For example `tuple<number, boolean>` or `tuple<x: integer, y: integer>`"), null;
    let n = this.parseTupleElements();
    return this.skipWhitespace(), this.match(">") || this.error('Expected ">".', "For example `tuple<number, boolean>` or `tuple<x: integer, y: integer>`"), { kind: "tuple", elements: n };
  }
  parseGroup() {
    let n = this.pos;
    if (this.skipWhitespace(), !this.match("(")) return null;
    let i = this.parseType();
    return i === null ? (this.pos = n, null) : (this.skipWhitespace(), this.match(")") && (this.skipWhitespace(), !this.match("->")) ? i : (this.pos = n, null));
  }
  parseSet() {
    if (this.skipWhitespace(), !this.match("set<")) return this.match("set(") && this.error("Use `set<type>` instead of `set(type)`.", "For example `set<number>`"), this.match("set") ? "set" : null;
    let n = this.parseType();
    return n === null && this.error("Expected a type.", "Use `set<number>` for a set of numbers"), this.skipWhitespace(), this.match(">") || this.error("Expected `>`.", "For example `set<number>`"), { kind: "set", elements: n };
  }
  parseMapElements() {
    var _a2;
    let n = [];
    for (; ; ) {
      let t = this.parseKey();
      t === null && this.error("Expected a name for the key.", "For example `map<key: string>`.", "Use backticks for special characters.", "For example `map<`key with space`: string>`"), this.skipWhitespace(), this.match(":") || this.error("Expected a type separated by a `:` after the key.", `For example \`map<${t}: string>\``, "Use backticks for special characters.", "For example `map<`key with space`: string>`");
      let r = this.parseType();
      if (r === null && this.error("Expected a type for the value. Use `any` for any type.", `For example \`map<${t}: any>.\``), n.push([t, r]), this.skipWhitespace(), !this.match(",")) break;
    }
    if (new Set(n.map(([t]) => t)).size !== n.length) {
      let t = (_a2 = n.find(([r], s) => n.slice(s + 1).some(([o]) => o === r))) == null ? void 0 : _a2[0];
      this.error(`Duplicate map key "${t}"`, "Keys in a map must be unique.");
    }
    return n;
  }
  parseMap() {
    if (this.skipWhitespace(), this.match("map(") && this.error('Use `map<key: type>` instead of `map(key: type)".', "For example `map<key: string>`"), this.match("map<")) {
      let n = this.parseMapElements();
      return this.skipWhitespace(), this.match(">") || this.error("Expected a closing `>`.", "For example `map<key: string>`"), { kind: "map", elements: Object.fromEntries(n) };
    }
    return this.match("map") ? "map" : null;
  }
  parseCollection() {
    if (this.skipWhitespace(), !this.match("collection<")) return this.match("collection(") && this.error("Use `collection<type>` instead of `collection(type)`.", "For example `collection<number>`"), this.match("collection") ? "collection" : null;
    let n = this.parseType();
    return n === null && this.error("Expected a type.", "Use `collection<number>` for a collection of numbers"), this.skipWhitespace(), this.match(">") || this.error('Expected ">".', "For example `collection<number>`"), { kind: "collection", elements: n };
  }
  parsePrimary() {
    var _a2, _b, _c2, _d2, _e2, _f2, _g, _h, _i2;
    let n = (_i2 = (_h = (_g = (_f2 = (_e2 = (_d2 = (_c2 = (_b = (_a2 = this.parseGroup()) != null ? _a2 : this.parseNegationType()) != null ? _b : this.parseList()) != null ? _c2 : this.parseSet()) != null ? _d2 : this.parseMap()) != null ? _e2 : this.parseCollection()) != null ? _f2 : this.parseTuple()) != null ? _g : this.parsePrimitiveType()) != null ? _h : this.parseValue()) != null ? _i2 : this.parseTypeReference();
    if (n === null) {
      let i = "";
      for (; !this.isEOF() && /[a-zA-Z_]/.test(this.peek()); ) i += this.consume();
      if (!i) return null;
      let t = Aa(i, [...$n, "vector", "matrix"]);
      return t && this.error(`Unknown keyword "${i}"`, `Did you mean "${t}"?`), null;
    }
    if (this.skipWhitespace(), this.match("->")) {
      let i = this.parseType();
      i === null && this.error("Expected return type", "Use `any` for any type, `nothing` for no return value or `never` for a function that never returns"), n = { kind: "signature", args: [{ type: n }], result: i };
    }
    return n;
  }
  parseNegationType() {
    if (!this.match("!")) return null;
    let n = this.parsePrimary();
    return n === null && this.error("Expected type"), { kind: "negation", type: n };
  }
  parseIntersectionType() {
    var _a2;
    let n = (_a2 = this.parseFunctionSignature()) != null ? _a2 : this.parsePrimary();
    if (n === null) return null;
    let i = [n];
    for (this.skipWhitespace(); this.match("&"); ) this.skipWhitespace(), n = this.parsePrimary(), n === null && this.error("Expected type"), i.push(n);
    return i.length === 1 ? i[0] : { kind: "intersection", types: i };
  }
  parseUnionType() {
    let n = this.parseIntersectionType();
    if (n === null) return null;
    let i = [n];
    for (this.skipWhitespace(); this.match("|"); ) n = this.parseIntersectionType(), n === null && this.error("Expected type"), i.push(n);
    return i.length === 1 ? i[0] : { kind: "union", types: i };
  }
  parseType() {
    if (this.skipWhitespace(), this.isEOF()) return null;
    if (this.peek() === "(") {
      let n = this.parseFunctionSignature();
      if (n) return n;
    }
    return this.parseUnionType();
  }
  parse() {
    let n = this.pos;
    this.parseName() !== null && (this.pos = n, this.error("Named elements must be enclosed in parentheses"));
    let i = this.parseType();
    return i === null && this.error("Syntax error. The type was not recognized."), this.skipWhitespace(), this.isEOF() || this.error("Unexpected character. Could be some mismatched parentheses."), i;
  }
};
function hp(e12) {
  let n = e12.pos;
  if (e12.skipWhitespace(), /["]/.test(e12.peek())) {
    let i = e12.consume(), t = "";
    for (; e12.peek() !== i; ) e12.isEOF() && e12.error("Expected closing quote"), e12.match("\\" + i) ? t += i : t += e12.consume();
    return e12.consume(), t;
  }
  if (e12.match("0x")) {
    let i = 0;
    for (; /[0-9a-fA-F]/.test(e12.peek()); ) i = i * 16 + parseInt(e12.consume(), 16);
    return i;
  }
  if (e12.match("0b")) {
    let i = 0;
    for (; /[01]/.test(e12.peek()); ) i = i * 2 + parseInt(e12.consume());
    return i;
  }
  if (/[-0-9\.]/.test(e12.peek())) {
    let i = 0, t = 1;
    if (e12.match("-") && (t = -1), !/[0-9]/.test(e12.peek())) return e12.pos = n, null;
    for (; /[0-9]/.test(e12.peek()); ) i = i * 10 + parseInt(e12.consume());
    if (e12.match(".")) {
      let r = 0, s = 1;
      for (; /[0-9]/.test(e12.peek()); ) r = r * 10 + parseInt(e12.consume()), s *= 10;
      i += r / s;
    }
    if (e12.match("e") || e12.match("E")) {
      let r = 0, s = 1;
      for (e12.match("+") && (s = 1), e12.match("-") && (s = -1); /[0-9]/.test(e12.peek()); ) r = r * 10 + parseInt(e12.consume());
      i *= Math.pow(10, s * r);
    }
    return t * i;
  }
  return e12.match("true") ? true : e12.match("false") ? false : e12.match("nan") ? NaN : e12.match("infinity") ? 1 / 0 : e12.match("-infinity") ? -1 / 0 : (e12.pos = n, null);
}
function k(e12) {
  return e12 === void 0 ? void 0 : Sn(e12) ? e12 : typeof e12 != "string" ? void 0 : $n.includes(e12) ? e12 : new vs(e12, { value: hp }).parse();
}
function Ra(e12) {
  let n = /* @__PURE__ */ new Set();
  for (let { name: i } of e12) if (i) {
    if (n.has(i)) return i;
    n.add(i);
  }
  return "";
}
var gp = { number: mr, non_finite_number: [], finite_number: ["finite_complex", "finite_real", "finite_integer", "finite_rational"], complex: ["finite_complex", "imaginary", "finite_real", "finite_rational", "finite_integer", "non_finite_number"], finite_complex: ["imaginary", "finite_real", "finite_rational", "finite_integer"], imaginary: [], real: ["rational", "integer", "finite_real", "finite_rational", "finite_integer", "non_finite_number"], finite_real: ["finite_rational", "finite_integer"], rational: ["finite_rational", "finite_integer", "integer", "non_finite_number"], finite_rational: ["finite_integer"], integer: ["finite_integer", "non_finite_number"], finite_integer: [], any: $n, unknown: [], nothing: [], never: [], error: [], value: Es, scalar: gr, collection: hr, list: [], set: [], tuple: [], map: [], function: [], symbol: [], boolean: [], string: [], expression: Ns };
function xt(e12, n) {
  return n === "any" || e12 === "never" ? true : e12 === "unknown" || n === "unknown" ? false : e12 === n ? true : gp[n].includes(e12);
}
function v(e12, n) {
  if (typeof e12 == "string" && typeof n == "string" && e12 === n || (typeof e12 == "string" && (e12 = k(e12)), typeof n == "string" && (n = k(n)), n === "any")) return true;
  if (n === "never" || n === "error") return false;
  if (n === "nothing") return e12 === "nothing";
  if (e12 === "nothing") return false;
  if (n === "unknown") return true;
  if (e12 === "unknown") return false;
  if (typeof n == "string") return typeof e12 == "string" ? xt(e12, n) : e12.kind === "value" ? typeof e12.value == "boolean" ? n === "boolean" : typeof e12.value == "number" ? Number.isInteger(e12.value) ? xt("integer", n) : xt("number", n) : typeof e12.value == "boolean" ? xt("boolean", n) : typeof e12.value == "string" ? xt("string", n) : false : n === "numeric" ? Ma(e12) : n === "function" ? La(e12) : n === "expression" ? xp(e12) : n === "scalar" ? Ca(e12) : n === "value" ? Oa(e12) : n === "collection" ? Pa(e12) : n === "tuple" ? e12.kind === "tuple" : n === "list" ? e12.kind === "list" : n === "set" ? e12.kind === "set" : n === "map" ? e12.kind === "map" : e12.kind === "union" ? e12.types.every((i) => v(i, n)) : false;
  if (n.kind === "union") return typeof e12 != "string" && e12.kind === "union" ? e12.types.every((i) => n.types.some((t) => v(i, t))) : n.types.some((i) => v(e12, i));
  if (typeof e12 == "string") return false;
  if (e12.kind === "reference" && n.kind === "reference") return e12.ref === n.ref;
  if (e12.kind === "union") return e12.types.some((i) => v(i, n));
  if (e12.kind === "intersection" && n.kind === "intersection") return n.types.every((i) => e12.types.some((t) => v(t, i)));
  if (e12.kind === "intersection") return e12.types.every((i) => v(i, n));
  if (n.kind === "intersection") return n.types.every((i) => v(e12, i));
  if (e12.kind === "signature" && n.kind === "signature") {
    if (!v(e12.result, n.result)) return false;
    if (n.args) {
      if (!e12.args || e12.args.length !== n.args.length) return false;
      for (let i = 0; i < e12.args.length; i++) if (!v(n.args[i].type, e12.args[i].type)) return false;
    } else if (e12.args) return false;
    if (n.optArgs) {
      if (!e12.optArgs || e12.optArgs.length !== n.optArgs.length) return false;
      for (let i = 0; i < e12.optArgs.length; i++) if (!v(n.optArgs[i].type, e12.optArgs[i].type)) return false;
    } else if (e12.optArgs) return false;
    if (n.restArg) {
      if (!e12.restArg || !v(n.restArg.type, e12.restArg.type)) return false;
    } else if (e12.restArg) return false;
    return true;
  }
  if (e12.kind === "map" && n.kind === "map") {
    let i = Object.entries(e12.elements), t = Object.entries(n.elements);
    for (let r = 0; r < t.length; r++) {
      let [s, o] = t[r], a = i.findIndex((f) => f[0] === s);
      if (a === -1) return false;
      let u = o, l = i[a][1];
      if (!v(l, u)) return false;
    }
    return true;
  }
  if (n.kind === "collection") return e12.kind === "collection" || e12.kind === "list" || e12.kind === "set" ? !!v(e12.elements, n.elements) : e12.kind === "tuple" ? e12.elements.every((i) => v(i.type, n.elements)) : false;
  if (e12.kind === "tuple" && n.kind === "tuple") {
    if (e12.elements.length !== n.elements.length) return false;
    for (let i = 0; i < e12.elements.length; i++) {
      let t = e12.elements[i], r = n.elements[i];
      if (!v(t.type, r.type) || t.name !== r.name) return false;
    }
    return true;
  }
  if (n.kind === "list" && e12.kind === "list") {
    if (!v(e12.elements, n.elements)) return false;
    if (n.dimensions) {
      if (!e12.dimensions || e12.dimensions.length !== n.dimensions.length) return false;
      for (let i = 0; i < e12.dimensions.length; i++) if (n.dimensions[i] !== -1 && e12.dimensions[i] !== n.dimensions[i]) return false;
    }
    return true;
  }
  if (n.kind === "set" && e12.kind === "set") return !!v(e12.elements, n.elements);
  if (e12.kind === "negation" && n.kind === "negation") return v(e12.type, n.type);
  if (n.kind === "negation") return !v(e12, n.type);
  if (n.kind === "value" && e12.kind === "value") return n.value === e12.value;
  if (e12.kind === "value") {
    if (typeof e12.value == "boolean") return v("boolean", n);
    if (typeof e12.value == "number") return Number.isInteger(e12.value) ? v("integer", n) : v("real", n);
    if (typeof e12.value == "string") return v("string", n);
  }
  return false;
}
function Ma(e12) {
  return typeof e12 == "string" ? mr.includes(e12) : e12.kind === "value" ? typeof e12.value == "number" : false;
}
function Ca(e12) {
  return Ma(e12) ? true : typeof e12 == "string" ? gr.includes(e12) : e12.kind === "value" ? ["string", "boolean", "number"].includes(typeof e12.value) : false;
}
function Pa(e12) {
  return typeof e12 == "string" ? hr.includes(e12) : ["collection", "list", "set", "tuple", "map"].includes(e12.kind);
}
function Oa(e12) {
  return Ca(e12) || Pa(e12);
}
function La(e12) {
  return e12 === "function" || typeof e12 != "string" && e12.kind === "signature";
}
function xp(e12) {
  return !!(typeof e12 == "string" && ["expression", "symbol", "function"].includes(e12) || Oa(e12) || La(e12));
}
var yt = class yt2 {
  constructor(n) {
    typeof n == "string" ? this.type = k(n) : this.type = n;
  }
  matches(n) {
    return n instanceof yt2 ? v(this.type, n.type) : v(this.type, n);
  }
  is(n) {
    return v(this.type, n) && v(n, this.type);
  }
  get isUnknown() {
    return this.type === "unknown";
  }
  toString() {
    return ne(this.type);
  }
  toJSON() {
    return ne(this.type);
  }
  [Symbol.toPrimitive](n) {
    return n === "string" ? this.toString() : null;
  }
  valueOf() {
    return ne(this.type);
  }
};
yt.unknown = new yt("unknown");
var C = yt;
function yp(e12) {
  let n = [];
  for (let i = 0; i < e12.length; i++) {
    let t = e12.charCodeAt(i);
    if (t >= 55296 && t <= 56319) {
      let r = e12.charCodeAt(i + 1);
      if (r >= 56320 && r <= 57343) {
        let s = t - 55296, o = r - 56320;
        t = 2 ** 16 + s * 2 ** 10 + o, i++;
      }
    }
    n.push(t);
  }
  return n;
}
var xr = 8205;
var Fa = [127462, 127487];
function qa(e12) {
  return e12 === xr || e12 === 65038 || e12 === 65039 || e12 >= 127995 && e12 <= 128e3 || e12 >= 129456 && e12 <= 129460 || e12 >= 917536 && e12 <= 917632;
}
function bp(e12) {
  return e12 >= Fa[0] && e12 <= Fa[1];
}
function $a(e12) {
  if (/^[\u0020-\u00FF]*$/.test(e12)) return e12;
  let n = [], i = yp(e12), t = 0;
  for (; t < i.length; ) {
    let r = i[t++], s = i[t];
    if (s === xr) {
      let o = t - 1;
      for (t += 2; i[t] === xr; ) t += 2;
      n.push(String.fromCodePoint(...i.slice(o, 2 * t - o + 1)));
    } else if (qa(s)) {
      let o = t - 1;
      for (; qa(i[t]); ) t += i[t] === xr ? 2 : 1;
      n.push(String.fromCodePoint(...i.slice(o, 2 * t - o - 1)));
    } else bp(r) ? (t += 1, n.push(String.fromCodePoint(...i.slice(t - 2, 2)))) : n.push(String.fromCodePoint(r));
  }
  return n;
}
var Ts = class {
  constructor(n) {
    this.obeyspaces = false;
    n = n.replace(/[\u200E\u200F\u2066-\u2069\u202A-\u202E]/g, ""), n = n.replace(/\u2212/g, "-"), this.s = $a(n), this.pos = 0;
  }
  end() {
    return this.pos >= this.s.length;
  }
  get() {
    return this.pos < this.s.length ? this.s[this.pos++] : "";
  }
  peek() {
    return this.s[this.pos];
  }
  match(n) {
    let i;
    return typeof this.s == "string" ? i = n.exec(this.s.slice(this.pos)) : i = n.exec(this.s.slice(this.pos).join("")), (i == null ? void 0 : i[0]) ? (this.pos += i[0].length, i[0]) : null;
  }
  next() {
    if (this.end()) return null;
    if (!this.obeyspaces && this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]+/)) return "<space>";
    if (this.obeyspaces && this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]/)) return "<space>";
    let n = this.get();
    if (n === "\\") {
      if (!this.end()) {
        let i = this.match(/^[a-zA-Z]+/);
        if (i) this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]*/);
        else if (i = this.get(), i === " ") return "<space>";
        return "\\" + i;
      }
    } else {
      if (n === "{") return "<{>";
      if (n === "}") return "<}>";
      if (n === "^") {
        if (this.peek() === "^") {
          this.get();
          let i = this.match(/^(\^(\^(\^(\^[0-9a-f])?[0-9a-f])?[0-9a-f])?[0-9a-f])?[0-9a-f][0-9a-f]/);
          if (i) return String.fromCodePoint(parseInt(i.slice(i.lastIndexOf("^") + 1), 16));
        }
        return n;
      } else if (n === "#") {
        if (!this.end()) {
          let i = false;
          if (/[0-9?]/.test(this.peek()) && (i = true, this.pos + 1 < this.s.length)) {
            let t = this.s[this.pos + 1];
            i = /[^0-9A-Za-z]/.test(t);
          }
          return i ? "#" + this.get() : "#";
        }
      } else if (n === "$") return this.peek() === "$" ? (this.get(), "<$$>") : "<$>";
    }
    return n;
  }
};
function Ep(e12, n) {
  var _a2, _b, _c2, _d2;
  let i = e12.next();
  if (!i) return [];
  let t = [];
  if (i !== "\\relax") {
    if (i === "\\noexpand") i = e12.next(), i && t.push(i);
    else if (i === "\\obeyspaces") e12.obeyspaces = true;
    else if (i === "\\space" || i === "~") t.push("<space>");
    else if (i === "\\bgroup") t.push("<{>");
    else if (i === "\\egroup") t.push("<}>");
    else if (i === "\\string") i = e12.next(), i && (i[0] === "\\" ? Array.from(i).forEach((r) => t.push(r === "\\" ? "\\backslash" : r)) : i === "<{>" ? t.push("\\{") : i === "<space>" ? t.push("~") : i === "<}>" && t.push("\\}"));
    else if (i === "\\csname") {
      for (; e12.peek() === "<space>"; ) e12.next();
      let r = "", s = false, o = [];
      do {
        if (o.length === 0) if (/^#[0-9?]$/.test(e12.peek())) {
          let a = e12.get().slice(1);
          o = de((_b = (_a2 = n == null ? void 0 : n[a]) != null ? _a2 : n == null ? void 0 : n["?"]) != null ? _b : "\\placeholder{}", n), i = o[0];
        } else i = e12.next(), o = i ? [i] : [];
        s = o.length === 0, !s && i === "\\endcsname" && (s = true, o.shift()), s || (s = i === "<$>" || i === "<$$>" || i === "<{>" || i === "<}>" || !!i && i.length > 1 && i[0] === "\\"), s || (r += o.shift());
      } while (!s);
      r && t.push("\\" + r), t = t.concat(o);
    } else if (i !== "\\endcsname") if (i.length > 1 && i[0] === "#") {
      let r = i.slice(1);
      t = t.concat(de((_d2 = (_c2 = n == null ? void 0 : n[r]) != null ? _c2 : n == null ? void 0 : n["?"]) != null ? _d2 : "\\placeholder{}", n));
    } else t.push(i);
  }
  return t;
}
function de(e12, n = []) {
  let i = e12.toString().split(/\r?\n/), t = "", r = "";
  for (let a of i) {
    t += r, r = " ";
    let u = a.match(/((?:\\%)|[^%])*/);
    u !== null && (t += u[0]);
  }
  let s = new Ts(t), o = [];
  do
    o.push(...Ep(s, n));
  while (!s.end());
  return o;
}
function yr(e12) {
  return de(e12).length;
}
function b(e12) {
  let n = "", i = "";
  for (let t of e12) t != null && (typeof t == "string" && (/[a-zA-Z]/.test(t[0]) && (i += n), /\\[a-zA-Z]+\*?$/.test(t) ? n = " " : n = ""), i += t.toString());
  return i;
}
function Ii(e12, n, i) {
  return n.includes(e12) && (n = `{${n}}`), /^[0-9]$/.test(i) ? `${n}${e12}${i}` : `${n}${e12}{${i}}`;
}
function tn(e12) {
  let n = [];
  if (Array.isArray(e12)) for (let t of e12) Array.isArray(t) ? n = [...n, ...t] : n.push(t);
  else n = [e12];
  return b(n.map((t) => {
    var _a2;
    return (_a2 = { "<space>": " ", "<$$>": "$$", "<$>": "$", "<{>": "{", "<}>": "}" }[t]) != null ? _a2 : t;
  }));
}
function Va(e12) {
  return !("kind" in e12) || e12.kind === "expression";
}
function za(e12) {
  return "kind" in e12 && e12.kind === "symbol";
}
function bt(e12) {
  return "kind" in e12 && e12.kind === "matchfix";
}
function Ss(e12) {
  return "kind" in e12 && e12.kind === "infix";
}
function br(e12) {
  return "kind" in e12 && e12.kind === "prefix";
}
function _s(e12) {
  return "kind" in e12 && e12.kind === "postfix";
}
function Ga(e12) {
  return "kind" in e12 && e12.kind === "environment";
}
var ni = [{ latexTrigger: ["\\not", "<"], kind: "infix", associativity: "any", precedence: 246, parse: "NotLess" }, { name: "NotLess", latexTrigger: ["\\nless"], kind: "infix", associativity: "any", precedence: 246 }, { latexTrigger: ["<"], kind: "infix", associativity: "any", precedence: 245, parse: "Less" }, { name: "Less", latexTrigger: ["\\lt"], kind: "infix", associativity: "any", precedence: 245 }, { latexTrigger: ["<", "="], kind: "infix", associativity: "any", precedence: 241, parse: "LessEqual" }, { name: "LessEqual", latexTrigger: ["\\le"], kind: "infix", associativity: "any", precedence: 241 }, { latexTrigger: ["\\leq"], kind: "infix", associativity: "any", precedence: 241, parse: "LessEqual" }, { latexTrigger: ["\\leqslant"], kind: "infix", associativity: "any", precedence: 250, parse: "LessEqual" }, { name: "LessNotEqual", latexTrigger: ["\\lneqq"], kind: "infix", associativity: "any", precedence: 245 }, { name: "NotLessNotEqual", latexTrigger: ["\\nleqq"], kind: "infix", associativity: "any", precedence: 245 }, { name: "LessOverEqual", latexTrigger: ["\\leqq"], kind: "infix", associativity: "any", precedence: 250 }, { name: "GreaterOverEqual", latexTrigger: ["\\geqq"], kind: "infix", associativity: "any", precedence: 250, parse: "GreaterEqual" }, { name: "Equal", latexTrigger: ["="], kind: "infix", associativity: "right", precedence: 245 }, { latexTrigger: ["*", "="], kind: "infix", associativity: "right", precedence: 245, parse: "StarEqual" }, { name: "StarEqual", latexTrigger: ["\\star", "="], kind: "infix", associativity: "right", precedence: 245 }, { name: "PlusEqual", latexTrigger: ["+", "="], kind: "infix", associativity: "right", precedence: 245 }, { name: "MinusEqual", latexTrigger: ["-", "="], kind: "infix", associativity: "right", precedence: 245 }, { name: "SlashEqual", latexTrigger: ["/", "="], kind: "infix", associativity: "right", precedence: 245 }, { name: "EqualEqual", latexTrigger: ["=", "="], kind: "infix", associativity: "right", precedence: 245 }, { name: "EqualEqualEqual", latexTrigger: ["=", "=", "="], kind: "infix", associativity: "right", precedence: 250 }, { name: "TildeFullEqual", latexTrigger: ["\\cong"], kind: "infix", associativity: "right", precedence: 245 }, { name: "NotTildeFullEqual", latexTrigger: ["\\ncong"], kind: "infix", associativity: "right", precedence: 245 }, { name: "Approx", latexTrigger: ["\\approx"], kind: "infix", associativity: "right", precedence: 247 }, { name: "NotApprox", latexTrigger: ["\\not", "\\approx"], kind: "infix", associativity: "right", precedence: 247 }, { name: "ApproxEqual", latexTrigger: ["\\approxeq"], kind: "infix", associativity: "right", precedence: 245 }, { name: "NotApproxEqual", latexTrigger: ["\\not", "\\approxeq"], kind: "infix", associativity: "right", precedence: 250 }, { name: "NotEqual", latexTrigger: ["\\ne"], kind: "infix", associativity: "right", precedence: 255 }, { name: "Unequal", latexTrigger: ["!", "="], kind: "infix", associativity: "right", precedence: 245 }, { name: "GreaterEqual", latexTrigger: ["\\ge"], kind: "infix", associativity: "right", precedence: 242 }, { latexTrigger: ["\\geq"], kind: "infix", associativity: "right", precedence: 242, parse: "GreaterEqual" }, { latexTrigger: [">", "="], kind: "infix", associativity: "right", precedence: 243, parse: "GreaterEqual" }, { latexTrigger: ["\\geqslant"], kind: "infix", associativity: "right", precedence: 250, parse: "GreaterEqual" }, { name: "GreaterNotEqual", latexTrigger: ["\\gneqq"], kind: "infix", associativity: "right", precedence: 245 }, { name: "NotGreaterNotEqual", latexTrigger: ["\\ngeqq"], kind: "infix", associativity: "right", precedence: 245 }, { latexTrigger: [">"], kind: "infix", associativity: "right", precedence: 245, parse: "Greater" }, { name: "Greater", latexTrigger: ["\\gt"], kind: "infix", associativity: "right", precedence: 245 }, { name: "NotGreater", latexTrigger: ["\\ngtr"], kind: "infix", associativity: "right", precedence: 244 }, { latexTrigger: ["\\not", ">"], kind: "infix", associativity: "right", precedence: 244, parse: "NotGreater" }, { name: "RingEqual", latexTrigger: ["\\circeq"], kind: "infix", associativity: "right", precedence: 245 }, { name: "TriangleEqual", latexTrigger: ["\\triangleq"], kind: "infix", associativity: "right", precedence: 245 }, { name: "DotEqual", latexTrigger: ["\\doteq"], kind: "infix", associativity: "right", precedence: 250 }, { name: "DotEqualDot", latexTrigger: ["\\doteqdot"], kind: "infix", associativity: "right", precedence: 250 }, { name: "FallingDotEqual", latexTrigger: ["\\fallingdotseq"], kind: "infix", associativity: "right", precedence: 250 }, { name: "RisingDotEqual", latexTrigger: ["\\fallingdotseq"], kind: "infix", associativity: "right", precedence: 250 }, { name: "QuestionEqual", latexTrigger: ["\\questeq"], kind: "infix", associativity: "right", precedence: 245 }, { name: "MuchLess", latexTrigger: ["\\ll"], kind: "infix", associativity: "right", precedence: 245 }, { name: "MuchGreater", latexTrigger: ["\\gg"], kind: "infix", associativity: "right", precedence: 245 }, { name: "Precedes", latexTrigger: ["\\prec"], kind: "infix", associativity: "right", precedence: 245 }, { name: "Succeeds", latexTrigger: ["\\succ"], kind: "infix", associativity: "right", precedence: 245 }, { name: "PrecedesEqual", latexTrigger: ["\\preccurlyeq"], kind: "infix", associativity: "right", precedence: 245 }, { name: "SucceedsEqual", latexTrigger: ["\\curlyeqprec"], kind: "infix", associativity: "right", precedence: 245 }, { name: "NotPrecedes", latexTrigger: ["\\nprec"], kind: "infix", associativity: "right", precedence: 245 }, { name: "NotSucceeds", latexTrigger: ["\\nsucc"], kind: "infix", associativity: "right", precedence: 245 }, { name: "Between", latexTrigger: ["\\between"], kind: "infix", associativity: "right", precedence: 250 }];
function Is(e12, n, i = {}) {
  let { contract: t = 0.125, step: r = 1, power: s = 2, atol: o = 1e-16, rtol: a = o > 0 ? 0 : Math.sqrt(Number.EPSILON), maxeval: u = 1e6, breaktol: l = 2 } = i;
  if (!isFinite(n)) return Is((E) => e12(1 / E), 1 / n, { rtol: a, atol: o, maxeval: u, contract: Math.abs(t) > 1 ? 1 / t : t, step: 1 / r, power: s });
  let f = r, c = Math.pow(1 / t, s), p = e12(n + f), m = [p], y = 1 / 0, x = 1;
  for (; x < u; ) {
    x += 1, f *= t, m.push(e12(n + f));
    let E = c, _ = 1 / 0;
    for (let R = m.length - 2; R >= 0; R--) {
      let I = m[R];
      m[R] = m[R + 1] + (m[R + 1] - m[R]) / (E - 1);
      let q = Math.abs(m[R] - I);
      _ = Math.min(_, q), q < y && (p = m[R], y = q), E *= c;
    }
    if (_ > l * y || !isFinite(_) || y <= Math.max(a * Math.abs(p), o)) break;
  }
  return [p, y];
}
function K(e12) {
  var _a2, _b;
  if (typeof e12 == "bigint") return e12;
  if (typeof e12 == "number") return Number.isInteger(e12) ? e12 >= Number.MAX_SAFE_INTEGER && e12 <= Number.MAX_SAFE_INTEGER ? BigInt(e12) : K(e12.toString()) : null;
  if (e12 instanceof M) return e12.isInteger() ? K(e12.toString()) : null;
  let n = e12.toLowerCase(), i = n.match(/([+-]?[0-9]*)(?:\.([0-9]+))?e([+-]?[0-9]+)$/);
  if (i) {
    let s = parseInt(i[3]) - (i[2] ? i[2].length : 0);
    if (s < 0) return null;
    n = ((_a2 = i[1]) != null ? _a2 : "") + ((_b = i[2]) != null ? _b : "") + "0".repeat(s);
  }
  if (n.indexOf(".") >= 0 || !/^[+-]?[0-9]+$/.test(n)) return null;
  try {
    return BigInt(n);
  } catch (r) {
    return console.error(r.message), null;
  }
}
var Ua = 1125899906842597;
var Bs = /* @__PURE__ */ new Set([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919]);
var ja = 7919;
function Za(e12) {
  var _a2, _b;
  if (Number.isInteger(e12) && e12 >= 0 && e12 < Number.MAX_SAFE_INTEGER, e12 <= 3) return { [e12]: 1 };
  let n = {}, i = 0;
  for (; e12 % 2 === 0; ) i += 1, e12 /= 2;
  for (i > 0 && (n[2] = i), i = 0; e12 % 3 === 0; ) i += 1, e12 /= 3;
  i > 0 && (n[3] = i);
  let t = false;
  for (; !t; ) {
    if (e12 === 1) return n;
    let r = Math.sqrt(e12);
    t = true;
    for (let s = 6; s <= r + 6; s += 6) {
      if (e12 % (s - 1) === 0) {
        n[s - 1] = ((_a2 = n[s - 1]) != null ? _a2 : 0) + 1, e12 /= s - 1, t = false;
        break;
      }
      if (e12 % (s + 1) === 0) {
        n[s + 1] = ((_b = n[s + 1]) != null ? _b : 0) + 1, e12 /= s + 1, t = false;
        break;
      }
    }
  }
  return n[e12] !== void 0 ? n[e12] += 1 : n[e12] = 1, n;
}
function ks(e12) {
  if (!Number.isInteger(e12) || !Number.isFinite(e12) || Number.isNaN(e12) || e12 <= 1) return false;
  if (e12 <= ja) return Bs.has(e12);
  for (let n of Bs) if (e12 % n === 0) return false;
  return e12 < Ua && Np(e12), Tp(e12, 30) ? void 0 : false;
}
function Np(e12) {
  if (e12 === 1) return 1;
  if (e12 % 2 === 0) return 2;
  if (e12 % 3 === 0) return 3;
  if (e12 % 5 === 0) return 5;
  let n = Math.floor(Math.sqrt(e12)), i = 7;
  for (; i <= n; ) {
    if (e12 % i === 0) return i;
    if (e12 % (i + 4) === 0) return i + 4;
    if (e12 % (i + 6) === 0) return i + 6;
    if (e12 % (i + 10) === 0) return i + 10;
    if (e12 % (i + 12) === 0) return i + 12;
    if (e12 % (i + 16) === 0) return i + 16;
    if (e12 % (i + 22) === 0) return i + 22;
    if (e12 % (i + 24) === 0) return i + 24;
    i += 30;
  }
  return e12;
}
function Ha(e12) {
  if (e12 <= 1) return false;
  if (e12 <= ja) return ks(Number(e12));
  for (let n of Bs) if (e12 % BigInt(n) === BigInt(0)) return false;
  return e12 < Ua && (e12 = vp(e12)), Sp(e12, 30) ? void 0 : false;
}
function vp(e12) {
  if (e12 === BigInt(1)) return BigInt(1);
  if (e12 % BigInt(2) === BigInt(0)) return BigInt(2);
  if (e12 % BigInt(3) === BigInt(0)) return BigInt(3);
  if (e12 % BigInt(5) === BigInt(0)) return BigInt(5);
  let n = BigInt(Math.floor(Math.sqrt(Number(e12)))), i = BigInt(7);
  for (; i <= n; ) {
    if (e12 % i === BigInt(0)) return i;
    if (e12 % (i + BigInt(4)) === BigInt(0)) return i + BigInt(4);
    if (e12 % (i + BigInt(6)) === BigInt(0)) return i + BigInt(6);
    if (e12 % (i + BigInt(10)) === BigInt(0)) return i + BigInt(10);
    if (e12 % (i + BigInt(12)) === BigInt(0)) return i + BigInt(12);
    if (e12 % (i + BigInt(16)) === BigInt(0)) return i + BigInt(16);
    if (e12 % (i + BigInt(22)) === BigInt(0)) return i + BigInt(22);
    if (e12 % (i + BigInt(24)) === BigInt(0)) return i + BigInt(24);
    i += BigInt(30);
  }
  return e12;
}
function Tp(e12, n) {
  let i = 0, t = e12 - 1;
  for (; t % 2 === 0; ) t /= 2, ++i;
  e: do {
    let r = Math.pow(2 + Math.floor(Math.random() * (e12 - 3)), t) % e12;
    if (!(r === 1 || r === e12 - 1)) {
      for (let s = i - 1; s--; ) {
        if (r = r * r % e12, r === 1) return false;
        if (r === e12 - 1) continue e;
      }
      return false;
    }
  } while (--n);
  return true;
}
function Sp(e12, n) {
  let i = 0, t = e12 - BigInt(1);
  for (; t % BigInt(2) === BigInt(0); ) t = t / BigInt(2), ++i;
  e: do {
    let r = BigInt(2 + Math.floor(Math.random() * (Number(e12) - 3))) ** t % e12;
    if (!(r === BigInt(1) || r === e12 - BigInt(1))) {
      for (let s = i - 1; s--; ) {
        if (r = r * r % e12, r === BigInt(1)) return false;
        if (r === e12 - BigInt(1)) continue e;
      }
      return false;
    }
  } while (--n);
  return true;
}
var oh = [BigInt(4), BigInt(2), BigInt(4), BigInt(2), BigInt(4), BigInt(6), BigInt(2), BigInt(6)];
var ws = 21;
var _p = 53;
var cn = Math.floor(Math.log10(Math.pow(2, _p)));
var Ds = 1e-10;
var O = 1e6;
var Wa = 1024;
var Et = 1e6;
function Bi(e12, n) {
  if (e12 >= Number.MAX_SAFE_INTEGER) return [1, e12];
  if (e12 === 0) return [0, 0];
  if (e12 === 1) return [1, 1];
  if (Number.isInteger(e12) && e12 > 0 && e12 < Number.MAX_SAFE_INTEGER, n === 2) {
    let s = [[0, 0], [1, 1], [1, 2], [1, 3], [2, 1], [1, 5], [1, 6], [1, 7], [1, 8], [3, 1], [1, 10], [1, 11], [2, 3], [1, 13], [1, 14], [1, 15], [4, 1], [1, 17], [3, 2], [1, 19], [1, 20]][e12];
    if (s) return s;
  }
  let i = Za(e12), t = 1, r = 1;
  for (let s of Object.keys(i)) {
    let o = parseInt(s);
    t = t * Math.pow(o, Math.floor(i[s] / n)), r = r * Math.pow(o, i[s] % n);
  }
  return [t, r];
}
function rn(e12, n) {
  if (e12 === 0) return n;
  if (n === 0 || e12 === n) return e12;
  if (!Number.isInteger(e12) || !Number.isInteger(n)) return NaN;
  for (; n !== 0; ) [e12, n] = [n, e12 % n];
  return e12 < 0 ? -e12 : e12;
}
function ki(e12, n) {
  return e12 * n / rn(e12, n);
}
function Ja(e12) {
  if (!Number.isInteger(e12) || e12 < 0) return NaN;
  if (e12 >= 170) return 1 / 0;
  let n = 1;
  for (let i = 2; i <= e12; i++) n = n * i;
  return n;
}
function Ya(e12) {
  if (!Number.isInteger(e12) || e12 < 0) return NaN;
  if (e12 < 0) return NaN;
  if (e12 <= 1) return 1;
  let n = e12;
  for (; e12 > 2; ) e12 -= 2, n *= e12;
  return n;
}
function Qa(e12, n = Ds) {
  return typeof e12 == "number" && Math.abs(e12) <= n ? 0 : e12;
}
function Xa(e12, n, i = 0.1) {
  return (e12(n - 4 * i) / 280 - 4 * e12(n - 3 * i) / 105 + e12(n - 2 * i) / 5 - 4 * e12(n - i) / 5 + 4 * e12(n + i) / 5 - e12(n + 2 * i) / 5 + 4 * e12(n + 3 * i) / 105 - e12(n + 4 * i) / 280) / i;
}
function ii(e12, n, i = 1) {
  if (i === 0) {
    let s = ii(e12, n, -1), o = ii(e12, n, 1);
    return s === void 0 || o === void 0 ? NaN : Math.abs(s - o) > 1e-5 ? NaN : (s + o) / 2;
  }
  let [t, r] = Is(e12, n, { step: i > 0 ? 1 : -1 });
  return t;
}
function _n(e12) {
  return typeof e12 == "object" && e12 !== null && "engine" in e12;
}
function oe(e12) {
  return e12.precision > cn;
}
function Nt(e12) {
  return typeof e12 == "string" ? e12.startsWith("$") && e12.endsWith("$") : false;
}
function Vn(e12) {
  if (typeof e12 == "number") return e12.toString();
  if (typeof e12 == "string") {
    let n = e12.trim();
    if (n.startsWith("$$") && n.endsWith("$$")) return n.slice(2, -2);
    if (n.startsWith("$") && n.endsWith("$")) return n.slice(1, -1);
  }
  return Array.isArray(e12) ? Vn(b(e12)) : null;
}
function pn(e12) {
  let n = 0;
  for (let i = 0; i < e12.length; i++) n = Math.imul(31, n) + e12.charCodeAt(i) | 0;
  return Math.abs(n);
}
function vt(e12) {
  return e12 == null ? [] : typeof e12 == "string" ? [e12] : _n(e12) ? vt(e12.symbol) : typeof e12[Symbol.iterator] == "function" ? Array.from(e12).map((n) => typeof n == "string" ? n : n.symbol) : [];
}
function we(e12) {
  return typeof e12 != "string" ? false : ni.some((n) => n.name === e12);
}
function Er(e12) {
  return ["Less", "LessEqual", "Greater", "GreaterEqual"].includes(e12);
}
function Nr(e12) {
  return ["Equal", "NotEqual"].includes(e12);
}
function zn(e12) {
  let n = e12.operator;
  return typeof n != "string" ? false : Er(n);
}
function As(e12) {
  let n = e12.operator;
  return typeof n != "string" ? false : Nr(n);
}
function wi(e12) {
  var _a2, _b;
  if (typeof e12 == "number") return;
  let n = e12.engine;
  if (e12.symbol === "ImaginaryUnit") return n.One;
  if (e12.re === 0) return n.number(e12.im);
  if (e12.operator === "Negate") return (_a2 = wi(e12.op1)) == null ? void 0 : _a2.neg();
  if (e12.operator === "Complex") return e12.op1.is(0) && !isNaN(e12.op2.re) ? n.number(e12.op2.re) : void 0;
  if (e12.operator === "Multiply" && e12.nops === 2) {
    let [i, t] = e12.ops;
    if (i.symbol === "ImaginaryUnit") return t;
    if (t.symbol === "ImaginaryUnit") return i;
    if (t.isNumberLiteral && t.re === 0 && t.im !== 0) return i.mul(t.im);
    if (i.isNumberLiteral && i.re === 0 && i.im !== 0) return t.mul(i.im);
  }
  if (e12.operator === "Divide") {
    let i = e12.op2;
    return i.is(0) ? void 0 : (_b = wi(e12.op1)) == null ? void 0 : _b.div(i);
  }
}
function Rs(e12) {
  if (!e12) return;
  let n = { ...e12 };
  return n.odd && (n.even = false), n.even && (n.odd = false), n;
}
function Tt(e12) {
  if (e12 == null || typeof e12 != "object" || _n(e12)) return false;
  if ("value" in e12 || "constant" in e12 || "inferred" in e12 || "type" in e12) {
    if ("type" in e12 && typeof e12.type != "string") throw new Error("The `type` field of a symbol definition should be of type `string`");
    if ("signature" in e12) throw new Error("Symbol definition cannot have a `signature` field. Use a `type` field instead.");
    if ("sgn" in e12) throw new Error("Symbol definition cannot have a `sgn` field. Use a `flags.sgn` field instead.");
    return true;
  }
  return false;
}
function St(e12) {
  if (e12 == null || typeof e12 != "object" || _n(e12)) return false;
  if (("signature" in e12 || "complexity" in e12) && "constant" in e12) throw new Error("Function definition cannot have a `constant` field and symbol definition cannot have a `signature` field.");
  if (!("evaluate" in e12) && !("signature" in e12) && !("sgn" in e12) && !("complexity" in e12) && !("canonical" in e12)) return false;
  if ("type" in e12 && typeof e12.type != "function") throw new Error("The `type` field of a function definition should be a function");
  if ("sgn" in e12 && typeof e12.sgn != "function") throw new Error("The `sgn` field of a function definition should be a function");
  return true;
}
function Di(e12, n) {
  return n.every((i) => _n(i)) ? n.every((i) => i.isCanonical) ? n : n.map((i) => i.canonical) : n.map((i) => e12.box(i));
}
function Fe(e12, n) {
  return n.every((i) => _n(i) && i.isCanonical) ? n : n.map((i) => e12.box(i));
}
function vr(e12) {
  return e12.symbol === "Numbers" ? "number" : e12.symbol === "ComplexNumbers" ? "complex" : e12.symbol === "ImaginaryNumbers" ? "imaginary" : e12.symbol === "RealNumbers" ? "real" : e12.symbol === "RationalNumbers" ? "rational" : e12.symbol === "Integers" ? "integer" : "unknown";
}
function Ip(e12) {
  if (!e12) return e12;
  let n = e12.engine, i = n.angularUnit;
  return i === "rad" || (i === "deg" && (e12 = e12.mul(n.Pi).div(180)), i === "grad" && (e12 = e12.mul(n.Pi).div(200)), i === "turn" && (e12 = e12.mul(n.Pi).mul(2))), e12;
}
function Tr(e12) {
  if (!e12) return e12;
  let n = Ip(e12);
  if (!n) return;
  if (n.N().im !== 0) return n;
  let i = n.engine, [t, r] = ti(n);
  if (t.isZero) return i.number(r);
  let s = i._numericValue(t.bignumRe ? t.bignumRe.mod(2) : t.re % 2);
  return i.number(r.add(i.Pi.mul(s).N().numericValue));
}
function ti(e12) {
  var _a2;
  let n = e12.engine;
  if (e12.symbol === "Pi") return [n._numericValue(1), n._numericValue(0)];
  if (e12.operator === "Negate") {
    let [i, t] = ti(e12.ops[0]);
    return [i.neg(), t.neg()];
  }
  if (e12.operator === "Add" && e12.nops === 2) {
    let [i, t] = ti(e12.op1), [r, s] = ti(e12.op2);
    return [i.add(r), t.add(s)];
  }
  if (e12.operator === "Multiply" && e12.nops === 2) {
    if (e12.op1.isNumberLiteral) {
      let [i, t] = ti(e12.op2), r = e12.op1.numericValue;
      return [i.mul(r), t.mul(r)];
    }
    if (e12.op2.isNumberLiteral) {
      let [i, t] = ti(e12.op1), r = e12.op2.numericValue;
      return [i.mul(r), t.mul(r)];
    }
  }
  if (e12.operator === "Divide" && e12.op2.isNumberLiteral) {
    let [i, t] = ti(e12.op1), r = e12.op2.numericValue;
    return [i.div(r), t.div(r)];
  }
  return [n._numericValue(0), n._numericValue((_a2 = e12.N().numericValue) != null ? _a2 : 0)];
}
var dn = class extends Error {
  constructor({ message: n, value: i, cause: t } = {}) {
    super(n != null ? n : "Operation canceled"), i && (this.value = i), this.cause = t, this.name = "CancellationError";
  }
};
async function Ai(e12, n, i) {
  let t = performance.now();
  for (; ; ) {
    let r = performance.now(), s = 16;
    for (; performance.now() - r < s; ) {
      let { done: o, value: a } = e12.next();
      if (o) return a;
      if (i == null ? void 0 : i.aborted) throw new dn({ value: a, cause: i.reason });
      if (performance.now() - t >= n) throw new dn({ value: a, cause: "timeout", message: `Timeout exceeded (${n}ms)` });
    }
    await new Promise((o) => setTimeout(o, 0));
  }
}
function Ri(e12, n) {
  let i = Date.now();
  for (; ; ) {
    let { done: t, value: r } = e12.next();
    if (t) return r;
    if (Date.now() - i >= n) throw new dn({ value: r, cause: "timeout", message: `Timeout exceeded (${n}ms)` });
  }
}
var Ka = 100;
function ri(e12) {
  let n = Bp(e12);
  return n === void 0 ? false : Number.isFinite(n);
}
function si(e12) {
  var _a2, _b;
  return e12 = _t(e12), e12.string !== null ? true : ((_b = (_a2 = e12.functionDefinition) == null ? void 0 : _a2.collection) == null ? void 0 : _b.at) !== void 0;
}
function ie(e12) {
  var _a2, _b, _c2, _d2;
  if (e12 = _t(e12), e12.string !== null) return true;
  let n = e12.functionDefinition;
  return n ? ((_a2 = n.collection) == null ? void 0 : _a2.at) !== void 0 && Number.isFinite((_d2 = (_c2 = (_b = n.collection) == null ? void 0 : _b.size) == null ? void 0 : _c2.call(_b, e12)) != null ? _d2 : 1 / 0) : false;
}
function* ee(e12) {
  let n = Mi(e12);
  if (!n) {
    yield e12;
    return;
  }
  let i = e12.engine.iterationLimit, t = 0;
  for (; ; ) {
    let { done: r, value: s } = n.next();
    if (r) return;
    if (t++ > i) throw new dn({ cause: "iteration-limit-exceeded" });
    yield s;
  }
}
function Bp(e12) {
  var _a2, _b, _c2;
  e12 = _t(e12);
  let n = e12.string;
  return n !== null ? n.length : (_c2 = (_b = (_a2 = e12.functionDefinition) == null ? void 0 : _a2.collection) == null ? void 0 : _b.size) == null ? void 0 : _c2.call(_b, e12);
}
function Mi(e12) {
  var _a2;
  e12 = _t(e12);
  let n = e12.functionDefinition;
  if ((_a2 = n == null ? void 0 : n.collection) == null ? void 0 : _a2.iterator) return n.collection.iterator(e12);
  let i = e12.string;
  if (i !== null) {
    if (i.length === 0) return { next: () => ({ done: true, value: void 0 }) };
    let t = 0;
    return { next: () => ({ value: e12.engine.string(i.charAt(t++)), done: t > i.length }) };
  }
}
function kp(e12, n) {
  return typeof n == "number" ? (n < 0 && (n = 0), { next() {
    return n === 0 ? { done: true, value: void 0 } : (n--, { done: false, value: e12 });
  } }) : { next() {
    return { done: false, value: e12 };
  } };
}
function eu(e12) {
  if (!e12) return;
  let n = {};
  if (!e12.contains || !e12.size) throw new Error('A collection must have at least a "contains" and "size" handler');
  e12.contains && (n.contains = e12.contains), e12.size && (n.size = e12.size), e12.at && (n.at = e12.at), e12.iterator && (n.iterator = e12.iterator), e12.keys && (n.keys = e12.keys), e12.indexOf && (n.indexOf = e12.indexOf), e12.subsetOf && (n.subsetOf = e12.subsetOf);
  let i = n.iterator;
  return n.at && !i && (i = (t, r = 1, s = -1) => {
    let o = e12.at, a = r;
    return { next() {
      if (s >= 0 && a >= r + s) return { done: true, value: void 0 };
      let u = o(t, a);
      return u === void 0 ? { done: true, value: void 0 } : (a++, { done: false, value: u });
    } };
  }, n.iterator = i), n.indexOf || (n.indexOf = (t, r) => {
    let s = 1, o = i(t), a = o.next();
    for (; !a.done; ) {
      if (r.isSame(a.value)) return s;
      s++, a = o.next();
    }
  }), { contains: e12.contains, size: e12.size, at: e12.at, iterator: i, keys: e12.keys, indexOf: e12.indexOf, subsetOf: e12.subsetOf };
}
function _t(e12) {
  var _a2;
  return e12.symbolDefinition && e12.symbolDefinition.holdUntil === "never" ? (_a2 = e12.symbolDefinition.value) != null ? _a2 : e12 : e12;
}
function Ms(e12) {
  e12 = e12.map((i) => _t(i));
  let n = e12.map((i) => {
    var _a2;
    return (_a2 = Mi(i)) != null ? _a2 : kp(i);
  });
  return { next() {
    let i = n.map((t) => t.next());
    return i.some((t) => t.done) ? { done: true, value: void 0 } : { done: false, value: i.map((t) => t.value) };
  } };
}
function J(e12, n) {
  let i = e12.every((r) => r.isCanonical) ? e12 : e12.map((r) => r.canonical);
  if (n) {
    let r = (o) => o.symbol === "Nothing" || o.operator === n || o.operator === "Sequence";
    if (i.every((o) => !r(o))) return i;
    let s = [];
    for (let o of i) o.symbol !== "Nothing" && (o.ops && (o.operator === n || o.operator === "Sequence") ? s.push(...J(o.ops, n)) : s.push(o));
    return s;
  }
  if (i.every((r) => !(r.symbol === "Nothing" || r.operator === "Sequence"))) return i;
  let t = [];
  for (let r of i) r.symbol !== "Nothing" && (r.ops && r.operator === "Sequence" ? t.push(...J(r.ops, n)) : t.push(r));
  return t;
}
function Gn(e12, n) {
  if (!n || e12.every((t) => !t.ops || t.operator !== n)) return e12;
  let i = [];
  for (let t of e12) !t.ops || t.operator !== n ? i.push(t) : i.push(...Gn(t.ops, n));
  return i.length, e12.length, i.length === e12.length ? e12 : i;
}
function Cs(e12) {
  var _a2;
  if (e12.every((i) => i.operator !== "Sequence" && i.operator !== "Delimiter")) return e12;
  let n = [];
  for (let i of e12) if (!i.isValid) n.push(i);
  else if (i.operator === "Delimiter") if (i.op1.operator === "Sequence") {
    let t = (_a2 = i.op1.ops) != null ? _a2 : [];
    t.length === 0 ? n.push(i.engine.box(["Tuple"])) : n.push(...Cs(t));
  } else n.push(i.op1);
  else i.operator === "Sequence" ? i.ops && n.push(...i.ops) : n.push(i);
  return n;
}
function qe(e12, n, i) {
  if (n = J(n), !e12.strict || n.length === i) return n;
  let t = [...n.slice(0, i)], r = Math.min(i, n.length);
  for (; r < i; ) t.push(e12.error("missing")), r += 1;
  for (; r < n.length; ) t.push(e12.error("unexpected-argument", n[r].toString())), r += 1;
  return t;
}
function Me(e12, n, i) {
  var _a2, _b, _c2, _d2;
  let t = typeof i == "number" ? i : i == null ? void 0 : i.count, r = typeof i == "number" ? void 0 : i == null ? void 0 : i.flatten;
  if (n = J(n, r), !e12.strict) {
    let a = "real";
    for (let u of n) if (v("complex", u.type.type)) {
      a = "number";
      break;
    }
    for (let u of n) ie(u) || u.infer(a);
    return n;
  }
  let s = true;
  t != null ? t : t = n.length;
  let o = [];
  for (let a = 0; a <= Math.max(t - 1, n.length - 1); a++) {
    let u = n[a];
    if (a > t - 1) s = false, o.push(e12.error("unexpected-argument", u.toString()));
    else if (u === void 0) s = false, o.push(e12.error("missing"));
    else if (!u.isValid) s = false, o.push(u);
    else if (u.isNumber) o.push(u);
    else if (u.symbol && !e12.lookupSymbol(u.symbol) && !e12.lookupFunction(u.symbol)) o.push(u);
    else if (u.type.isUnknown) o.push(u);
    else if (ie(u)) {
      for (let l of ee(u)) if (!l.isNumber) {
        s = false;
        break;
      }
      s ? o.push(u) : o.push(e12.typeError("number", u.type, u));
    } else ((_a2 = u.symbolDefinition) == null ? void 0 : _a2.inferredType) && v("number", u.type.type) || ((_b = u.functionDefinition) == null ? void 0 : _b.inferredSignature) && v("number", u.type.type) || u.operator === "Hold" || ((_d2 = (_c2 = u.symbolDefinition) == null ? void 0 : _c2.value) == null ? void 0 : _d2.operator) === "Hold" ? o.push(u) : (s = false, o.push(e12.typeError("number", u.type, u)));
  }
  if (s) {
    let a = "real";
    for (let u of o) if (v("complex", u.type.type)) {
      a = "number";
      break;
    }
    for (let u of o) if (ie(u)) for (let l of ee(u)) l.infer(a);
    else u.infer(a);
  }
  return o;
}
function In(e12, n, i) {
  return n == null ? e12.error("missing") : i === void 0 ? e12.error("unexpected-argument", n.toString()) : (n = n.canonical, !n.isValid || n.type.matches(i) ? n : e12.typeError(i, n.type, n));
}
function Sr(e12, n, i) {
  if (n.length === i.length && n.every((r, s) => r.type.matches(i[s]))) return n;
  let t = [];
  for (let r = 0; r <= i.length - 1; r++) t.push(In(e12, n[r], i[r]));
  for (let r = i.length; r <= n.length - 1; r++) t.push(e12.error("unexpected-argument", n[r].toString()));
  return t;
}
function Ci(e12, n, i, t, r) {
  var _a2, _b, _c2, _d2, _e2, _f2, _g, _h, _i2, _j;
  if (!e12.strict || typeof i == "string" || i.kind !== "signature") return null;
  let s = [], o = true, a = (_b = (_a2 = i.args) == null ? void 0 : _a2.map((c) => c.type)) != null ? _b : [], u = (_d2 = (_c2 = i.optArgs) == null ? void 0 : _c2.map((c) => c.type)) != null ? _d2 : [], l = (_e2 = i.restArg) == null ? void 0 : _e2.type, f = 0;
  for (let c of a) {
    let p = n[f++];
    if (!p) {
      s.push(e12.error("missing")), o = false;
      continue;
    }
    if (t) {
      s.push(p);
      continue;
    }
    if (!p.isValid) {
      s.push(p), o = false;
      continue;
    }
    if (p.type.isUnknown) {
      s.push(p);
      continue;
    }
    if (r && ie(p)) {
      s.push(p);
      continue;
    }
    if (((_f2 = p.symbolDefinition) == null ? void 0 : _f2.inferredType) && p.type.matches(c)) {
      s.push(p);
      continue;
    }
    if (((_g = p.functionDefinition) == null ? void 0 : _g.inferredSignature) && p.type.matches(c)) {
      s.push(p);
      continue;
    }
    if (!p.type.matches(c)) {
      s.push(e12.typeError(c, p.type, p)), o = false;
      continue;
    }
    s.push(p);
  }
  for (let c of u) {
    let p = n[f];
    if (!p) break;
    if (t) {
      s.push(p), f += 1;
      continue;
    }
    if (!p.isValid) {
      s.push(p), o = false, f += 1;
      continue;
    }
    if (p.type.isUnknown) {
      s.push(p), f += 1;
      continue;
    }
    if (r && ie(p)) {
      s.push(p), f += 1;
      continue;
    }
    if (((_h = p.symbolDefinition) == null ? void 0 : _h.inferredType) && p.type.matches(c)) {
      s.push(p), f += 1;
      continue;
    }
    if (!p.type.matches(c)) {
      s.push(e12.typeError(c, p.type, p)), o = false, f += 1;
      continue;
    }
    s.push(p), f += 1;
  }
  if (l) for (let c of n.slice(f)) {
    if (f += 1, t) {
      s.push(c);
      continue;
    }
    if (!c.isValid) {
      s.push(c), o = false;
      continue;
    }
    if (c.type.isUnknown) {
      s.push(c);
      continue;
    }
    if (r && ie(c)) {
      s.push(c);
      continue;
    }
    if (((_i2 = c.symbolDefinition) == null ? void 0 : _i2.inferredType) && c.type.matches(l)) {
      s.push(c);
      continue;
    }
    if (!c.type.matches(l)) {
      s.push(e12.typeError(l, c.type, c)), o = false;
      continue;
    }
    s.push(c);
  }
  if (f < n.length) for (let c of n.slice(f)) s.push(e12.error("unexpected-argument", c.toString())), o = false;
  if (!o) return s;
  f = 0;
  for (let c of a) t || (!r || !ie(n[f])) && n[f].infer(c), f += 1;
  for (let c of u) {
    if (!n[f]) break;
    (!r || !ie(n[f])) && ((_j = n[f]) == null ? void 0 : _j.infer(c)), f += 1;
  }
  if (l) for (let c of n.slice(f)) t || (!r || !ie(c)) && c.infer(l), f += 1;
  return null;
}
function It(e12, n) {
  for (; n !== BigInt(0); ) [e12, n] = [n, e12 % n];
  return e12 < 0 ? -e12 : e12;
}
function nu(e12, n) {
  return e12 * n / It(e12, n);
}
function* _r(e12) {
  if (e12 < 0) return BigInt(0);
  if (e12 < 10) return BigInt([1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880][Number(e12)]);
  if (e12 % BigInt(2) === BigInt(1)) return e12 * (yield* _r(e12 - BigInt(1)));
  let n = e12, i = e12, t = e12, r = 0;
  for (; n > 2; ) n -= BigInt(2), i += n, t *= i, r += 1, (r % 5e4 === 0 || r > 1e4 && r % 500 === 0) && (yield t);
  return t;
}
function Bn(e12) {
  return e12 !== null && Array.isArray(e12);
}
function te(e12) {
  return e12 !== null && Array.isArray(e12) && typeof e12[0] == "number";
}
function iu(e12) {
  return e12 !== null && Array.isArray(e12) && typeof e12[0] == "bigint";
}
function mn(e12) {
  return e12[0] == 0;
}
function Ps(e12) {
  return e12[0] > 0;
}
function ve(e12) {
  return e12[0] == e12[1];
}
function Bt(e12) {
  return e12[0] === -e12[1];
}
function oi(e12) {
  return e12[1] == 1;
}
function Os(e12) {
  return Number(e12[0]);
}
function Ls(e12) {
  return Number(e12[1]);
}
function tu(e12) {
  return Number(e12[0]) / Number(e12[1]);
}
function ai(e12, n) {
  if (typeof e12[0] == "number" && !Number.isFinite(e12[0])) return e12;
  let i = n;
  if (i === null) return e12;
  if (iu(i)) return e12 = [BigInt(e12[0]), BigInt(e12[1])], [i[1] * e12[0] + i[0] * e12[1], i[1] * e12[1]];
  if (!Number.isFinite(i[0])) return i;
  if (iu(e12)) {
    let t = [BigInt(i[0]), BigInt(i[1])];
    return [t[1] * e12[0] + t[0] * e12[1], t[1] * e12[1]];
  }
  return [i[1] * e12[0] + i[0] * e12[1], i[1] * e12[1]];
}
function hn(e12, n) {
  return te(e12) && te(n) ? [e12[0] * n[0], e12[1] * n[1]] : te(e12) ? [BigInt(e12[0]) * n[0], BigInt(e12[1]) * n[1]] : te(n) ? [BigInt(n[0]) * e12[0], BigInt(n[1]) * e12[1]] : [e12[0] * n[0], e12[1] * n[1]];
}
function ui(e12) {
  return [-e12[0], e12[1]];
}
function ru(e12) {
  return e12[0] < 0 ? [-e12[1], -e12[0]] : [e12[1], e12[0]];
}
function su(e12) {
  return [Number(e12[0]), Number(e12[1])];
}
function Ir(e12, n) {
  return te(e12) && te(n) ? e12[1] === 1 && n[1] === 1 ? [rn(e12[0], n[0]), 1] : [rn(e12[0], n[0]), ki(e12[1], n[1])] : e12[1] === 1 && n[1] === 1 ? [It(BigInt(e12[0]), BigInt(n[0])), BigInt(1)] : [It(BigInt(e12[0]), BigInt(n[0])), nu(BigInt(e12[1]), BigInt(n[1]))];
}
function Pi(e12) {
  if (te(e12)) {
    if (e12[0] === 1 || e12[1] === 1) return e12;
    if (e12[1] < 0 && (e12 = [-e12[0], -e12[1]]), !Number.isFinite(e12[1])) return [0, 1];
    let r = rn(e12[0], e12[1]);
    return r <= 1 ? e12 : [e12[0] / r, e12[1] / r];
  }
  e12[1] < 0 && (e12 = [-e12[0], -e12[1]]);
  let n = It(e12[0], e12[1]), [i, t] = n <= 1 ? e12 : [e12[0] / n, e12[1] / n];
  return i <= Number.MAX_SAFE_INTEGER && i >= Number.MIN_SAFE_INTEGER && t <= Number.MAX_SAFE_INTEGER ? [Number(i), Number(t)] : [i, t];
}
function ou(e12) {
  if (!Number.isFinite(e12) || e12 % 1 === 0) return e12;
  let i = 1e-15, t = Math.floor(e12), r = 1, s = 0, o = t, a = 1;
  for (; e12 - t > i * a * a; ) {
    e12 = 1 / (e12 - t), t = Math.floor(e12);
    let u = r;
    r = o;
    let l = s;
    s = a, o = u + t * r, a = l + t * s;
  }
  return [o, a];
}
var z = class {
  get bignumRe() {
  }
  get bignumIm() {
  }
  isZeroWithTolerance(n) {
    return this.isZero;
  }
  valueOf() {
    return this.im === 0 ? this.bignumRe ? this.bignumRe.toFixed() : this.re : this.N().toString();
  }
  [Symbol.toPrimitive](n) {
    return n === "string" ? this.toString() : this.valueOf();
  }
  toJSON() {
    if (this.im === 0) {
      let n = this.re;
      if (Number.isFinite(n)) return n;
    }
    return this.N().toString();
  }
  print() {
    let n = console.log;
    n == null ? void 0 : n(this.toString());
  }
};
var Oi = class {
  static parse(n) {
    let i = new Fs(n), t = i.parseValue();
    if (i.skipWhitespace(), !i.isAtEnd()) throw i.error(`Unexpected token '${i.currentChar()}' after parsing complete value`);
    return t;
  }
};
var Fs = class {
  constructor(n) {
    this.index = 0;
    this.text = n;
  }
  parseValue() {
    if (this.skipWhitespace(), this.isAtEnd()) throw this.error("Unexpected end of input");
    let n = this.currentChar();
    return n === "{" ? this.parseObject() : n === "[" ? this.parseArray() : n === '"' || n === "'" ? this.parseString() : n === "-" || n === "+" || n >= "0" && n <= "9" || n === "." ? this.parseNumber() : this.parseIdentifier();
  }
  parseObject() {
    let n = {};
    if (this.expectChar("{"), this.skipWhitespace(), this.currentChar() === "}") return this.index++, n;
    for (; ; ) {
      this.skipWhitespace();
      let i, t = this.currentChar();
      t === '"' || t === "'" ? i = this.parseString() : i = this.parseIdentifier(), this.skipWhitespace(), this.expectChar(":"), this.skipWhitespace();
      let r = this.parseValue();
      if (n[i] = r, this.skipWhitespace(), this.currentChar() === ",") {
        if (this.index++, this.skipWhitespace(), this.currentChar() === "}") {
          this.index++;
          break;
        }
      } else if (this.currentChar() === "}") {
        this.index++;
        break;
      } else throw this.error(`Expected ',' or '}' in object but found '${this.currentChar()}'`);
    }
    return n;
  }
  parseArray() {
    let n = [];
    if (this.expectChar("["), this.skipWhitespace(), this.currentChar() === "]") return this.index++, n;
    for (; ; ) if (this.skipWhitespace(), n.push(this.parseValue()), this.skipWhitespace(), this.currentChar() === ",") {
      if (this.index++, this.skipWhitespace(), this.currentChar() === "]") {
        this.index++;
        break;
      }
    } else if (this.currentChar() === "]") {
      this.index++;
      break;
    } else throw this.error(`Expected ',' or ']' in array but found '${this.currentChar()}'`);
    return n;
  }
  parseString() {
    let n = this.currentChar();
    if (n !== '"' && n !== "'") throw this.error(`String should start with a quote, got '${n}'`);
    this.index++;
    let i = "";
    for (; !this.isAtEnd(); ) {
      let t = this.currentChar();
      if (t === n) return this.index++, i;
      if (t === "\\") {
        if (this.index++, this.isAtEnd()) throw this.error("Unterminated escape sequence in string");
        let r = this.currentChar();
        switch (r) {
          case "b":
            i += "\b";
            break;
          case "f":
            i += "\f";
            break;
          case "n":
            i += `
`;
            break;
          case "r":
            i += "\r";
            break;
          case "t":
            i += "	";
            break;
          case "v":
            i += "\v";
            break;
          case "\\":
            i += "\\";
            break;
          case "'":
            i += "'";
            break;
          case '"':
            i += '"';
            break;
          case "0":
            i += "\0";
            break;
          case "u": {
            this.index++;
            let s = this.text.substr(this.index, 4);
            if (!/^[0-9a-fA-F]{4}$/.test(s)) throw this.error(`Invalid Unicode escape sequence: \\u${s}`);
            i += String.fromCharCode(parseInt(s, 16)), this.index += 3;
            break;
          }
          default:
            i += r;
        }
        this.index++;
      } else i += t, this.index++;
    }
    throw this.error("Unterminated string literal");
  }
  parseNumber() {
    let n = this.index;
    if (this.text.startsWith("-Infinity", this.index)) return this.index += 9, -1 / 0;
    if (this.text.startsWith("+Infinity", this.index)) return this.index += 9, 1 / 0;
    if (this.text.startsWith("Infinity", this.index)) return this.index += 8, 1 / 0;
    for (; !this.isAtEnd() && /[0-9+\-_.eE]/.test(this.currentChar()); ) this.index++;
    let i = this.text.slice(n, this.index), t = i.replace(/_/g, ""), r = Number(t);
    if (isNaN(r)) throw this.error(`Invalid number: ${i}`);
    return r;
  }
  parseIdentifier() {
    let n = this.index, i = this.currentChar();
    if (!/[a-zA-Z$_]/.test(i)) throw this.error(`Unexpected token '${i}'`);
    for (this.index++; !this.isAtEnd(); ) {
      let r = this.currentChar();
      if (!/[a-zA-Z0-9$_]/.test(r)) break;
      this.index++;
    }
    let t = this.text.slice(n, this.index);
    return t === "true" ? true : t === "false" ? false : t === "null" ? null : t === "Infinity" ? 1 / 0 : t === "NaN" ? NaN : t;
  }
  skipWhitespace() {
    for (; !this.isAtEnd(); ) {
      let n = this.currentChar();
      if (/\s/.test(n)) {
        this.index++;
        continue;
      }
      if (n === "/") {
        let i = this.peekChar(1);
        if (i === "/") {
          for (this.index += 2; !this.isAtEnd() && this.currentChar() !== `
`; ) this.index++;
          continue;
        } else if (i === "*") {
          for (this.index += 2; !this.isAtEnd() && !(this.currentChar() === "*" && this.peekChar(1) === "/"); ) this.index++;
          if (this.isAtEnd()) throw this.error("Unterminated multi-line comment");
          this.index += 2;
          continue;
        }
      }
      break;
    }
  }
  expectChar(n) {
    if (this.currentChar() !== n) throw this.error(`Expected '${n}' but found '${this.currentChar()}'`);
    this.index++;
  }
  currentChar() {
    return this.text[this.index];
  }
  peekChar(n) {
    return this.text[this.index + n];
  }
  isAtEnd() {
    return this.index >= this.text.length;
  }
  error(n) {
    return new Error(`${n} at position ${this.index}`);
  }
};
var Li = ["Error", "'missing'"];
function kn(e12) {
  return !!(typeof e12 == "number" || Fi(e12) || typeof e12 == "string" && /^[+-]?[0-9\.]/.test(e12));
}
function Fi(e12) {
  return e12 !== null && typeof e12 == "object" && "num" in e12;
}
function kr(e12) {
  return e12 !== null && typeof e12 == "object" && "sym" in e12;
}
function wp(e12) {
  return e12 !== null && typeof e12 == "object" && "str" in e12;
}
function kt(e12) {
  return e12 !== null && typeof e12 == "object" && "fn" in e12;
}
function V(e12) {
  return e12 == null ? null : typeof e12 == "object" && "str" in e12 ? e12.str : typeof e12 != "string" || e12.length < 2 || e12.at(0) !== "'" || e12.at(-1) !== "'" ? null : e12.substring(1, e12.length - 1);
}
function $s(e12) {
  if (e12 == null || V(e12) !== null) return null;
  let n = h(e12);
  return n ? [n, ...N(e12).map((i) => $s(i)).filter((i) => i !== null)] : e12;
}
function h(e12) {
  return Array.isArray(e12) ? e12[0] : e12 == null ? "" : kt(e12) ? e12.fn[0] : "";
}
function N(e12) {
  return Array.isArray(e12) ? e12.slice(1) : e12 !== void 0 && kt(e12) ? e12.fn.slice(1) : [];
}
function d(e12, n) {
  var _a2, _b;
  return Array.isArray(e12) ? (_a2 = e12[n]) != null ? _a2 : null : e12 === null || !kt(e12) ? null : (_b = e12.fn[n]) != null ? _b : null;
}
function Y(e12) {
  return e12 == null ? 0 : Array.isArray(e12) ? Math.max(0, e12.length - 1) : kt(e12) ? Math.max(0, e12.fn.length - 1) : 0;
}
function Vs(e12) {
  return e12 == null ? null : h(e12) === "Hold" ? d(e12, 1) : e12;
}
function A(e12) {
  if (typeof e12 == "string") return /^[+-]?[0-9\.]/.test(e12) || e12.length >= 2 && e12[0] === "'" && e12[e12.length - 1] === "'" ? null : e12;
  if (e12 == null) return null;
  let n = kr(e12) ? e12.sym : e12;
  return typeof n != "string" ? null : n;
}
function au(e12) {
  let n = h(e12);
  if (n === "KeyValuePair" || n === "Tuple" || n === "Pair") {
    let [i, t] = N(e12), r = V(i);
    return r ? [r, t != null ? t : "Nothing"] : null;
  }
  return null;
}
function zs(e12) {
  if (e12 === null) return null;
  if (typeof e12 == "object" && !("sym" in e12) && !("num" in e12) && !("str" in e12) && !("fn" in e12)) return e12;
  if (typeof e12 == "string" && e12[0] === "{" && e12[e12.length - 1] === "}") try {
    return Oi.parse(e12);
  } catch (e13) {
    return null;
  }
  let n = au(e12);
  if (n) return { [n[0]]: n[1] };
  if (h(e12) === "Dictionary") {
    let i = {}, t = N(e12);
    for (let r = 1; r < Y(e12); r++) {
      let s = au(t[r]);
      s && (i[s[0]] = s[1]);
    }
    return i;
  }
  return null;
}
function wr(e12) {
  let n = Object.keys(e12);
  if (n.length === 0) return ["Dictionary"];
  if (n.length === 1) return ["Pair", { str: n[0] }, e12[n[0]]];
  let i = [];
  for (let t of n) i.push(["Pair", { str: t }, e12[t]]);
  return ["Dictionary", ...i];
}
function Dp(e12) {
  var _a2;
  if (e12 = e12.toLowerCase().replace(/[nd]$/, "").replace(/[\u0009-\u000d\u0020\u00a0]/g, ""), e12 === "nan") return NaN;
  if (e12 === "infinity" || e12 === "+infinity") return 1 / 0;
  if (e12 === "-infinity") return -1 / 0;
  if (/\([0-9]+\)/.test(e12)) {
    let [n, i, t, r] = (_a2 = e12.match(/(.+)\(([0-9]+)\)(.*)$/)) != null ? _a2 : [];
    e12 = i + t.repeat(Math.ceil(16 / t.length)) + (r != null ? r : "");
  }
  return parseFloat(e12);
}
function D(e12) {
  return typeof e12 == "number" ? e12 : typeof e12 == "string" ? Dp(e12) : e12 !== void 0 && Fi(e12) ? D(e12.num) : null;
}
function qi(e12) {
  var _a2, _b;
  if (e12 == null) return null;
  if (A(e12) === "Half") return [1, 2];
  let n = h(e12);
  if (!n) return null;
  let i = null, t = null;
  if (n === "Negate") {
    let r = qi(N(e12)[0]);
    if (r) return [-r[0], r[1]];
  }
  if (n === "Rational" || n === "Divide") {
    let [r, s] = N(e12);
    i = (_a2 = D(r)) != null ? _a2 : NaN, t = (_b = D(s)) != null ? _b : NaN;
  }
  if (n === "Power") {
    let [r, s] = N(e12), o = D(s);
    o === 1 ? (i = D(r), t = 1) : o === -1 && (i = 1, t = D(r));
  }
  if (n === "Multiply") {
    let [r, s] = N(e12);
    if (h(s) === "Power") {
      let [o, a] = N(s);
      D(a) === -1 && (i = D(r), t = D(o));
    }
  }
  return i === null || t === null ? null : Number.isInteger(i) && Number.isInteger(t) ? [i, t] : null;
}
function Br(e12, n) {
  let i = A(e12);
  if (i && n[i]) return n[i];
  let t = h(e12);
  return t ? [Br(t, n), ...N(e12).map((r) => Br(r, n))] : e12;
}
function Dr(e12, n) {
  let i = null;
  if (Array.isArray(e12) && (i = e12), kt(e12) && (i = e12.fn), i === null) return [];
  let t = 1, r = [];
  for (; t < i.length; ) r.push(n(i[t])), t += 1;
  return r;
}
function $i(e12, n, i) {
  let t = h(n), r = h(i);
  return t === e12 && r === e12 ? [e12, ...N(n), ...N(i)] : t === e12 ? [e12, ...N(n), i] : r === e12 ? [e12, n, ...N(i)] : [e12, n, i];
}
function wn(e12) {
  if (e12 == null) return null;
  let n = h(e12);
  if (n === "Delimiter") {
    if (e12 = d(e12, 1), e12 === null) return [];
    if (n = h(e12), n !== "Sequence") return [e12];
  }
  return n !== "Sequence" ? null : N(e12);
}
function U(e12) {
  return e12 == null || e12 === "Nothing" ? true : h(e12) === "Sequence" && Y(e12) === 0;
}
function F(e12) {
  return U(e12) ? Li : e12;
}
function qs(e12) {
  return e12[0] === "Square" ? qs(e12.slice(1)) + 2 : e12.reduce((n, i) => n + wt(i), 0);
}
function wt(e12) {
  if (e12 === null) return 0;
  if (typeof e12 == "number" || typeof e12 == "string" || kn(e12) || kr(e12) || wp(e12)) return 1;
  if (Array.isArray(e12)) return qs(e12);
  if ("fn" in e12) return qs(e12.fn);
  let n = zs(e12);
  if (n) {
    let i = Object.keys(n);
    return 1 + i.length + i.reduce((t, r) => t + wt(n[r]), 0);
  }
  return 0;
}
function Ap(e12) {
  if (e12 === "N") return [0, ""];
  let n = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1e3 }, i = 0, t = 0;
  e12 = e12.toUpperCase();
  for (let r = e12.length - 1; r >= 0; r--) {
    let s = n[e12[r]];
    if (s === void 0) return [i, e12.slice(r)];
    s < t ? i -= s : i += s, t = s;
  }
  return [i, ""];
}
function Vi(e12, n) {
  if (e12 = e12.trim(), e12.length === 0) return [NaN, ""];
  if (e12.startsWith("+")) return Vi(e12.slice(1), n);
  if (e12.startsWith("-")) {
    let [r, s] = Vi(e12.slice(1), n);
    return [-r, s];
  }
  let i = 10;
  if (typeof n == "string" && (n = n.toLowerCase()), e12.startsWith("0x")) i = 16, e12 = e12.slice(2);
  else if (e12.startsWith("0b")) i = 2, e12 = e12.slice(2);
  else {
    if (n === "roman") return Ap(e12);
    if (n === "base64" || n === "base-64") try {
      return [parseInt(btoa(e12)), ""];
    } catch (e13) {
      return [NaN, ""];
    }
    else typeof n == "number" ? i = n : typeof n == "string" && (i = parseInt(n));
  }
  let t = 0;
  for (let r = 0; r < e12.length; r++) {
    let s = { " ": -1, "\xA0": -1, "\u2000": -1, "\u2001": -1, "\u2002": -1, "\u2003": -1, "\u2004": -1, "\u2005": -1, "\u2006": -1, "\u2007": -1, "\u2008": -1, "\u2009": -1, "\u200A": -1, "\u200B": -1, "\u202F": -1, "\u205F": -1, _: -1, ",": -1, 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15, g: 16, h: 17, i: 18, j: 19, k: 20, l: 21, m: 22, n: 23, o: 24, p: 25, q: 26, r: 27, s: 28, t: 29, u: 30, v: 31, w: 32, x: 33, y: 34, z: 35 }[e12[r]];
    if (s !== -1) {
      if (s === void 0) return [t, e12.substring(r)];
      if (s >= i) return [t, e12.substring(r)];
      t = t * i + s;
    }
  }
  return [t, ""];
}
function ge(e12, n) {
  if (typeof n == "number" && typeof e12 == "number") return e12.toFixed(n);
  let i = e12.toString();
  if (typeof e12 == "number" && Number.isInteger(e12) && i.includes("e")) {
    let t = BigInt(e12).toString(), r = t.match(/0+$/);
    if ((r ? r[0].length : 0) <= 5) return t;
  } else if (typeof e12 == "bigint") {
    let t = i.match(/0+$/), r = t ? t[0].length : 0;
    if (r > 5) return `${i.slice(0, -r)}e+${r}`;
  }
  return i;
}
function uu(e12) {
  if (typeof e12 == "number") return Number.isInteger(e12) ? BigInt(e12) : null;
  if (e12 == null || !kn(e12)) return null;
  let n = Fi(e12) ? e12.num : e12;
  if (typeof n == "number") return Number.isInteger(n) ? BigInt(n) : null;
  if (typeof n != "string") return null;
  let i = n.toLowerCase().replace(/[nd]$/, "").replace(/[\u0009-\u000d\u0020\u00a0]/g, "");
  return i === "nan" || i === "infinity" || i === "+infinity" || i === "-infinity" ? null : K(i);
}
function Ie(e12, n) {
  if (typeof e12 == "number") return isNaN(e12) ? "NaN" : Number.isFinite(e12) ? typeof n == "number" ? { num: e12.toFixed(n) } : e12 : e12 < 0 ? "NegativeInfinity" : "PositiveInfinity";
  if (e12 >= Number.MIN_SAFE_INTEGER && e12 <= Number.MAX_SAFE_INTEGER) return Number(e12);
  let i = ge(e12);
  return Number(e12).toString() === i ? Number(e12) : { num: i };
}
var Z = class e2 extends z {
  constructor(i, t, r) {
    var _a2;
    super();
    this.im = 0;
    if (this.factory = t, this.bignum = r, typeof i == "number") {
      !Number.isFinite(i) || Number.isInteger(i), this.rational = [i, 1], this.radical = 1;
      return;
    }
    if (typeof i == "bigint") {
      this.rational = [i, BigInt(1)], this.radical = 1;
      return;
    }
    typeof i != "object" || "im" in i;
    let s = 1;
    if (typeof s != "number" || Number.isInteger(s), s == 0) {
      this.rational = [0, 1], this.radical = 1;
      return;
    }
    let o = i.rational ? [...i.rational] : [1, 1];
    s != 1 && (typeof s == "bigint" ? o = hn(o, [s, BigInt(1)]) : o = hn(o, [s, 1])), this.rational = o, this.radical = (_a2 = i.radical) != null ? _a2 : 1, this.radical <= O && this.radical >= 1, this.normalize();
  }
  get type() {
    return this.isNaN ? "number" : this.isPositiveInfinity || this.isNegativeInfinity ? "non_finite_number" : this.radical !== 1 ? (mn(this.rational), "finite_real") : oi(this.rational) ? "finite_integer" : "finite_rational";
  }
  get isExact() {
    return true;
  }
  get asExact() {
    return this;
  }
  toJSON() {
    if (this.isNaN) return "NaN";
    if (this.isPositiveInfinity) return "PositiveInfinity";
    if (this.isNegativeInfinity) return "NegativeInfinity";
    if (this.isZero) return 0;
    if (this.isOne) return 1;
    if (this.isNegativeOne) return -1;
    let i = (t) => oi(t) ? Ie(t[0]) : ["Rational", Ie(t[0]), Ie(t[1])];
    return this.radical === 1 ? i(this.rational) : ve(this.rational) ? ["Sqrt", this.radical] : Bt(this.rational) ? ["Negate", ["Sqrt", this.radical]] : this.rational[0] == 1 ? ["Divide", ["Sqrt", this.radical], Ie(this.rational[1])] : this.rational[0] == -1 ? ["Negate", ["Divide", ["Sqrt", this.radical], Ie(this.rational[1])]] : ["Multiply", i(this.rational), ["Sqrt", this.radical]];
  }
  clone(i) {
    return new e2(i, this.factory, this.bignum);
  }
  toString() {
    if (this.isZero) return "0";
    if (this.isOne) return "1";
    if (this.isNegativeOne) return "-1";
    let i = (r) => oi(r) ? ge(r[0]) : `${ge(r[0])}/${ge(r[1])}`;
    if (this.radical === 1) return i(this.rational);
    let t = (r) => `sqrt(${ge(r)})`;
    return ve(this.rational) ? t(this.radical) : Bt(this.rational) ? `-${t(this.radical)}` : this.rational[0] == 1 ? `${t(this.radical)}/${ge(this.rational[1])}` : this.rational[0] == -1 ? `-${t(this.radical)}/${ge(this.rational[1])}` : `${i(this.rational)}${t(this.radical)}`;
  }
  get sign() {
    return mn(this.rational) ? 0 : Ps(this.rational) ? 1 : -1;
  }
  get re() {
    return tu(this.rational) * Math.sqrt(this.radical);
  }
  get bignumRe() {
    let i, t = this.rational;
    return te(t) ? i = this.bignum(t[0]).div(t[1]) : i = this.bignum(t[0].toString()).div(this.bignum(t[1].toString())), this.radical === 1 ? i : i.mul(this.bignum(this.radical).sqrt());
  }
  get numerator() {
    return this.rational[1] == 1 ? this : this.clone({ rational: te(this.rational) ? [this.rational[0], 1] : [this.rational[0], BigInt(1)], radical: this.radical });
  }
  get denominator() {
    return te(this.rational) ? this.clone(this.rational[1]) : this.clone({ rational: [this.rational[1], BigInt(1)] });
  }
  normalize() {
    if (Number.isInteger(this.radical) && this.radical > 0 && Number.isFinite(this.radical), isNaN(this.radical)) {
      this.rational = [NaN, 1], this.radical = 1;
      return;
    }
    let [i, t] = this.rational;
    if (t == 0) {
      this.rational = [NaN, 1], this.radical = 1;
      return;
    }
    if (this.radical === 0 || i === 0) {
      this.rational = [0, 1], this.radical = 1;
      return;
    }
    if (this.radical >= 4) {
      let [r, s] = Bi(this.radical, 2);
      typeof this.rational[0] == "number" ? this.rational[0] *= r : this.rational = hn(this.rational, [r, 1]), this.radical = s;
    }
    this.rational = Pi(this.rational);
  }
  get isNaN() {
    return Number.isNaN(this.rational[0]);
  }
  get isPositiveInfinity() {
    return this.rational[0] == 1 / 0;
  }
  get isNegativeInfinity() {
    return this.rational[0] == -1 / 0;
  }
  get isComplexInfinity() {
    return false;
  }
  get isZero() {
    return mn(this.rational);
  }
  get isOne() {
    return !(this.rational[0] !== this.rational[1] || this.radical !== 1);
  }
  get isNegativeOne() {
    return !(this.rational[0] !== -this.rational[1] || this.radical !== 1);
  }
  sgn() {
    if (!Number.isNaN(this.rational[0])) return mn(this.rational) ? 0 : Ps(this.rational) ? 1 : -1;
  }
  N() {
    return this.isZero || this.isOne || this.isNegativeOne ? this : this.rational[1] == 1 && this.radical === 1 ? this : this.factory(this.bignumRe);
  }
  neg() {
    return this.isZero ? this : this.clone({ rational: ui(this.rational), radical: this.radical });
  }
  inv() {
    return this.isOne ? this : this.isNegativeOne ? this : this.clone({ rational: te(this.rational) ? [this.rational[1], this.rational[0] * this.radical] : [this.rational[1], this.rational[0] * BigInt(this.radical)], radical: this.radical });
  }
  add(i) {
    return typeof i == "number" ? i === 0 ? this : Number.isInteger(i) && this.radical === 1 ? this.clone({ rational: te(this.rational) ? [this.rational[0] + i * this.rational[1], this.rational[1]] : [this.rational[0] + BigInt(i) * this.rational[1], this.rational[1]] }) : this.factory(this.bignumRe).add(i) : i.isZero ? this : this.isZero ? i : i instanceof e2 ? this.radical === i.radical ? this.clone({ rational: ai(this.rational, i.rational), radical: this.radical }) : this.factory(this.bignumRe).add(i) : i.add(this);
  }
  sub(i) {
    return this.add(i.neg());
  }
  mul(i) {
    return i === 0 ? this.clone(0) : i === 1 ? this : i === -1 ? this.neg() : typeof i == "number" ? Number.isInteger(i) ? this.clone({ rational: te(this.rational) ? [this.rational[0] * i, this.rational[1]] : [this.rational[0] * BigInt(i), this.rational[1]], radical: this.radical }) : this.factory(this.bignumRe).mul(i) : i instanceof M ? this.factory(i).mul(this) : i.im !== 0 ? i.mul(this) : i.isZero ? i : i.isOne ? this : i.isNegativeOne ? this.neg() : i.isNaN ? i : this.isZero ? this : this.isOne ? i : this.isNegativeOne ? i.neg() : i instanceof e2 ? this.clone({ rational: hn(this.rational, i.rational), radical: this.radical * i.radical }) : i.mul(this);
  }
  div(i) {
    if (typeof i == "number") return i === 1 ? this : i === -1 ? this.neg() : i === 0 ? this.clone(NaN) : this.clone({ rational: te(this.rational) ? [this.rational[0], this.rational[1] * i] : [this.rational[0], this.rational[1] * BigInt(i)], radical: this.radical });
    if (i.isOne) return this;
    if (i.isNegativeOne) return this.neg();
    if (this.isZero) return i.isZero ? this.clone(NaN) : i.isNaN ? i : this;
    if (i.isNaN) return i;
    if (i.isZero) return this.clone(this.sign * (1 / 0));
    if (!(i instanceof e2)) return this.factory(this.bignumRe).div(i);
    if (i.im !== 0) return this.factory(this.bignumRe).div(i);
    let t;
    if (te(this.rational) && te(i.rational)) {
      let [r, s] = this.rational, [o, a] = i.rational;
      t = [r * a, s * o * i.radical];
    } else t = hn(this.rational, [BigInt(i.rational[1]), BigInt(i.rational[0]) * BigInt(i.radical)]);
    return this.clone({ rational: t, radical: this.radical * i.radical });
  }
  pow(i) {
    if (Array.isArray(i), this.isNaN) return this;
    if (typeof i == "number" && isNaN(i)) return this.clone(NaN);
    if (i instanceof z) {
      if (i.isNaN) return this.clone(NaN);
      if (i.isZero) return this.clone(1);
      if (i.isOne) return this;
      if (i.im) i = { re: i.re, im: i.im };
      else {
        if (i instanceof e2 && i.radical === 1 && i.rational[0] == 1) return this.root(i.rational[0]);
        i = i.re;
      }
    }
    if (i === 0.5) return this.sqrt();
    if (typeof i == "object" && ("re" in i || "im" in i)) return this.factory(this.bignumRe).pow(i);
    if (this.isPositiveInfinity) {
      if (i === -1) return this.clone(0);
      if (i === 1 / 0) return this.clone(1 / 0);
      if (i === -1 / 0) return this.clone(0);
    } else if (this.isNegativeInfinity && i === 1 / 0) return this.clone(NaN);
    if ((i === 1 / 0 || i === -1 / 0) && (this.isOne || this.isNegativeOne)) return this.clone(NaN);
    if (i === 1) return this;
    if (i === -1) return this.inv();
    if (i === 0) return this.clone(1);
    if (this.isZero) {
      if (i > 0) return this;
      if (i < 0) return this.factory({ im: 1 / 0 });
    }
    if (i < 0) return this.pow(-i).inv();
    if (i % 1 === 0.5) return this.pow(Math.floor(i)).mul(this.sqrt());
    if (this.radical > O || this.rational[0] > O || this.rational[0] < -O || this.rational[1] > O) return this.factory(this.bignumRe).pow(i);
    if (this.sign < 0) {
      if (Number.isInteger(i)) {
        let t = i % 2 === 0 ? 1 : -1;
        return this.clone({ rational: te(this.rational) ? [t * (-this.rational[0]) ** i, this.rational[1] ** i] : [BigInt(t) * (-this.rational[0]) ** BigInt(i), this.rational[1] ** BigInt(i)], radical: this.radical ** i });
      }
      return this.factory({ im: (-this.re) ** i });
    } else if (Number.isInteger(i)) return this.clone({ rational: te(this.rational) ? [this.rational[0] ** i, this.rational[1] ** i] : [BigInt(this.rational[0]) ** BigInt(i), this.rational[1] ** BigInt(i)], radical: this.radical ** i });
    return this.factory(this.bignumRe).pow(i);
  }
  root(i) {
    if (i === 0) return this.clone(NaN);
    if (this.isNaN) return this;
    if (this.isZero) return this;
    if (i === 1) return this;
    if (i === -1) return this.inv();
    if (i < 0) return this.root(-i).inv();
    if (i % 1 === 0.5) return this.root(Math.floor(i)).sqrt();
    if (this.radical === 1) {
      if (this.sign > 0) {
        let t = this.re;
        if (Number.isInteger(t)) {
          if (t > 0) {
            let r = Math.pow(t, 1 / i);
            if (Number.isInteger(r)) return this.clone(r);
          }
          return this.factory(this.bignumRe).root(i);
        }
      }
      return this.factory(this.bignumRe).root(i);
    }
    if (this.sign < 0) return this.factory({ im: Math.pow(-this.re, 1 / i) });
    if (this.radical > O || this.rational[0] > O || this.rational[0] < -O || this.rational[1] > O) return this.factory(this.bignumRe).root(i);
    if (this.rational[1] == 1) {
      let t = Math.pow(this.rational[0], 1 / i);
      if (Number.isInteger(t)) return this.clone(t);
    }
    return this.factory(this.bignumRe).root(i);
  }
  sqrt() {
    if (this.isZero || this.isOne) return this;
    if (this.radical === 1) if (te(this.rational)) {
      let [i, t] = this.rational;
      return i * t > O ? this.factory(this.bignumRe).sqrt() : i > 0 ? this.clone({ radical: i * t, rational: [1, t] }) : this.factory({ im: Math.sqrt(-i * t) / t });
    } else return this.factory(this.bignumRe).sqrt();
    if (this.sign > 0) {
      let i = Math.sqrt(this.re);
      if (Number.isInteger(i)) return this.clone(i);
    }
    return this.factory(this.bignumRe).sqrt();
  }
  gcd(i) {
    if (!(i instanceof e2)) return i.gcd(this);
    if (this.isOne || i.im !== 0 || i.isOne) return this.clone(1);
    let t = Ir(this.rational, i.rational), r = rn(this.radical, i.radical);
    return this.clone({ rational: t, radical: r });
  }
  abs() {
    return this.sign === -1 ? this.neg() : this;
  }
  ln(i) {
    return this.isZero ? this.clone(NaN) : this.isPositiveInfinity ? this.clone(1 / 0) : this.sign < 0 ? this.clone(NaN) : this.isOne ? this.clone(0) : this.isNegativeOne ? this.factory({ im: Math.PI }) : this.factory(this.bignumRe).ln(i);
  }
  exp() {
    return this.isNaN ? this.clone(NaN) : this.isZero ? this.clone(1) : this.isNegativeInfinity ? this.clone(0) : this.isPositiveInfinity ? this.clone(1 / 0) : this.factory(this.bignumRe).exp();
  }
  floor() {
    return this.isNaN ? this.clone(NaN) : this.type === "integer" ? this : this.clone(Math.floor(this.re));
  }
  ceil() {
    return this.isNaN ? this.clone(NaN) : this.type === "integer" ? this : this.clone(Math.ceil(this.re));
  }
  round() {
    return this.isNaN ? this.clone(NaN) : this.type === "integer" ? this : this.clone(Math.round(this.re));
  }
  eq(i) {
    return typeof i == "number" ? this.radical === 1 && oi(this.rational) && this.rational[0] == i : i instanceof e2 ? this.radical === i.radical && this.rational[0] == i.rational[0] && this.rational[1] == i.rational[1] : i.im === 0 && i.re === this.re;
  }
  lt(i) {
    return this.im, typeof i == "number" ? this.re < i : this.re < i.re;
  }
  lte(i) {
    return this.im, typeof i == "number" ? this.re <= i : this.re <= i.re;
  }
  gt(i) {
    return this.im, typeof i == "number" ? this.re > i : this.re > i.re;
  }
  gte(i) {
    return this.im, typeof i == "number" ? this.re >= i : this.re >= i.re;
  }
  static sum(i, t, r) {
    if (i.length === 1) return i;
    if (i.some((l) => !l.isExact)) {
      if (i.length === 2) return [i[0].add(i[1])];
      let l = t(0);
      for (let f of i) l = l.add(f);
      return [l];
    }
    let s = 0, o = [0, 1], a = [];
    for (let l of i) {
      if (l.isNaN) return [new e2(NaN, t, r)];
      if (!l.isZero) if (s += l.im, l instanceof e2) {
        let f = l.rational;
        if (l.radical === 1) o = ai(o, f);
        else {
          let c = a.findIndex((p) => p.radical === l.radical);
          c === -1 ? a.push({ multiple: f, radical: l.radical }) : a[c].multiple = ai(a[c].multiple, f);
        }
      } else v(l.type, "integer"), o = ai(o, [l.re, 1]);
    }
    if (mn(o) && a.length === 0) return s === 0 ? [new e2(0, t, r)] : [t({ im: s })];
    let u = [];
    return s !== 0 && u.push(t({ im: s })), a.length === 0 ? u.push(new e2({ rational: o }, t, r)) : (a.push({ multiple: o, radical: 1 }), u.push(...a.map((l) => new e2({ rational: l.multiple, radical: l.radical }, t, r)))), u;
  }
};
function je(e12) {
  let n = e12.numericValue;
  if (n === null || typeof n == "number" && !Number.isFinite(n) || n instanceof z && (n.isNaN || n.isPositiveInfinity || n.isNegativeInfinity)) return;
  if (typeof n == "number") return Number.isInteger(n) ? [n, 1] : void 0;
  let i = n.type;
  if (i !== "finite_integer" && i !== "finite_rational" || n.im !== 0) return;
  if (n instanceof Z) return n.radical !== 1 ? void 0 : n.rational;
  let t = n.bignumRe;
  if (t !== void 0 && Number.isInteger(t)) return [K(t), BigInt(1)];
  let r = n.re;
  if (Number.isInteger(r)) return [r, 1];
}
function Dt(e12) {
  if (e12 == null) return null;
  let n = e12.numericValue;
  if (n === null) return null;
  if (typeof n == "number") return Number.isInteger(n) ? BigInt(n) : null;
  if (n.im !== 0) return null;
  let i = n.bignumRe;
  return (i == null ? void 0 : i.isInteger()) ? K(i) : Number.isInteger(n.re) ? BigInt(n.re) : null;
}
function Gs(e12) {
  var _a2;
  if (e12 == null) return null;
  let n = typeof e12 == "number" ? e12 : e12.numericValue;
  if (n === null) return null;
  if (typeof n == "number") return e12.engine.bignum(n);
  if (n.im !== 0) return null;
  let i = (_a2 = n.bignumRe) != null ? _a2 : n.re;
  return typeof i == "number" && isNaN(i) ? null : e12.engine.bignum(i);
}
function G(e12) {
  if (e12 == null) return null;
  if (typeof e12 == "number") return Number.isInteger(e12) && e12 >= -O && e12 <= O ? e12 : null;
  let n = e12.numericValue;
  if (n === null) return null;
  if (typeof n == "number") return Number.isInteger(n) && n >= -O && n <= O ? n : null;
  if (n.im !== 0) return null;
  let i = n.re;
  return Number.isInteger(i) && i >= -O && i <= O ? Number(i) : null;
}
function De(e12) {
  if (e12.symbol && !e12.isConstant) return 1;
  if (e12.operator === "Power" && e12.op2.isNumberLiteral) {
    if (De(e12.op1) === 0) return 0;
    let n = G(e12.op2);
    return n !== null && n > 0 ? n : 0;
  }
  if (e12.operator === "Multiply") {
    let n = 0;
    for (let i of e12.ops) {
      let t = De(i);
      n = n + t;
    }
    return n;
  }
  if (e12.operator === "Add" || e12.operator === "Subtract") {
    let n = 0;
    for (let i of e12.ops) n = Math.max(n, De(i));
    return n;
  }
  return e12.operator === "Negate" || e12.operator === "Divide" ? De(e12.op1) : 0;
}
function Ze(e12) {
  if (e12.symbol && !e12.isConstant) return 1;
  if (e12.operator === "Power" && e12.op2.isNumberLiteral) {
    if (Ze(e12.op1) === 0) return 0;
    let n = G(e12.op2);
    return n !== null && n > 0 ? n : 0;
  }
  if (e12.operator === "Multiply" || e12.operator === "Add" || e12.operator === "Subtract") {
    let n = 0;
    for (let i of e12.ops) n = Math.max(n, De(i));
    return n;
  }
  return e12.operator === "Negate" || e12.operator === "Divide" ? Ze(e12.op1) : 0;
}
function lu(e12) {
  return e12.symbol && !e12.isConstant ? e12.symbol : e12.ops ? e12.ops.map((n) => lu(n)).join(" ").trim() : "";
}
function Us(e12) {
  return lu(e12).split(" ").reverse().join(" ").trim();
}
function Q(e12, n, i, t) {
  var _a2;
  if (((_a2 = e12 == null ? void 0 : e12.numericValue) != null ? _a2 : null) === null) return;
  let r = e12.engine, s;
  if (e12.im !== 0) s = t == null ? void 0 : t(r.complex(e12.re, e12.im));
  else {
    let o = e12.bignumRe;
    if (o !== void 0 && oe(r) && i) s = i(o);
    else {
      let a = e12.re;
      oe(r) && i ? s = i(r.bignum(a)) : s = n(a);
    }
  }
  if (s !== void 0) return s instanceof $ ? r.number(r._numericValue({ re: s.re, im: s.im })) : r.number(s);
}
function gn(e12, n, i, t, r) {
  var _a2, _b;
  if (e12.numericValue === null || n.numericValue === null) return;
  let s = e12.engine, o;
  if ((e12.im !== 0 || n.im !== 0) && (o = r == null ? void 0 : r(s.complex(e12.re, e12.im), s.complex(n.re, n.im))), o === void 0 && t) {
    let a = e12.bignumRe, u = n.bignumRe;
    (a !== void 0 || u !== void 0) && (a != null ? a : a = s.bignum(e12.re), u != null ? u : u = s.bignum(n.re), o = t(a, u));
  }
  if (o === void 0) {
    let a = e12.re, u = n.re;
    !isNaN(a) && !isNaN(u) && (oe(s) && t ? o = t(s.bignum((_a2 = e12.bignumRe) != null ? _a2 : a), s.bignum((_b = n.bignumRe) != null ? _b : u)) : o = i(a, u));
  }
  if (o !== void 0) return o instanceof $ ? s.number(s._numericValue({ re: s.chop(o.re), im: s.chop(o.im) })) : s.number(s.chop(o));
}
function fu(e12) {
  return e12.operator === "Sqrt" || e12.operator === "Power" && e12.op2.im === 0 && e12.op2.re === 0.5 || e12.operator === "Root" && e12.op2.im === 0 && e12.op2.re === 2;
}
function Ar(e12) {
  var _a2;
  if (fu(e12)) return (_a2 = je(e12.op1)) != null ? _a2 : null;
  if (e12.operator === "Divide" && e12.op1.is(1) && fu(e12.op2)) {
    let n = e12.op2.re;
    return Number.isInteger(n) ? [1, n] : null;
  }
  return null;
}
function zi(e12, n) {
  let i = e12.engine;
  if (e12 = e12.canonical, n = n.canonical, e12.is(0)) {
    if (n.is(0)) return i.NaN;
    if (n.isPositive) return i.Zero;
    if (n.isNegative) return i.ComplexInfinity;
  }
  if (e12.is(1) || n.is(0)) return i.One;
  if (n.is(1)) return e12;
  if (n.is(0.5)) return li(e12, 2);
  let t = je(n);
  return t !== void 0 && t[0] === 1 ? li(e12, i.number(t[1])) : i._fn("Power", [e12, n]);
}
function li(e12, n) {
  e12 = e12.canonical;
  let i = e12.engine, t;
  if (typeof n == "number" ? t = n : (n = n.canonical, n.isNumberLiteral && n.im === 0 && (t = n.re)), t === 1) return e12;
  if (t === 2) {
    if (e12.isNumberLiteral && e12.type.matches("rational") && e12.re < O) {
      let r = e12.sqrt();
      if (typeof r.numericValue == "number" || r.numericValue.isExact) return r;
    }
    return i._fn("Sqrt", [e12]);
  }
  return i._fn("Root", [e12, typeof n == "number" ? i.number(n) : n]);
}
function me(e12, n, { numericApproximation: i }) {
  var _a2, _b, _c2;
  if (!e12.isCanonical) return e12.canonical.pow(n);
  if (i && e12.isNumberLiteral) {
    if (typeof n == "number") return (_a2 = Q(e12, (s) => Math.pow(s, n), (s) => s.pow(n), (s) => s.pow(n))) != null ? _a2 : me(e12, n, { numericApproximation: false });
    if (n.isNumberLiteral) return (_b = gn(e12, n, (s, o) => Math.pow(s, o), (s, o) => s.pow(o), (s, o) => s.pow(o))) != null ? _b : me(e12, n, { numericApproximation: false });
  }
  let t = e12.engine;
  typeof n != "number" && (n = n.canonical);
  let r = typeof n == "number" ? n : n.im === 0 ? n.re : void 0;
  if (r === 0) return t.One;
  if (r === 1) return e12;
  if (r === -1) return e12.isInfinity && e12.isNegative ? t.Zero : e12.is(-1) ? t.NegativeOne : e12.is(0) ? t.ComplexInfinity : e12.is(1) ? t.One : e12.isInfinity && e12.isPositive ? t.Zero : e12.inv();
  if (r === Number.POSITIVE_INFINITY) {
    if (e12.is(0)) return t.Zero;
    if (e12.is(1) || e12.is(-1)) return t.NaN;
    if (e12.isInfinity) {
      if (e12.isPositive) return t.PositiveInfinity;
      if (e12.isNegative) return t.NaN;
    }
  }
  if (r === Number.NEGATIVE_INFINITY) {
    if (e12.is(-1)) return t.NaN;
    if (e12.isInfinity) {
      if (e12.isPositive) return t.Zero;
      if (e12.isNegative) return t.NegativeInfinity;
    }
  }
  if (typeof n != "number") {
    if (n.isInfinity && !n.isPositive && !n.isNegative) return t.NaN;
    if (e12.isInfinity) {
      if (n.type.matches("imaginary")) return t.NaN;
      if (n.type.matches("complex") && !isNaN(n.re)) {
        if (n.re > 0) return t.ComplexInfinity;
        if (n.re < 0) return t.Zero;
      }
    }
  }
  if (r === Number.POSITIVE_INFINITY) {
    if (e12.isGreater(1)) return t.PositiveInfinity;
    if (e12.isPositive && e12.isLess(1)) return t.Zero;
  }
  if (r === Number.NEGATIVE_INFINITY) {
    if (e12.isGreater(1)) return t.Zero;
    if (e12.isPositive && e12.isLess(1)) return t.PositiveInfinity;
  }
  if (typeof n != "number" && n.operator === "Negate") return me(e12, n.op1, { numericApproximation: i }).inv();
  if (e12.symbol === "ComplexInfinity") return t.NaN;
  if (e12.symbol === "ExponentialE") {
    let s = wi(n);
    if (s !== void 0) {
      if (s = Tr(s), s !== void 0) return t.function("Cos", [s]).add(t.function("Sin", [s]).mul(t.I)).simplify();
    } else if (i) {
      if (typeof n == "number") return t.number(t._numericValue(t.E.N().numericValue).pow(n));
      if (n.isNumberLiteral) return t.number(t._numericValue(t.E.N().numericValue).pow(n.numericValue));
    }
  }
  if (e12.operator === "Power") {
    let [s, o] = e12.ops;
    return me(s, o.mul(n), { numericApproximation: i });
  }
  if (e12.operator === "Divide") {
    let [s, o] = e12.ops;
    return me(s, n, { numericApproximation: i }).div(me(o, n, { numericApproximation: i }));
  }
  if (e12.operator === "Negate" && r !== void 0) return r % 2 === 0 ? me(e12.op1, n, { numericApproximation: i }) : me(e12.op1, n, { numericApproximation: i }).neg();
  if (e12.operator === "Sqrt") return r === 2 ? e12.op1 : r !== void 0 && r % 2 === 0 ? e12.op1.pow(r / 2) : me(e12.op1, n, { numericApproximation: i }).sqrt();
  if (e12.operator === "Exp") return me(t.E, e12.op1.mul(n), { numericApproximation: i });
  if (e12.operator === "Multiply") {
    let s = e12.ops.map((o) => me(o, n, { numericApproximation: i }));
    return t._fn("Multiply", s);
  }
  if (typeof n != "number" && n.isNumberLiteral) {
    let s = je(n);
    if (s !== void 0 && s[0] === 1) return Rr(e12, t.number(s[1]), { numericApproximation: i });
  }
  if (e12.operator === "Root") {
    let [s, o] = e12.ops;
    return me(s, t.box(n).div(o), { numericApproximation: i });
  }
  if (e12.isNumberLiteral && Number.isInteger(r)) {
    let s = e12.numericValue;
    return typeof s == "number" ? (_c2 = Q(e12, (o) => Math.pow(o, r), (o) => o.pow(r), (o) => o.pow(r))) != null ? _c2 : t._fn("Power", [e12, t.box(n)]) : t.number(s.pow(r));
  }
  return t._fn("Power", [e12, t.box(n)]);
}
function Rr(e12, n, { numericApproximation: i }) {
  var _a2, _b, _c2;
  if (i && e12.isNumberLiteral && n.isNumberLiteral) {
    let t = e12.isNegative, r = n.isEven;
    return t && (e12 = e12.neg()), (_a2 = gn(e12, n, (s, o) => {
      let a = Math.pow(s, 1 / o);
      return t && !r ? -a : a;
    }, (s, o) => {
      let a = s.pow(o.pow(-1));
      return t && !r ? a.neg() : a;
    }, (s, o) => {
      let a = s.pow(typeof o == "number" ? 1 / o : o.inverse());
      return t && !r ? a.neg() : a;
    })) != null ? _a2 : Rr(e12, n, { numericApproximation: false });
  }
  if (e12.isNumberLiteral && n.isNumberLiteral && n.isInteger) {
    let t = typeof n == "number" ? n : n.im === 0 ? n.re : void 0;
    if (t !== void 0) if (typeof e12.numericValue == "number") {
      let r = (_b = e12.engine._numericValue(e12.numericValue)) == null ? void 0 : _b.root(t);
      if (r == null ? void 0 : r.isExact) return e12.engine.number(r);
    } else {
      let r = (_c2 = e12.numericValue.asExact) == null ? void 0 : _c2.root(t);
      if (r == null ? void 0 : r.isExact) return e12.engine.number(r);
    }
  }
  return e12.engine._fn("Root", [e12, n]);
}
var Un = 1e5;
var Rp = { Sin: true, Cos: true, Tan: true, Cot: true, Sec: true, Csc: true, Sinh: true, Cosh: true, Tanh: true, Coth: true, Sech: true, Csch: true, Arcsin: true, Arccos: true, Arctan: true, Arccot: true, Arcsec: true, Arccsc: true, Arcsinh: true, Arccosh: true, Arctanh: true, Arccoth: true, Arccsch: true, Arcsech: true };
function Mp(e12) {
  return !e12 || typeof e12 != "string" ? false : e12 in Rp;
}
function At(e12, n) {
  let i = De(e12), t = De(n);
  if (i !== t) return t - i;
  let r = Ze(e12), s = Ze(n);
  if (r !== s) return s - r;
  let o = Us(e12), a = Us(n);
  if (o || a) {
    if (!o) return 1;
    if (!a || o < a) return -1;
    if (o > a) return 1;
  }
  return fe(e12, n);
}
var cu = ["integer", "rational", "radical", "real", "complex", "constant", "symbol", "multiply", "divide", "add", "trig", "fn", "power", "string", "other"];
function pu(e12) {
  if (typeof e12.numericValue == "number") return Number.isInteger(e12.numericValue) ? "integer" : "real";
  if (e12.numericValue) {
    let n = e12.numericValue.type;
    return n === "integer" || n === "finite_integer" ? "integer" : n === "rational" || n === "finite_rational" ? "rational" : n === "real" || n === "finite_real" ? "real" : n === "complex" || n === "finite_complex" || n === "imaginary" || n === "finite_number" ? "complex" : n === "non_finite_number" ? "constant" : n === "number" ? "real" : "other";
  }
  return e12.symbol === "ImaginaryUnit" ? "complex" : Ar(e12) ? "radical" : e12.symbol && e12.isConstant ? "constant" : e12.symbol ? "symbol" : Mp(e12.operator) ? "trig" : e12.operator === "Add" ? "add" : e12.operator === "Power" || e12.operator === "Root" ? "power" : e12.operator === "Multiply" || e12.operator === "Negate" ? "multiply" : e12.operator === "Divide" ? "divide" : e12.operator === "Rational" ? "rational" : e12.operator === "Complex" ? e12.im !== 0 ? "complex" : "real" : e12.operator === "Sqrt" ? e12.op1.isNumberLiteral && (e12.op1.isInteger || e12.op1.isRational) ? "radical" : "power" : e12.ops ? "fn" : e12.string ? "string" : "other";
}
function fe(e12, n) {
  var _a2, _b, _c2, _d2, _e2, _f2;
  if (e12 === n) return 0;
  let i = pu(e12), t = pu(n);
  if (i !== t) return cu.indexOf(i) - cu.indexOf(t);
  if (i === "complex") {
    let [r, s] = du(e12), [o, a] = du(n);
    return s !== a ? s - a : r - o;
  }
  if (i === "integer" || i === "rational" || i === "real") {
    let r = e12.numericValue, s = n.numericValue;
    r === null && e12.operator === "Rational" && (r = e12.op1.re / e12.op2.re), s === null && n.operator === "Rational" && (s = n.op1.re / n.op2.re);
    let o = typeof r == "number" ? r : r.re, a = typeof s == "number" ? s : s.re;
    return o - a;
  }
  if (i === "radical") return fe(e12.op1, n.op1);
  if (i === "constant" || i === "symbol") return e12.symbol === n.symbol ? 0 : e12.symbol > n.symbol ? 1 : -1;
  if (i === "add") {
    let r = e12.ops, s = n.ops;
    if (r.length !== s.length) return s.length - r.length;
    for (let o = 0; o < r.length; o++) {
      let a = fe(r[o], s[o]);
      if (a !== 0) return a;
    }
    return 0;
  }
  if (i === "power") {
    let r = De(e12), s = De(n);
    if (r !== s) return s - r;
    let o = Ze(e12), a = Ze(n);
    return o !== a ? o - a : fe(e12.op1, n.op1);
  }
  if (i === "multiply") {
    let r = De(e12), s = De(n);
    if (r !== s) return s - r;
    let o = Ze(e12), a = Ze(n);
    if (o !== a) return o - a;
    let u = e12.ops, l = n.ops;
    if (u.length !== l.length) return l.length - u.length;
    for (let f = 0; f < u.length; f++) {
      let c = fe(u[f], l[f]);
      if (c !== 0) return c;
    }
    return 0;
  }
  if (i === "divide") {
    let r = De(e12.op1), s = De(n.op1);
    if (r !== s) return s - r;
    let o = Ze(e12.op1), a = Ze(n.op1);
    if (o !== a) return o - a;
    let u = fe(e12.op1, n.op1);
    return u !== 0 ? u : fe(e12.op2, n.op2);
  }
  if (i === "fn" || i === "trig") {
    if (e12.operator == n.operator && e12.nops === 1 && n.nops === 1) return fe(e12.op1, n.op1);
    let r = (_b = (_a2 = e12.functionDefinition) == null ? void 0 : _a2.complexity) != null ? _b : Un, s = (_d2 = (_c2 = n.functionDefinition) == null ? void 0 : _c2.complexity) != null ? _d2 : Un;
    return r === s ? e12.operator === n.operator ? js(e12) - js(n) : e12.operator < n.operator ? 1 : -1 : r - s;
  }
  return i === "string" ? e12.string === n.string ? 0 : n.string < e12.string ? -1 : 1 : ((_e2 = e12.complexity) != null ? _e2 : Un) - ((_f2 = n.complexity) != null ? _f2 : Un);
}
function Zs(e12, { recursive: n = false }) {
  if (e12.isCanonical || !e12.ops) return e12;
  let i = e12.ops;
  return n && (i = i.map((t) => Zs(t, { recursive: n }))), i = Rt(e12.operator, i), e12.engine._fn(e12.operator, i, { canonical: false });
}
function Rt(e12, n) {
  if (n.length === 0) return n;
  let i = n[0].engine;
  if (e12 === "Add") return [...n].sort(At);
  if (e12 === "Multiply") return [...n].sort(fe);
  let t = i.lookupFunction(e12);
  return !t || !t.commutative ? n : t.commutativeOrder ? [...n].sort(t.commutativeOrder) : [...n].sort(fe);
}
function js(e12) {
  return e12.ops ? 1 + [...e12.ops].reduce((n, i) => n + js(i), 0) : 1;
}
function du(e12) {
  if (e12.symbol === "ImaginaryUnit") return [0, 1];
  if (e12.numericValue) {
    if (typeof e12.numericValue == "number") return [e12.numericValue, 0];
    let n = e12.numericValue;
    return [n.re, n.im];
  }
  if (e12.operator === "Complex") {
    let n = e12.op1.numericValue;
    if (n === null) return [0, 0];
    let i = typeof n == "number" ? n : n.re, t = e12.op2.numericValue;
    if (t === null) return [0, 0];
    let r = typeof t == "number" ? t : t.re;
    return [i, r];
  }
  return [0, 0];
}
function Hs(e12, n) {
  for (e12.isInteger() && n.isInteger(); !n.isZero(); ) [e12, n] = [n, e12.modulo(n)];
  return e12.abs();
}
function mu(e12, n) {
  return e12.mul(n).div(Hs(e12, n));
}
function hu(e12, n) {
  if (!n.isInteger() || n.isNegative()) return e12._BIGNUM_NAN;
  if (n.lessThan(1)) return e12._BIGNUM_ONE;
  let i = n;
  for (; n.greaterThan(2); ) n = n.minus(2), i = i.mul(n);
  return i;
}
function fi(e12) {
  return e12.isFinite() ? e12.d.length > 3 || e12.d.length === 3 && e12.d[0] >= 90 ? false : (e12.precision() <= 16, e12.e < 308 && e12.e > -306) : true;
}
var gu = [0.9999999999998099, 676.5203681218851, -1259.1392167224028, 771.3234287776531, -176.6150291621406, 12.507343278686905, -0.13857109526572012, 9984369578019572e-21, 15056327351493116e-23];
function Mt(e12) {
  if (e12 < 0) return NaN;
  let n = Math.PI, i = e12 * e12 * e12;
  return e12 * Math.log(e12) - e12 - 0.5 * Math.log(e12) + 0.5 * Math.log(2 * n) + 1 / (12 * e12) - 1 / (360 * i) + 1 / (1260 * i * e12 * e12);
}
function ci(e12) {
  if (e12 < 0.5) return Math.PI / (Math.sin(Math.PI * e12) * ci(1 - e12));
  if (e12 > 100) return Math.exp(Mt(e12));
  e12 -= 1;
  let n = gu[0];
  for (let t = 1; t < 9; t++) n += gu[t] / (e12 + t);
  let i = e12 + 7 + 0.5;
  return Math.sqrt(2 * Math.PI) * Math.pow(i, e12 + 0.5) * Math.exp(-i) * n;
}
function xu(e12) {
  let n = Math.PI, i = n * n, t = i * n, r = e12 * e12, s = e12 * r, o = s * r, a = o * r;
  return Math.sqrt(n) / 2 * (e12 + n / 12 * s + 7 * i / 480 * o + 127 * t / 40320 * a + 4369 * i * i / 5806080 * a * r + 34807 * t * i / 182476800 * a * r * r);
}
function Ws(e12) {
  let n = 0.254829592, i = -0.284496736, t = 1.421413741, r = -1.453152027, s = 1.061405429, o = 0.3275911, a = e12 < 0 ? -1 : 1;
  e12 = Math.abs(e12);
  let u = 1 / (1 + o * e12), l = ((((s * u + r) * u + t) * u + i) * u + n) * u;
  return a * (1 - l * Math.exp(-e12 * e12));
}
function Js(e12, n) {
  if (n.isNegative()) return e12._BIGNUM_NAN;
  let i = e12.cache("gamma-p-ln", () => ["0.99999999999999709182", "57.156235665862923517", "-59.597960355475491248", "14.136097974741747174", "-0.49191381609762019978", "0.33994649984811888699e-4", "0.46523628927048575665e-4", "-0.98374475304879564677e-4", "0.15808870322491248884e-3", "-0.21026444172410488319e-3", "0.2174396181152126432e-3", "-0.16431810653676389022e-3", "0.84418223983852743293e-4", "-0.2619083840158140867e-4", "0.36899182659531622704e-5"].map((o) => e12.bignum(o))), t = i[0];
  for (let o = i.length - 1; o > 0; --o) t = t.add(i[o].div(n.add(o)));
  let r = e12.cache("gamma-g-ln", () => e12.bignum(607).div(128)), s = n.add(r).add(e12._BIGNUM_HALF);
  return e12._BIGNUM_NEGATIVE_ONE.acos().mul(e12._BIGNUM_TWO).log().mul(e12._BIGNUM_HALF).add(s.log().mul(n.add(e12._BIGNUM_HALF)).minus(s).add(t.log()).minus(n.log()));
}
function Ys(e12, n) {
  if (n.lessThan(e12._BIGNUM_HALF)) {
    let s = e12._BIGNUM_NEGATIVE_ONE.acos();
    return s.div(s.mul(n).sin().mul(Ys(e12, e12._BIGNUM_ONE.sub(n))));
  }
  if (n.greaterThan(100)) return Js(e12, n).exp();
  n = n.sub(1);
  let i = e12.cache("lanczos-7-c", () => ["0.99999999999980993227684700473478", "676.520368121885098567009190444019", "-1259.13921672240287047156078755283", "771.3234287776530788486528258894", "-176.61502916214059906584551354", "12.507343278686904814458936853", "-0.13857109526572011689554707", "9.984369578019570859563e-6", "1.50563273514931155834e-7"].map((s) => e12.bignum(s))), t = i[0];
  for (let s = 1; s < 9; s++) t = t.add(i[s].div(n.add(s)));
  let r = n.add(7).add(e12._BIGNUM_HALF);
  return e12._BIGNUM_NEGATIVE_ONE.acos().times(e12._BIGNUM_TWO).sqrt().mul(t.mul(r.neg().exp()).mul(r.pow(n.add(e12._BIGNUM_HALF))));
}
var Be = class e3 {
  constructor(n, i, t) {
    this.options = t;
    this.terms = [];
    this._isCanonical = true;
    if (t = t ? { ...t } : {}, "canonical" in t || (t.canonical = true), this._isCanonical = t.canonical, this.engine = n, this.coefficient = n._numericValue(1), i) for (let r of i) this.mul(r);
  }
  static from(n) {
    return new e3(n.engine, [n]);
  }
  mul(n, i) {
    if (n.isCanonical || n.isStructural, this.coefficient.isNaN) return;
    if (n.isNaN) {
      this.coefficient = this.engine._numericValue(NaN);
      return;
    }
    if (n.operator === "Multiply") {
      for (let s of n.ops) this.mul(s, i);
      return;
    }
    if (n.operator === "Negate") {
      this.mul(n.op1, i), this.coefficient = this.coefficient.neg();
      return;
    }
    if (this._isCanonical) {
      if (n.symbol === "Nothing") return;
      i != null ? i : i = [1, 1];
      let s = n.numericValue;
      if (s !== null) {
        if (n.is(1)) return;
        if (n.is(0)) {
          this.coefficient = this.engine._numericValue(mn(i) ? NaN : 0);
          return;
        }
        if (n.is(-1)) {
          ve(i) ? this.coefficient = this.coefficient.neg() : this.coefficient = this.coefficient.mul(this.engine._numericValue(-1).pow(this.engine._numericValue(i)));
          return;
        }
        if (n.isInfinity) {
          ve(i) ? this.coefficient = this.engine._numericValue(n.isNegative ? -1 / 0 : 1 / 0) : this.terms.push({ term: n, exponent: i });
          return;
        }
        ve(i) ? this.coefficient = this.coefficient.mul(s) : this.coefficient = this.coefficient.mul(this.engine._numericValue(s).pow(this.engine._numericValue(i)));
        return;
      }
      let o = Ar(n);
      if (o !== null) {
        this.coefficient = this.coefficient.mul(this.engine._numericValue({ radical: o[0] * o[1], rational: [1, Number(o[1])] }).pow(this.engine._numericValue(i)));
        return;
      }
      if (!n.symbol) {
        let a;
        [a, n] = n.toNumericValue(), i && !ve(i) && (a = a.pow(this.engine._numericValue(i))), this.coefficient = this.coefficient.mul(a);
      }
    }
    if (n.is(1) && (!i || ve(i)) || n.is(0) === false && i && mn(i)) return;
    if (n.is(0)) {
      i && mn(i) ? this.coefficient = this.engine._numericValue(NaN) : this.coefficient = this.engine._numericValue(0);
      return;
    }
    let t = i != null ? i : [1, 1];
    if (n.operator === "Power") {
      let s = je(n.op2);
      if (s) {
        this.mul(n.op1, hn(t, s));
        return;
      }
    }
    if (n.operator === "Sqrt") {
      this.mul(n.op1, hn(t, [1, 2]));
      return;
    }
    if (n.operator === "Root") {
      let s = je(n.op2);
      if (s) {
        this.mul(n.op1, hn(t, ru(s)));
        return;
      }
    }
    if (n.operator === "Divide") {
      this.mul(n.op1, t), this.mul(n.op2, ui(t));
      return;
    }
    let r = false;
    for (let s of this.terms) if (s.term.isSame(n)) {
      s.exponent = ai(s.exponent, t), r = true;
      break;
    }
    r || this.terms.push({ term: n, exponent: t });
  }
  div(n) {
    n instanceof z ? this.coefficient = this.coefficient.div(n) : this.mul(n, [-1, 1]);
  }
  groupedByDegrees(n) {
    n != null ? n : n = {}, "mode" in n || (n.mode = "expression");
    let i = n.mode;
    if (i === "numeric" && (this.coefficient.isNegativeInfinity || this.coefficient.isPositiveInfinity)) return [];
    if (this.coefficient.isZero) return [];
    let t = this.engine;
    if (this.terms.length === 0) if (i === "numeric") {
      let s = this.coefficient.N();
      return [{ exponent: [1, 1], terms: [t.number(s)] }];
    } else return [{ exponent: [1, 1], terms: [t.number(this.coefficient)] }];
    let r = [];
    if (!this.coefficient.isOne) if (i === "rational" && this.coefficient.type === "finite_rational") {
      let s = this.coefficient.numerator;
      s.isOne || r.push({ exponent: [1, 1], terms: [t.number(s)] });
      let o = this.coefficient.denominator;
      o.isOne || r.push({ exponent: [-1, 1], terms: [t.number(o)] });
    } else if (i === "numeric") {
      let s = this.coefficient.N();
      r.push({ exponent: [1, 1], terms: [t.number(s)] });
    } else r.push({ exponent: [1, 1], terms: [t.number(this.coefficient)] });
    for (let s of this.terms) {
      let o = Pi(s.exponent);
      if (o[0] === 0) continue;
      let a = false;
      for (let u of r) if (o[0] === u.exponent[0] && o[1] === u.exponent[1]) {
        u.terms.push(s.term), a = true;
        break;
      }
      a || r.push({ exponent: o, terms: [s.term] });
    }
    return r;
  }
  asExpression(n = { numericApproximation: false }) {
    let i = this.engine, t = this.coefficient;
    if (t.isNaN) return i.NaN;
    if (t.isPositiveInfinity) return i.PositiveInfinity;
    if (t.isNegativeInfinity) return i.NegativeInfinity;
    if (t.isZero) return i.Zero;
    let r = t.isNegativeOne;
    r && (this.coefficient = i._numericValue(1));
    let s = this.groupedByDegrees({ mode: n.numericApproximation ? "numeric" : "expression" });
    if (s === null) return i.NaN;
    if (r) {
      let o = Mr(i, s).neg();
      return this.coefficient = i._numericValue(-1), o;
    }
    return Mr(i, s);
  }
  asNumeratorDenominator() {
    let n = this.engine, i = this.coefficient;
    if (i.isZero) return [n.Zero, n.One];
    if (i.isPositiveInfinity || i.isNegativeInfinity) return this.terms.length === 0 ? [i.isPositiveInfinity ? n.PositiveInfinity : n.NegativeInfinity, n.One] : [n.NaN, n.NaN];
    let t = i.isNegativeOne;
    t && (this.coefficient = n._numericValue(1));
    let r = this.groupedByDegrees({ mode: "rational" });
    if (this.coefficient = i, r === null) return [n.NaN, n.NaN];
    let s = r.filter((u) => u.exponent[0] >= 0), o = r.filter((u) => u.exponent[0] < 0).map((u) => ({ exponent: ui(u.exponent), terms: u.terms })), a = Mr(n, s);
    return [t ? a.neg() : a, Mr(n, o)];
  }
  asRationalExpression() {
    let [n, i] = this.asNumeratorDenominator();
    return He(n, i);
  }
};
function yu(e12, n) {
  let i = e12.engine, t = e12.coefficient.gcd(n.coefficient);
  if (t.isOne) return [i._numericValue(1), i.One];
  let r = [];
  for (let s of e12.terms) {
    let o = n.terms.find((u) => s.term.isSame(u.term));
    if (!o) continue;
    let a = Ir(s.exponent, o.exponent);
    if (ve(a)) r.push(s.term);
    else {
      let [u, l] = su(a);
      l === 1 ? r.push(s.term.pow(u)) : u === 1 ? r.push(s.term.root(l)) : r.push(s.term.pow(u).root(l));
    }
  }
  return [t, r.length === 0 ? i.One : ae(...r)];
}
function Mr(e12, n) {
  let i = n.map(({ terms: t, exponent: r }) => {
    let s = J(t, "Multiply"), o = s.length <= 1 ? s[0] : e12._fn("Multiply", [...s].sort(fe));
    return ve(r) ? o : o.pow(e12.number(r));
  });
  return i = J(i, "Multiply"), i.length === 0 ? e12.One : i.length === 1 ? i[0] : e12._fn("Multiply", i.sort(fe));
}
var Qs;
function Nu(e12) {
  if (!Qs) {
    let i = `^[${["Zyyy", "Zinh", "Arab", "Armn", "Beng", "Bopo", "Cyrl", "Deva", "Ethi", "Geor", "Grek", "Gujr", "Guru", "Hang", "Hani", "Hebr", "Hira", "Kana", "Knda", "Khmr", "Laoo", "Latn", "Mlym", "Mymr", "Orya", "Sinh", "Taml", "Telu", "Thaa", "Thai", "Tibt"].map((t) => `\\p{Script=${t}}`).join("")}]*$`;
    Qs = new RegExp(i, "u");
  }
  return Qs.test(e12);
}
function xe(e12) {
  return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(e12) || Gi.test(e12) ? true : Nu(e12) ? /^[\p{XIDS}_]\p{XIDC}*$/u.test(e12) : false;
}
var Cp = "\\u{FE0F}";
var Pp = "\\u{20E3}";
var Op = "\\u{200D}";
var Lp = "\\p{RI}\\p{RI}";
var Fp = "(?:[\\u{E0020}-\\u{E007E}]+\\u{E007F})";
var bu = `(?:\\p{EMod}|${Cp}${Pp}?|${Fp})`;
var qp = "(?:(?=\\P{XIDC})\\p{Emoji})";
var Eu = `(?:${qp}${bu}*|\\p{Emoji}${bu}+|${Lp})`;
var vu = `(?:${Eu})(${Op}${Eu})*`;
var $p = new RegExp(`(?:${vu})+`, "u");
var Gi = new RegExp(`^(?:${vu})+$`, "u");
function We(e12) {
  return typeof e12 != "string" ? "not-a-string" : e12 === "" ? "empty-string" : e12.normalize() !== e12 ? "expected-nfc" : /[\u200E\u200F\u2066-\u2069\u202A-\u202E]/.test(e12) ? "unexpected-bidi-marker" : Gi.test(e12) ? "valid" : /\p{XIDC}/u.test(e12) && $p.test(e12) ? "unexpected-mixed-emoji" : Nu(e12) ? xe(e12) ? "valid" : xe(e12[0]) ? "invalid-char" : "invalid-first-char" : "unexpected-script";
}
var Tu = [{ name: "To", latexTrigger: ["\\to"], kind: "infix", precedence: 270 }, { latexTrigger: ["\\rightarrow"], kind: "infix", precedence: 270, parse: "To" }];
function Su(e12, n) {
  return "normal";
}
function _u(e12, n) {
  return "normal";
}
function Iu(e12, n) {
  return n > 2 ? "solidus" : "radical";
}
function Bu(e12, n) {
  if (n > 3) return "inline-solidus";
  if (h(e12) === "Divide") {
    let [i, t] = N(e12), [r, s] = [wt(i), wt(t)];
    if (s <= 2 && r > 5) return "factor";
    if (r <= 2 && s > 5) return "reciprocal";
  }
  return "quotient";
}
function ku(e12, n) {
  return "boolean";
}
function wu(e12, n) {
  return "solidus";
}
function Du(e12, n) {
  return "compact";
}
function Ui(e12, n, i) {
  e12.indexOf("#1") < 0 && e12.indexOf("#2") < 0 && (e12 = `#1 ${e12} #2`);
  let t = e12.split(/(#\d+)/).filter((r) => r.trim() !== "").map((r) => r.trim());
  return b(t.map((r) => {
    switch (r) {
      case "#1":
        return n;
      case "#2":
        return i;
      default:
        return r;
    }
  }));
}
function Vp(e12) {
  var _a2;
  if (h(e12) !== "Multiply") return [[], []];
  let n = [], i = [];
  for (let t of N(e12)) if (h(t) === "Power") {
    let r = d(t, 1), s = d(t, 2);
    if (h(s) === "Negate") {
      let o = d(s, 1);
      r && o && i.push(["Power", r, o]);
    } else {
      let o = (_a2 = D(s)) != null ? _a2 : NaN;
      o === -1 ? r && i.push(r) : o < 0 ? r && i.push(["Power", r, -o]) : n.push(t);
    }
  } else if (h(t) === "Rational" && Y(t) === 2 || h(t) === "Divide") {
    let r = d(t, 1), s = d(t, 2);
    D(r) !== 1 && n.push(r), D(s) !== 1 && i.push(s);
  } else {
    let r = qi(t);
    r !== null ? (r[0] !== 1 && n.push(r[0]), i.push(r[1])) : n.push(t);
  }
  return [n, i];
}
function zp(e12) {
  var _a2;
  let n = e12.parseOptionalGroup(), i = (_a2 = e12.parseGroup()) != null ? _a2 : e12.parseToken();
  return U(i) ? n !== null ? ["Root", Li, F(n)] : ["Sqrt", Li] : n !== null ? ["Root", i, n] : ["Sqrt", i];
}
function Ct(e12, n, i, t) {
  return i == null ? "\\sqrt{}" : (t = t != null ? t : 2, n === "solidus" ? e12.wrapShort(i) + "^{1/" + e12.serialize(t) + "}" : n === "quotient" ? e12.wrapShort(i) + "^{\\frac{1}{" + e12.serialize(t) + "}}" : D(t) === 2 ? "\\sqrt{" + e12.serialize(i) + "}" : "\\sqrt[" + e12.serialize(t) + "]{" + e12.serialize(i) + "}");
}
function Gp(e12, n) {
  e12.level -= 1;
  let i = h(n), t = "", r = d(n, 1);
  if (i === "Negate") t = "-" + e12.wrap(r, 276);
  else if (i === "Subtract") {
    t = e12.wrap(r, 275);
    let s = d(n, 2);
    if (s !== null) {
      let o = e12.wrap(s, 275);
      o[0] === "-" ? t += "+" + o.slice(1) : o[0] === "+" ? t += "-" + o.slice(1) : t = t + "-" + o;
    }
  } else if (i === "Add") {
    if (e12.options.prettify && Y(n) === 2 && e12.options.invisiblePlus !== "+") {
      let [a, u] = [d(n, 1), d(n, 2)], [l, f] = [a, u], c = D(l), p = qi(f);
      if ((c === null || p === null) && ([l, f] = [u, a], c = D(l), p = qi(f)), c !== null && p !== null && isFinite(c) && Number.isInteger(c) && c >= 0 && c <= 1e3 && isFinite(p[0]) && isFinite(p[1]) && p[0] > 0 && p[0] <= 100 && p[1] <= 100) return t = Ui(e12.options.invisiblePlus, e12.serialize(l), e12.serialize(f)), e12.level += 1, t;
    }
    if (e12.options.prettify && Y(n) === 2) {
      let [a, u] = Pt(r), [l, f] = Pt(d(n, 2));
      if (u < 0 && f > 0) return t = e12.wrap(l, 275) + "-" + e12.wrap(a, 275), e12.level += 1, t;
    }
    t = e12.serialize(r);
    let s = Y(n) + 1, o = N(n);
    for (let a = 2; a < s; a++) if (r = o[a - 1], e12.options.prettify) {
      let [u, l] = Pt(r), f = e12.wrap(u, 275);
      l > 0 ? f.startsWith("+") || f.startsWith("-") ? t += f : t += "+" + f : f.startsWith("+") ? t += "-" + f.slice(1) : f.startsWith("-") ? t += "+" + f.slice(1) : t += "-" + f;
    } else {
      let u = e12.wrap(r, 275);
      u[0] === "-" || u[0] === "+" ? t += u : t += "+" + u;
    }
  }
  return e12.level += 1, t;
}
function Lu(e12, n) {
  var _a2;
  if (n === null) return "";
  e12.level -= 1;
  let i = "";
  if (e12.options.prettify === true) {
    let [u, l] = Vp(n);
    l.length > 0 && (l.length === 1 && l[0] === 1 ? u.length === 0 ? i = "1" : u.length === 1 ? i = e12.serialize(u[0]) : i = Lu(e12, ["Multiply", ...u]) : i = e12.serialize(["Divide", u.length === 1 ? u[0] : ["Multiply", ...u], l.length === 1 ? l[0] : ["Multiply", ...l]]));
  }
  if (i) return e12.level += 1, i;
  let t = false, r = null, s = Y(n) + 1, o = N(n);
  e12.options.prettify === true && o.length === 2 && kn(o[1]) && !kn(o[0]) && (o = [o[1], o[0]]);
  let a = false;
  for (let u = 1; u < s; u++) {
    if (r = o[u - 1], r === null) continue;
    let l;
    if (kn(r)) {
      l = e12.serialize(r), l === "-1" && !i ? (i = "", t = !t) : (l[0] === "-" && (l = l.slice(1), t = !t), i ? i = Ui(e12.options.multiply, i, l) : i = l), a = true;
      continue;
    }
    if (h(r) === "Power") {
      let f = qi(d(r, 2));
      if (f != null) {
        let [c, p] = f;
        if (c === 1 && p !== null) {
          i += Ct(e12, e12.rootStyle(r, e12.level), d(r, 1), p), a = false;
          continue;
        }
      }
    }
    if (h(r) === "Power" && !isNaN((_a2 = D(d(r, 1))) != null ? _a2 : NaN)) {
      l = e12.serialize(r), i ? i = Ui(e12.options.multiply, i, l) : i = l, a = true;
      continue;
    }
    if (h(r) === "Negate" && (r = d(r, 1), t = !t), l = e12.wrap(r, 390), !i) i = l;
    else {
      let f = h(r);
      a && (f === "Divide" || f === "Rational") ? i = Ui(e12.options.multiply, i, l) : e12.options.invisibleMultiply ? i = Ui(e12.options.invisibleMultiply, i, l) : i = b([i, l]);
    }
    a = false;
  }
  return e12.level += 1, t ? "-" + i : i;
}
function Up(e12) {
  var _a2;
  let n = e12.parseGroup(), i = null;
  if (n === null ? (n = e12.parseToken(), i = e12.parseToken()) : i = e12.parseGroup(), n = F(n), i = F(i), h(n) === "PartialDerivative" && (h(i) === "PartialDerivative" || h(i) === "Multiply" && h(d(i, 1)) === "PartialDerivative")) {
    let t = (_a2 = d(n, 3)) != null ? _a2 : null, r = d(n, 1);
    r == null && (r = F(e12.parseExpression()));
    let s = [];
    if (h(i) === "Multiply") {
      for (let o of N(i)) if (h(o) === "PartialDerivative") {
        let a = d(o, 2);
        a && s.push(a);
      }
    } else {
      let o = d(i, 2);
      o && s.push(o);
    }
    return s.length > 1 && (s = ["List", ...s]), ["PartialDerivative", r, ...s, t === null ? 1 : t];
  }
  return ["Divide", n, i];
}
function Mu(e12, n) {
  if (n === null) return "";
  let i = F(d(n, 1)), t = F(d(n, 2)), r = e12.options.prettify ? e12.fractionStyle(n, e12.level) : "quotient";
  if (r === "inline-solidus" || r === "nice-solidus") {
    let u = e12.wrapShort(i), l = e12.wrapShort(t);
    return r === "inline-solidus" ? `${u}/${l}` : `{}^{${u}}\\!\\!/\\!{}_{${l}}`;
  } else {
    if (r === "reciprocal") return D(i) === 1 ? e12.wrap(t) + "^{-1}" : e12.wrap(i) + e12.wrap(t) + "^{-1}";
    if (r === "factor") return D(t) === 1 ? e12.wrap(i) : "\\frac{1}{" + e12.serialize(t) + "}" + e12.wrapString(e12.serialize(i), e12.groupStyle(n, 1));
  }
  let s = "\\frac";
  r === "block-quotient" ? s = "\\dfrac" : r === "inline-quotient" && (s = "\\tfrac");
  let o = e12.serialize(i), a = e12.serialize(t);
  return `${s}{${o}}{${a}}`;
}
function Xs(e12, n) {
  var _a2;
  if (!n) return "";
  let i = h(n), t = F(d(n, 1));
  if (i === "Sqrt") return Ct(e12, e12.rootStyle(n, e12.level - 1), t, 2);
  let r = F(d(n, 2));
  if (i === "Root") return Ct(e12, e12.rootStyle(n, e12.level - 1), t, r);
  if (e12.options.prettify) {
    let s = (_a2 = D(r)) != null ? _a2 : 1;
    if (s === -1) return e12.serialize(["Divide", "1", t]);
    if (s < 0) return e12.serialize(["Divide", "1", ["Power", t, -s]]);
    if (h(r) === "Divide" || h(r) === "Rational") {
      if (D(d(r, 1)) === 1) {
        let o = e12.rootStyle(n, e12.level);
        return Ct(e12, o, t, d(r, 2));
      }
      if (D(d(r, 2)) === 2) return `${e12.serialize(["Sqrt", t])}^{${e12.serialize(d(r, 1))}}`;
    } else if (h(r) === "Power" && D(d(r, 2)) === -1) {
      let o = e12.rootStyle(n, e12.level);
      return Ct(e12, o, t, d(r, 1));
    }
  }
  if (h(t) === "Power") {
    let s = d(t, 1), o = d(t, 2);
    return `
      ${e12.wrapShort(s)}^{${Ii("^", e12.wrapShort(o), e12.serialize(r))}}`;
  }
  return Ii("^", e12.wrapShort(t), e12.serialize(r));
}
var Fu = [{ name: "CatalanConstant", identifierTrigger: "G" }, { name: "GoldenRatio", latexTrigger: "\\varphi" }, { name: "EulerGamma", latexTrigger: "\\gamma" }, { name: "Degrees", latexTrigger: ["\\degree"], kind: "postfix", precedence: 880, parse: (e12, n) => ["Degrees", n], serialize: (e12, n) => b([e12.serialize(d(n, 1)), "\\degree"]) }, { latexTrigger: ["\\degree"], kind: "postfix", precedence: 880, parse: (e12, n) => ["Degrees", n] }, { latexTrigger: ["^", "<{>", "\\circ", "<}>"], kind: "postfix", parse: (e12, n) => ["Degrees", n] }, { latexTrigger: ["^", "\\circ"], kind: "postfix", parse: (e12, n) => ["Degrees", n] }, { latexTrigger: ["\xB0"], kind: "postfix", precedence: 880, parse: (e12, n) => ["Degrees", n] }, { latexTrigger: ["\\ang"], parse: (e12) => {
  let n = e12.parseGroup();
  return n === null ? ["Degrees"] : ["Degrees", n];
} }, { latexTrigger: ["\\infty"], parse: "PositiveInfinity" }, { name: "PositiveInfinity", serialize: (e12) => e12.options.positiveInfinity }, { name: "NegativeInfinity", serialize: (e12) => e12.options.negativeInfinity }, { name: "ComplexInfinity", latexTrigger: ["\\tilde", "\\infty"], serialize: "\\tilde\\infty" }, { latexTrigger: ["\\tilde", "<{>", "\\infty", "<}>"], parse: "ComplexInfinity" }, { name: "Pi", kind: "symbol", latexTrigger: ["\\pi"] }, { latexTrigger: ["\u03C0"], parse: "Pi" }, { name: "ExponentialE", latexTrigger: ["\\exponentialE"], parse: "ExponentialE", serialize: "\\exponentialE" }, { latexTrigger: "\\operatorname{e}", parse: "ExponentialE" }, { latexTrigger: "\\mathrm{e}", parse: "ExponentialE" }, { kind: "function", identifierTrigger: "exp", parse: "Exp" }, { latexTrigger: "\\exp", parse: "Exp" }, { name: "ImaginaryUnit", latexTrigger: ["\\imaginaryI"] }, { latexTrigger: "\\operatorname{i}", parse: "ImaginaryUnit" }, { latexTrigger: "\\mathrm{i}", parse: "ImaginaryUnit" }, { name: "Abs", kind: "matchfix", openTrigger: "|", closeTrigger: "|", parse: (e12, n) => U(n) ? null : ["Abs", n] }, { kind: "matchfix", openTrigger: ["\\vert"], closeTrigger: ["\\vert"], parse: (e12, n) => U(n) ? null : ["Abs", n] }, { identifierTrigger: "abs", kind: "function", parse: "Abs" }, { name: "Add", latexTrigger: ["+"], kind: "infix", associativity: "any", precedence: 275, parse: (e12, n, i) => {
  let t = e12.parseExpression({ ...i, minPrec: 275 });
  return t === null ? null : $i("Add", n, t);
}, serialize: Gp }, { kind: "prefix", latexTrigger: ["+"], precedence: 275, parse: (e12, n) => e12.parseExpression({ ...n, minPrec: 400 }) }, { name: "Ceil", kind: "matchfix", openTrigger: "\\lceil", closeTrigger: "\\rceil", parse: (e12, n) => U(n) ? null : ["Ceil", n] }, { kind: "matchfix", openTrigger: ["\u2308"], closeTrigger: ["\u2309"], parse: (e12, n) => U(n) ? null : ["Ceil", n] }, { identifierTrigger: "ceil", kind: "function", parse: "Ceil" }, { name: "Chop", identifierTrigger: "chop", kind: "function", parse: "Chop" }, { name: "Complex", precedence: 274, serialize: (e12, n) => {
  let i = e12.serialize(d(n, 1)), t = D(d(n, 2));
  if (t === 0) return i;
  let r = t === 1 ? "\\imaginaryI" : t === -1 ? "-\\imaginaryI" : b([e12.serialize(d(n, 2)), "\\imaginaryI"]);
  return D(d(n, 1)) === 0 ? r : t !== null && t < 0 ? b([i, r]) : b([i, "+", r]);
} }, { name: "Divide", latexTrigger: "\\frac", precedence: 600, parse: Up, serialize: Mu }, { kind: "infix", latexTrigger: "\\over", associativity: "none", precedence: 600, parse: "Divide" }, { latexTrigger: ["\\/"], kind: "infix", associativity: "left", precedence: 600, parse: "Divide" }, { latexTrigger: ["/"], kind: "infix", associativity: "left", precedence: 600, parse: "Divide" }, { latexTrigger: ["\\div"], kind: "infix", associativity: "left", precedence: 600, parse: "Divide" }, { name: "Exp", serialize: (e12, n) => {
  let i = d(n, 1);
  return A(i) || D(i) !== null ? b(["\\exponentialE^{", e12.serialize(i), "}"]) : b(["\\exp", e12.wrap(F(i))]);
} }, { name: "Factorial", latexTrigger: ["!"], kind: "postfix", precedence: 810 }, { name: "Factorial2", latexTrigger: ["!", "!"], kind: "postfix", precedence: 810 }, { name: "Floor", kind: "matchfix", openTrigger: "\\lfloor", closeTrigger: "\\rfloor", parse: (e12, n) => U(n) ? null : ["Floor", n] }, { kind: "matchfix", openTrigger: ["\u230A"], closeTrigger: ["\u230B"], parse: (e12, n) => U(n) ? null : ["Floor", n] }, { identifierTrigger: "floor", kind: "function", parse: "Floor" }, { latexTrigger: ["\\Gamma"], parse: "Gamma" }, { name: "GCD", latexTrigger: ["\\gcd"] }, { identifierTrigger: "gcd", kind: "function", parse: "GCD" }, { identifierTrigger: "GCD", kind: "function", parse: "GCD" }, { name: "Half", serialize: "\\frac12" }, { name: "Lg", latexTrigger: ["\\lg"], serialize: (e12, n) => "\\log_{10}" + e12.wrapArguments(n), parse: (e12) => {
  let n = e12.parseArguments("implicit");
  return n === null ? "Lg" : ["Log", ...n, 10];
} }, { name: "Lb", latexTrigger: "\\lb", parse: (e12) => {
  let n = e12.parseArguments("implicit");
  return n === null ? "Log" : ["Log", n[0], 2];
} }, { name: "Ln", latexTrigger: ["\\ln"], parse: (e12) => Ou("Ln", e12), serialize: (e12, n) => "\\ln" + e12.wrapArguments(n) }, { name: "Log", latexTrigger: ["\\log"], parse: (e12) => Ou("Log", e12), serialize: (e12, n) => {
  let [i, t] = N(n);
  return t ? b(["\\log_{", e12.serialize(t), "}", e12.wrap(i)]) : "\\log" + e12.wrapArguments(n);
} }, { name: "LCM", identifierTrigger: "lcm", kind: "function" }, { identifierTrigger: "LCM", kind: "function", parse: "LCM" }, { identifierTrigger: "max", kind: "function", parse: "Max" }, { identifierTrigger: "min", kind: "function", parse: "Min" }, { name: "Max", latexTrigger: "\\max", kind: "function" }, { name: "Min", latexTrigger: "\\min", kind: "function" }, { name: "Supremum", latexTrigger: "\\sup", kind: "function" }, { name: "Infimum", latexTrigger: "\\inf", kind: "function" }, { name: "Limit", latexTrigger: "\\lim", kind: "expression", parse: (e12) => {
  if (!e12.match("_")) return null;
  let n = e12.parseGroup();
  if (h(n) !== "To") return null;
  let i = e12.parseArguments("implicit");
  return i ? ["Limit", ["Function", i[0], d(n, 1)], d(n, 2)] : null;
}, serialize: (e12, n) => {
  let i = d(n, 1), t = d(i, 2), r = d(n, 2);
  return b(["\\lim_{", e12.serialize(t), "\\to", e12.serialize(r), "}", e12.serialize(d(i, 1))]);
} }, { name: "MinusPlus", latexTrigger: ["\\mp"], kind: "infix", associativity: "any", precedence: 270 }, { name: "Multiply", latexTrigger: ["\\times"], kind: "infix", associativity: "any", precedence: 390, serialize: Lu }, { latexTrigger: ["\\cdot"], kind: "infix", associativity: "any", precedence: 390, parse: (e12, n, i) => {
  let t = e12.parseExpression({ ...i, minPrec: 392 });
  return t === null ? ["Multiply", n, Li] : $i("Multiply", n, t);
} }, { latexTrigger: ["*"], kind: "infix", associativity: "any", precedence: 390, parse: (e12, n, i) => {
  let t = e12.parseExpression({ ...i, minPrec: 392 });
  return t === null ? ["Multiply", n, Li] : $i("Multiply", n, t);
} }, { name: "Mod", latexTrigger: "\\bmod", kind: "infix", precedence: 600, serialize: (e12, n) => {
  if (Y(n) !== 2) return "";
  let i = e12.serialize(d(n, 1)), t = e12.serialize(d(n, 2));
  return b([i, "\\bmod", t]);
} }, { latexTrigger: "\\mod", kind: "infix", precedence: 600, parse: "Mod" }, { latexTrigger: "\\pmod", kind: "prefix", precedence: 245, parse: (e12) => {
  var _a2;
  let n = (_a2 = e12.parseGroup()) != null ? _a2 : e12.parseToken();
  return ["Mod", F(n)];
} }, { name: "Congruent", serialize: (e12, n) => {
  let i = e12.serialize(d(n, 1)), t = e12.serialize(d(n, 2));
  if (d(n, 3) === null) return b([i, "\\equiv", t]);
  let r = e12.serialize(d(n, 3));
  return b([i, "\\equiv", t, "\\pmod{", r, "}"]);
} }, { name: "Negate", latexTrigger: ["-"], kind: "prefix", precedence: 701, parse: (e12, n) => {
  e12.skipSpace();
  let i = e12.parseExpression({ ...n, minPrec: 703 });
  return i === null ? null : ["Negate", i];
} }, { kind: "matchfix", openTrigger: "||", closeTrigger: "||", parse: (e12, n) => U(n) ? null : ["Norm", n] }, { name: "Norm", kind: "matchfix", openTrigger: ["\\left", "\\Vert"], closeTrigger: ["\\right", "\\Vert"], parse: (e12, n) => U(n) ? null : ["Norm", n] }, { name: "PlusMinus", latexTrigger: ["\\pm"], kind: "infix", associativity: "any", precedence: 270, serialize: (e12, n) => {
  let i = d(n, 1);
  if (i === null) return "\\pm";
  if (Y(n) === 1) return b(["\\pm", e12.serialize(i)]);
  let t = d(n, 2);
  return b([e12.serialize(i), "\\pm", e12.serialize(t)]);
} }, { latexTrigger: ["\\pm"], kind: "prefix", precedence: 270, parse: (e12, n) => {
  let i = e12.parseExpression({ ...n, minPrec: 400 });
  return ["PlusMinus", 0, F(i)];
} }, { latexTrigger: ["\\plusmn"], kind: "infix", associativity: "any", precedence: 270, parse: (e12, n, i) => {
  let t = e12.parseExpression({ ...i, minPrec: 400 });
  return ["PlusMinus", n, F(t)];
} }, { latexTrigger: ["\\plusmn"], kind: "prefix", precedence: 270, parse: (e12, n) => {
  let i = e12.parseExpression({ ...n, minPrec: 400 });
  return ["PlusMinus", F(i)];
} }, { name: "Power", latexTrigger: ["^"], kind: "infix", serialize: Xs }, { latexTrigger: "\\prod", precedence: 390, name: "Product", parse: Cu("Product", 390), serialize: Pu("\\prod") }, { name: "Rational", precedence: 600, serialize: (e12, n) => n && Y(n) === 1 ? "\\operatorname{Rational}" + e12.wrapArguments(n) : Mu(e12, n) }, { name: "Root", serialize: Xs }, { name: "Round", identifierTrigger: "round", kind: "function" }, { name: "Square", precedence: 720, serialize: (e12, n) => e12.wrapShort(d(n, 1)) + "^2" }, { latexTrigger: ["\\sum"], precedence: 275, name: "Sum", parse: Cu("Sum", 390), serialize: Pu("\\sum") }, { name: "Sign", identifierTrigger: "sgn", kind: "function" }, { name: "Sqrt", latexTrigger: ["\\sqrt"], parse: zp, serialize: Xs }, { name: "Subtract", latexTrigger: ["-"], kind: "infix", associativity: "left", precedence: 277, parse: (e12, n, i) => {
  e12.index -= 1;
  let t = e12.parseExpression({ ...i, minPrec: 278 });
  return t === null ? null : ["Add", n, t];
}, serialize: (e12, n) => {
  let i = e12.wrap(d(n, 1), 277), t = e12.wrap(d(n, 2), 278);
  return b([i, "-", t]);
} }];
function jp(e12, n) {
  var _a2, _b, _c2, _d2, _e2, _f2;
  if (e12 !== null) {
    if (A(e12)) return { index: (_a2 = A(e12)) != null ? _a2 : "Nothing", upper: n };
    if (h(e12) === "GreaterEqual") {
      let i = (_b = A(d(e12, 1))) != null ? _b : "Nothing", t = (_c2 = d(e12, 2)) != null ? _c2 : 1;
      return { index: i, lower: t, upper: n };
    }
    if (h(e12) === "Equal") {
      let i = (_d2 = A(d(e12, 1))) != null ? _d2 : "Nothing", t = d(e12, 2);
      if (h(t) === "Range") {
        let s = (_e2 = d(t, 1)) != null ? _e2 : 1, o = (_f2 = d(t, 2)) != null ? _f2 : void 0;
        return { index: i, lower: s, upper: o };
      }
      return { index: i, lower: t != null ? t : 1, upper: n };
    }
  }
}
function Zp(e12, n) {
  var _a2, _b;
  U(e12) && (e12 = null), U(n) && (n = null);
  let i = e12 === null ? [] : (_a2 = wn(e12)) != null ? _a2 : [e12], t = n === null ? [] : (_b = wn(n)) != null ? _b : [n];
  return i.map((r, s) => jp(r, t[s])).filter((r) => r !== void 0);
}
function Cu(e12, n) {
  return (i) => {
    var _a2, _b, _c2;
    i.skipSpace();
    let t = null, r = null;
    for (; !(r && t) && (i.peek === "_" || i.peek === "^"); ) i.match("_") ? r = (_a2 = i.parseGroup()) != null ? _a2 : i.parseToken() : i.match("^") && (t = (_b = i.parseGroup()) != null ? _b : i.parseToken()), i.skipSpace();
    let s = Zp(r, t);
    i.pushSymbolTable();
    for (let u of s) i.addSymbol(u.index, "symbol");
    let o = i.parseExpression({ minPrec: n });
    if (i.popSymbolTable(), o === null) return [e12];
    let a = [];
    for (let u of s) {
      let l = u.lower, f = u.upper, c = (_c2 = u.index) != null ? _c2 : "Nothing";
      f != null ? a.push(["Tuple", c, l != null ? l : 1, f]) : l != null ? a.push(["Tuple", c, l]) : a.push(["Tuple", c]);
    }
    return [e12, o, ...a];
  };
}
function Pu(e12) {
  return (n, i) => {
    if (!d(i, 1)) return e12;
    let t = d(i, 2), r = h(t);
    r !== "Tuple" && r !== "Triple" && r !== "Pair" && r !== "Single" && (t = null);
    let s = d(t, 1);
    s !== null && h(s) === "Hold" && (s = d(s, 1));
    let o = d(i, 1);
    if (t != null) return d(i, 2) !== null ? b([e12, n.serialize(o)]) : b([e12, "_{", n.serialize(d(i, 2)), "}", n.serialize(o)]);
    let a = d(t, 2), u = [];
    s && A(s) !== "Nothing" && a ? u = [n.serialize(s), "=", n.serialize(a)] : s && A(s) !== "Nothing" ? u = [n.serialize(s)] : a !== null && (u = [n.serialize(a)]), u.length > 0 && (u = ["_{", ...u, "}"]);
    let l = [];
    return d(t, 3) !== null && (l = ["^{", n.serialize(d(t, 3)), "}"]), b([e12, ...l, ...u, n.serialize(o)]);
  };
}
function Ou(e12, n) {
  var _a2;
  let i = null;
  n.match("_") && (i = (_a2 = n.parseGroup()) != null ? _a2 : n.parseToken());
  let t = n.parseArguments("implicit");
  return t === null && i === null ? [e12] : t === null ? [e12, i] : i === null ? [e12, ...t] : i === 10 ? ["Log", t[0]] : i === 2 ? ["Lb", ...t] : ["Log", t[0], i];
}
function Pt(e12) {
  let n = 1, i = e12;
  do {
    e12 = i;
    let t = h(e12);
    if (t === "Negate") n *= -1, i = d(e12, 1);
    else if (t === "Multiply") {
      let [r, s] = Pt(d(e12, 1));
      s < 0 && (n *= -1, r === 1 ? i = ["Multiply", ...N(e12).slice(1)] : i = ["Multiply", r, ...N(e12).slice(1)]);
    } else if (t === "Divide" || t === "Rational") {
      let [r, s] = Pt(d(e12, 1));
      s < 0 && (n *= -1, i = [t, r, d(e12, 2)]);
    } else {
      let r = D(e12);
      r !== null && r < 0 && (n *= -1, i = -r);
    }
  } while (i !== e12);
  return [e12, n];
}
function Ks(e12, n, i, t, r) {
  if (n && n.minPrec >= t) return null;
  let s = i ? [i] : ["Nothing"], o = false;
  for (; !o; ) {
    for (o = true, e12.skipSpace(); e12.match(r); ) s.push("Nothing"), e12.skipSpace();
    if (e12.atTerminator(n)) s.push("Nothing");
    else {
      let a = e12.parseExpression({ ...n, minPrec: t });
      s.push(a != null ? a : "Nothing"), o = a === null;
    }
    o || (e12.skipSpace(), o = !e12.match(r));
  }
  return s;
}
function xn(e12 = "") {
  return (n, i) => {
    var _a2;
    if (!i) return "";
    let t = N(i);
    if (t.length === 0) return "";
    if (t.length === 1) return n.serialize(t[0]);
    e12 = (_a2 = { "&": "\\&", ":": "\\colon", "|": "\\mvert", "-": "-", "\xB7": "\\cdot", "\u2012": "-", "\u2013": "--", "\u2014": "---", "\u2015": "-", "\u2022": "\\bullet", "\u2026": "\\ldots" }[e12]) != null ? _a2 : e12;
    let r = t.reduce((s, o) => (s.push(n.serialize(o), e12), s), []);
    return r.pop(), b(r);
  };
}
var qu = [{ latexTrigger: ["\\placeholder"], kind: "symbol", parse: (e12) => {
  for (; e12.match("<space>"); ) ;
  if (e12.match("[")) for (; !e12.match("]") && !e12.atBoundary; ) e12.nextToken();
  for (; e12.match("<space>"); ) ;
  if (e12.match("<{>")) for (; !e12.match("<}>") && !e12.atBoundary; ) e12.nextToken();
  return "Nothing";
} }, { name: "Function", latexTrigger: ["\\mapsto"], kind: "infix", precedence: 270, parse: (e12, n) => {
  var _a2, _b, _c2;
  let i = [];
  if (h(n) === "Delimiter" && (n = (_a2 = d(n, 1)) != null ? _a2 : "Nothing"), h(n) === "Sequence") for (let r of N(n)) {
    if (!A(r)) return null;
    i.push(A(r));
  }
  else {
    if (!A(n)) return null;
    i = [A(n)];
  }
  let t = (_b = e12.parseExpression({ minPrec: 270 })) != null ? _b : "Nothing";
  return h(t) === "Delimiter" && (t = (_c2 = d(t, 1)) != null ? _c2 : "Nothing"), h(t) === "Sequence" && (t = ["Block", ...N(t)]), ["Function", t, ...i];
}, serialize: (e12, n) => {
  var _a2;
  let i = N(n);
  return i.length < 1 ? "()\\mapsto()" : i.length === 1 ? b(["()", "\\mapsto", e12.serialize(d(n, 1))]) : i.length === 2 ? b([e12.serialize(d(n, 2)), "\\mapsto", e12.serialize(d(n, 1))]) : b([e12.wrapString((_a2 = N(n)) == null ? void 0 : _a2.slice(1).map((t) => e12.serialize(t)).join(", "), "normal"), "\\mapsto", e12.serialize(d(n, 1))]);
} }, { name: "Apply", kind: "function", identifierTrigger: "apply", serialize: (e12, n) => {
  let i = d(n, 1), t = h(i);
  if (t === "InverseFunction" || t === "Derivative") {
    let o = e12.options.applyFunctionStyle(n, e12.level), a = N(n).slice(1);
    return e12.serializeFunction(i, e12.dictionary.ids.get(t)) + e12.wrapString(a.map((u) => e12.serialize(u)).join(", "), o);
  }
  let r = d(n, 2);
  if (typeof i == "string" || !r) {
    let o = N(n).slice(1);
    return e12.serialize(o);
  }
  if (Y(n) === 2) return b([e12.wrap(i, 20), "\\lhd", e12.wrap(r, 20)]);
  let s = e12.options.applyFunctionStyle(n, e12.level);
  return b(["\\operatorname{apply}", e12.wrapString(e12.serialize(t) + ", " + e12.serialize(["List", ...N(n)]), s)]);
} }, { latexTrigger: "\\lhd", kind: "infix", precedence: 20, parse: "Apply" }, { latexTrigger: "\\rhd", kind: "infix", precedence: 20, parse: (e12, n) => {
  var _a2;
  return ["Apply", (_a2 = e12.parseExpression({ minPrec: 21 })) != null ? _a2 : "Nothing", n];
} }, { name: "Assign", latexTrigger: "\\coloneq", kind: "infix", associativity: "right", precedence: 260, serialize: (e12, n) => {
  let i = Vs(d(n, 1));
  if (h(d(n, 2)) === "Function") {
    let t = d(n, 2), r = Vs(d(t, 1)), s = N(t).slice(1);
    return b([e12.serialize(i), e12.wrapString(s.map((o) => e12.serialize(o)).join(", "), e12.options.applyFunctionStyle(n, e12.level)), "\\coloneq", e12.serialize(r)]);
  }
  return b([e12.serialize(i), "\\coloneq", e12.serialize(d(n, 2))]);
}, parse: Pr }, { latexTrigger: "\\coloneqq", kind: "infix", associativity: "right", precedence: 260, parse: Pr }, { latexTrigger: "\\colonequals", kind: "infix", associativity: "right", precedence: 260, parse: Pr }, { latexTrigger: [":", "="], kind: "infix", associativity: "right", precedence: 260, parse: Pr }, { name: "BaseForm", serialize: (e12, n) => {
  var _a2, _b;
  let i = (_a2 = D(d(n, 2))) != null ? _a2 : NaN;
  if (isFinite(i) && i >= 2 && i <= 36) {
    let t = (_b = D(d(n, 1))) != null ? _b : NaN;
    if (isFinite(t) && Number.isInteger(t)) {
      let r = Number(t).toString(i), s = 0;
      if (i === 2 || i === 10 ? s = 4 : i === 16 ? s = 2 : i > 16 && (s = 4), s > 0) {
        let o = r;
        r = "";
        for (let a = 0; a < o.length; a++) a > 0 && a % s === 0 && (r = "\\, " + r), r = o[o.length - a - 1] + r;
      }
      return `(\\text{${r}}_{${i}}`;
    }
  }
  return "\\operatorname{BaseForm}(" + e12.serialize(d(n, 1)) + ", " + e12.serialize(d(n, 2)) + ")";
} }, { name: "Sequence", serialize: xn(" ") }, { name: "InvisibleOperator", serialize: xn("") }, { name: "Delimiter", serialize: (e12, n) => {
  let i = e12.options.groupStyle(n, e12.level + 1), t = d(n, 1), r = { Set: "{,}", List: "[,]", Tuple: "(,)", Single: "(,)", Pair: "(,)", Triple: "(,)", Sequence: "(,)", String: '""' }[h(t)], s = r ? t : ["Sequence", t];
  if (r != null ? r : r = "(,)", Y(n) > 1) {
    let f = V(d(n, 2));
    typeof f == "string" && f.length <= 3 && (r = f);
  }
  let [o, a, u] = ["", "", ""];
  r.length === 3 ? [o, a, u] = r : r.length === 2 ? [o, u] = r : r.length === 1 && (a = r);
  let l = t ? s ? xn(a)(e12, s) : e12.serialize(t) : "";
  return e12.wrapString(l, i, o + u);
} }, { name: "Tuple", serialize: (e12, n) => b(["(", xn(",")(e12, n), ")"]) }, { name: "Pair", serialize: (e12, n) => b(["(", xn(",")(e12, n), ")"]) }, { name: "Triple", serialize: (e12, n) => b(["(", xn(",")(e12, n), ")"]) }, { name: "Single", serialize: (e12, n) => b(["(", xn(",")(e12, n), ")"]) }, { name: "Domain", serialize: (e12, n) => h(n) === "Error" ? e12.serialize(n) : `\\mathbf{${e12.serialize(d(n, 1))}}` }, { latexTrigger: ["\\mathtip"], parse: (e12) => {
  let n = e12.parseGroup();
  return e12.parseGroup(), n;
} }, { latexTrigger: ["\\texttip"], parse: (e12) => {
  let n = e12.parseGroup();
  return e12.parseGroup(), n;
} }, { latexTrigger: ["\\error"], parse: (e12) => ["Error", e12.parseGroup()] }, { name: "Error", serialize: (e12, n) => {
  var _a2;
  let i = d(n, 1);
  if (V(i) === "missing") return `\\error{${(_a2 = e12.options.missingSymbol) != null ? _a2 : "\\placeholder{}"}}`;
  let t = Jp(e12, n) || "\\blacksquare", r = h(i) === "ErrorCode" ? V(d(i, 1)) : V(i);
  return r === "incompatible-type" ? A(d(i, 3)) === "Undefined" ? `\\mathtip{\\error{${t}}}{\\notin ${e12.serialize(d(i, 2))}}` : `\\mathtip{\\error{${t}}}{\\in ${e12.serialize(d(i, 3))}\\notin ${e12.serialize(d(i, 2))}}` : typeof r == "string" ? `\\error{${t}}` : `\\error{${t}}`;
} }, { name: "ErrorCode", serialize: (e12, n) => {
  var _a2;
  let i = V(d(n, 1));
  return i === "missing" ? (_a2 = e12.options.missingSymbol) != null ? _a2 : "\\placeholder{}" : i === "unexpected-command" || i === "unexpected-operator" || i === "unexpected-token" || i === "invalid-identifier" || i === "unknown-environment" || i === "unexpected-base" || i === "incompatible-type" ? "" : `\\texttip{\\error{\\blacksquare}}{\\mathtt{${i}}}`;
} }, { name: "FromLatex", serialize: (e12, n) => `\\texttt{${Wp(V(d(n, 1)))}}` }, { name: "Latex", serialize: (e12, n) => n === null ? "" : b(Dr(n, (i) => {
  var _a2;
  return (_a2 = V(i)) != null ? _a2 : e12.serialize(i);
})) }, { name: "LatexString", serialize: (e12, n) => n === null ? "" : b(Dr(n, (i) => e12.serialize(i))) }, { name: "LatexTokens", serialize: Hp }, { name: "At", kind: "postfix", precedence: 810, latexTrigger: ["["], parse: no("]"), serialize: (e12, n) => b(["\\lbrack", xn(", ")(e12, n), "\\rbrack"]) }, { kind: "postfix", precedence: 810, latexTrigger: ["\\lbrack"], parse: no("\\rbrack") }, { kind: "postfix", precedence: 810, latexTrigger: ["\\left", "\\lbrack"], parse: no("\\right", "\\rbrack") }, { kind: "postfix", latexTrigger: ["_"], parse: (e12, n, i) => {
  var _a2;
  let t = (_a2 = e12.parseGroup()) != null ? _a2 : e12.parseToken();
  return ["Subscript", n, t];
} }, { name: "List", kind: "matchfix", openTrigger: "[", closeTrigger: "]", parse: $u, serialize: Qp }, { kind: "matchfix", openTrigger: "(", closeTrigger: ")", parse: Yp }, { latexTrigger: [","], kind: "infix", precedence: 20, parse: (e12, n, i) => {
  let t = Ks(e12, i, n, 20, ",");
  return t === null ? null : ["Delimiter", ["Sequence", ...t], { str: "," }];
} }, { latexTrigger: [","], kind: "prefix", precedence: 20, parse: (e12, n) => {
  let i = Ks(e12, n, null, 20, ",");
  return i === null ? null : ["Delimiter", ["Sequence", ...i], { str: "," }];
} }, { name: "Range", latexTrigger: [".", "."], kind: "infix", precedence: 800, parse: Xp, serialize: (e12, n) => {
  let i = N(n);
  if (i.length === 0) return "";
  if (i.length === 1) return "1.." + e12.serialize(d(n, 1));
  if (i.length === 2) return e12.wrap(d(n, 1), 10) + ".." + e12.wrap(d(n, 2), 10);
  if (i.length === 3) {
    let t = D(d(n, 3)), r = D(d(n, 1));
    return t !== null && r !== null ? e12.wrap(d(n, 1), 10) + ".." + e12.wrap(r + t, 10) + ".." + e12.wrap(d(n, 2), 10) : e12.wrap(d(n, 1), 10) + "..(" + (e12.wrap(d(n, 1), 275) + "+" + e12.wrap(d(n, 3), 275)) + ").." + e12.wrap(d(n, 2), 10);
  }
  return "";
} }, { latexTrigger: [";"], kind: "infix", precedence: 19, parse: (e12, n, i) => {
  let t = Ks(e12, i, n, 19, ";");
  return t === null ? null : ["Delimiter", ["Sequence", ...t], "';'"];
} }, { name: "String", latexTrigger: ["\\text"], parse: (e12) => io(e12), serialize: (e12, n) => {
  let i = N(n);
  return i.length === 0 ? "\\text{}" : b(["\\text{", i.map((t) => e12.serialize(t)).join(""), "}"]);
} }, { name: "Subscript", latexTrigger: ["_"], kind: "infix", serialize: (e12, n) => Y(n) === 2 ? e12.serialize(d(n, 1)) + "_{" + e12.serialize(d(n, 2)) + "}" : "_{" + e12.serialize(d(n, 1)) + "}" }, { name: "Superplus", latexTrigger: ["^", "+"], kind: "postfix" }, { name: "Subplus", latexTrigger: ["_", "+"], kind: "postfix" }, { name: "Superminus", latexTrigger: ["^", "-"], kind: "postfix" }, { name: "Subminus", latexTrigger: ["_", "-"], kind: "postfix" }, { latexTrigger: ["^", "*"], kind: "postfix", parse: (e12, n) => ["Superstar", n] }, { latexTrigger: ["_", "*"], kind: "postfix", parse: (e12, n) => ["Substar", n] }, { name: "Substar", latexTrigger: ["_", "\\star"], kind: "postfix" }, { name: "Superdagger", latexTrigger: ["^", "\\dagger"], kind: "postfix" }, { latexTrigger: ["^", "\\dag"], kind: "postfix", parse: (e12, n) => ["Superdagger", n] }, { name: "Prime", latexTrigger: ["^", "\\prime"], kind: "postfix", parse: (e12, n) => Dn(e12, n, 1), serialize: (e12, n) => {
  var _a2;
  let i = (_a2 = D(d(n, 2))) != null ? _a2 : 1, t = e12.serialize(d(n, 1));
  return i === 1 ? t + "^\\prime" : i === 2 ? t + "^\\doubleprime" : i === 3 ? t + "^\\tripleprime" : t + "^{(" + e12.serialize(d(n, 2)) + ")}";
} }, { latexTrigger: "^{\\prime\\prime}", kind: "postfix", parse: (e12, n) => Dn(e12, n, 2) }, { latexTrigger: "^{\\prime\\prime\\prime}", kind: "postfix", parse: (e12, n) => Dn(e12, n, 3) }, { latexTrigger: ["^", "\\doubleprime"], kind: "postfix", parse: (e12, n) => Dn(e12, n, 2) }, { latexTrigger: ["^", "\\tripleprime"], kind: "postfix", parse: (e12, n) => Dn(e12, n, 3) }, { latexTrigger: "'", kind: "postfix", precedence: 810, parse: (e12, n) => Dn(e12, n, 1) }, { latexTrigger: "\\prime", kind: "postfix", precedence: 810, parse: (e12, n) => Dn(e12, n, 1) }, { latexTrigger: "\\doubleprime", kind: "postfix", precedence: 810, parse: (e12, n) => Dn(e12, n, 2) }, { latexTrigger: "\\tripleprime", kind: "postfix", precedence: 810, parse: (e12, n) => Dn(e12, n, 3) }, { latexTrigger: ["^", "<{>", "("], kind: "postfix", parse: (e12, n, i) => {
  let t = A(n);
  if (!t || e12.getIdentifierType(t) !== "function") return null;
  e12.addBoundary([")"]);
  let r = e12.parseExpression(i);
  return !e12.matchBoundary() || !e12.match("<}>") ? null : ["Derivative", n, r];
} }, { name: "InverseFunction", latexTrigger: "^{-1", kind: "postfix", parse: (e12, n) => {
  let i = A(n);
  if (!i || e12.getIdentifierType(i) !== "function") return null;
  let t = 0;
  for (; !e12.atEnd && !e12.match("<}>"); ) if (e12.match("'")) t++;
  else if (e12.match("\\prime")) t++;
  else if (e12.match("\\doubleprime")) t += 2;
  else if (e12.match("\\tripleprime")) t += 3;
  else return null;
  return t === 1 ? ["Derivative", ["InverseFunction", n]] : t > 0 ? ["Derivative", ["InverseFunction", n], t] : ["InverseFunction", n];
}, serialize: (e12, n) => e12.serialize(d(n, 1)) + "^{-1}" }, { name: "Derivative", serialize: (e12, n) => {
  var _a2;
  let i = (_a2 = D(d(n, 2))) != null ? _a2 : 1, t = e12.serialize(d(n, 1));
  return i === 1 ? t + "^{\\prime}" : i === 2 ? t + "^{\\doubleprime}" : i === 3 ? t + "^{\\tripleprime}" : t + "^{(" + e12.serialize(d(n, 2)) + ")}";
} }, { kind: "environment", name: "Which", identifierTrigger: "cases", parse: eo, serialize: (e12, n) => {
  let i = [], t = N(n);
  if (t.length > 0) for (let r = 0; r <= t.length - 2; r += 2) {
    let s = [];
    s.push(e12.serialize(t[r + 1])), s.push(e12.serialize(t[r])), i.push(s.join("&"));
  }
  return b(["\\begin{cases}", i.join("\\\\"), "\\end{cases}"]);
} }, { kind: "environment", identifierTrigger: "dcases", parse: eo }, { kind: "environment", identifierTrigger: "rcases", parse: eo }];
function io(e12, n) {
  var _a2, _b, _c2, _d2;
  if (!e12.match("<{>")) return "''";
  let i = [], t = "", r = null;
  for (; !e12.atEnd && !e12.match("<}>"); ) if (e12.peek === "<{>") i.push(io(e12));
  else if (e12.match("\\textbf") && e12.match("<{>")) i.push(io(e12, { "font-weight": "bold" }));
  else if (e12.match("\\color")) {
    let o = e12.parseStringGroup();
    o !== null && (r !== null && t ? i.push(["Style", t, wr(r)]) : t && i.push(["String", t]), t = "", r = { color: o });
  } else if (e12.match("<space>")) t += " ";
  else if (e12.match("<$>")) {
    let o = e12.index, a = (_a2 = e12.parseExpression()) != null ? _a2 : "Nothing";
    e12.skipSpace(), e12.match("<$>") ? i.push(a) : (t += "$", e12.index = o);
  } else if (e12.match("<$$>")) {
    let o = e12.index, a = (_b = e12.parseExpression()) != null ? _b : "Nothing";
    e12.skipSpace(), e12.match("<$$>") ? i.push(a) : (t += "$$", e12.index = o);
  } else {
    let o = (_c2 = e12.matchChar()) != null ? _c2 : e12.nextToken();
    t += (_d2 = { "\\enskip": "\u2002", "\\enspace": "\u2002", "\\quad": "\u2003", "\\qquad": "\u2003\u2003", "\\space": "\u2003", "\\ ": "\u2003", "\\;": "\u2004", "\\,": "\u2009", "\\:": "\u205F", "\\!": "", "\\{": "{", "\\}": "}", "\\$": "$", "\\&": "&", "\\#": "#", "\\%": "%", "\\_": "_", "\\textbackslash": "\\", "\\textasciitilde": "~", "\\textasciicircum": "^", "\\textless": "<", "\\textgreater": ">", "\\textbar": "|", "\\textunderscore": "_", "\\textbraceleft": "{", "\\textbraceright": "}", "\\textasciigrave": "`", "\\textquotesingle": "'", "\\textquotedblleft": "\u201C", "\\textquotedblright": "\u201D", "\\textquotedbl": '"', "\\textquoteleft": "\u2018", "\\textquoteright": "\u2019", "\\textbullet": "\u2022", "\\textdagger": "\u2020", "\\textdaggerdbl": "\u2021", "\\textsection": "\xA7", "\\textparagraph": "\xB6", "\\textperiodcentered": "\xB7", "\\textellipsis": "\u2026", "\\textemdash": "\u2014", "\\textendash": "\u2013", "\\textregistered": "\xAE", "\\texttrademark": "\u2122", "\\textdegree": "\xB0" }[o]) != null ? _d2 : o;
  }
  r !== null && t ? i.push(["Style", `'${t}'`, wr(r)]) : t && i.push(`'${t}'`);
  let s;
  return i.length === 1 ? s = i[0] : i.every((o) => V(o) !== null) ? s = "'" + i.map((o) => V(o)).join() + "'" : s = ["String", ...i], n ? ["Style", s, wr(n)] : s;
}
function Hp(e12, n) {
  return n === null ? "" : b(Dr(n, (i) => {
    let t = V(i);
    return t === null ? e12.serialize(i) : t === "<{>" ? "{" : t === "<}>" ? "}" : t === "<$>" ? "$" : t === "<$$>" ? "$$" : t === "<space>" ? " " : t;
  }));
}
function Wp(e12) {
  return e12 === null ? "" : e12.replace(/[{}\[\]\\:\-\$%]/g, (n) => {
    var _a2;
    return (_a2 = { "{": "\\lbrace ", "}": "\\rbrace ", "[": "\\lbrack ", "]": "\\rbrack ", ":": "\\colon ", "\\": "\\backslash " }[n]) != null ? _a2 : "\\" + n;
  });
}
function Jp(e12, n) {
  var _a2;
  let i = d(n, 2);
  return i ? h(i) === "LatexString" ? (_a2 = V(d(i, 1))) != null ? _a2 : "" : h(i) === "Hold" ? e12.serialize(d(i, 1)) : e12.serialize(i) : "";
}
function Dn(e12, n, i) {
  var _a2;
  let t = h(n);
  if (t === "Derivative" || t === "Prime") {
    let s = (_a2 = D(d(n, 2))) != null ? _a2 : 1;
    return [t, F(d(n, 1)), s + i];
  }
  let r = A(n);
  return r && e12.getIdentifierType(r) === "function" || h(n) ? i === 1 ? ["Derivative", n] : ["Derivative", n, i] : i === 1 ? ["Prime", F(n)] : ["Prime", F(n), i];
}
function Yp(e12, n) {
  var _a2, _b;
  if (U(n)) return ["Delimiter"];
  let i = h(n);
  if (i === "Delimiter" && d(n, 2) !== null) {
    let t = V(d(n, 2));
    if ((t == null ? void 0 : t.length) === 1) return ["Delimiter", (_a2 = d(n, 1)) != null ? _a2 : "Nothing", { str: `(${t})` }];
  }
  return i === "Matrix" && ((_b = V(d(n, 2))) != null ? _b : "..") === ".." ? ["Matrix", d(n, 1)] : ["Delimiter", n];
}
function $u(e12, n) {
  var _a2, _b;
  if (U(n)) return ["List"];
  let i = h(n);
  if (i === "Range" || i === "Linspace") return n;
  if (i === "Sequence") return ["List", ...N(n)];
  if (i === "Delimiter") {
    let t = (_a2 = V(d(n, 2))) != null ? _a2 : "...";
    if (t === ";" || t === ".;.") return ["List", ...((_b = N(d(n, 1))) != null ? _b : []).map((r) => $u(e12, r))];
    if (t === "," || t === ".,.") return n = d(n, 1), h(n) === "Sequence" ? ["List", ...N(n)] : ["List", n != null ? n : "Nothing"];
  }
  return ["List", n];
}
function Qp(e12, n) {
  return Y(n) > 1 && N(n).every((i) => {
    let t = h(i);
    return Nr(t) || Er(t);
  }) ? b(["\\begin{cases}", xn("\\\\")(e12, n), "\\end{cases}"]) : b(["\\bigl\\lbrack", xn(", ")(e12, n), "\\bigr\\rbrack"]);
}
function Xp(e12, n) {
  if (n === null) return null;
  let i = e12.parseExpression({ minPrec: 270 });
  if (i === null) return null;
  if (e12.matchAll([".", "."])) {
    let t = e12.parseExpression({ minPrec: 270 });
    if (t === null) return null;
    let r = D(n), s = D(i);
    return r !== null && s !== null ? s <= r ? null : s - r === 1 ? ["Range", n, t] : ["Range", n, t, s - r] : ["Range", n, t, ["Subtract", i, n]];
  }
  return ["Range", n, i];
}
var ji = { "(": "(", ")": ")", "[": "\\lbrack", "]": "\\rbrack", "\u27E6": "\\llbrack", "\u27E7": "\\rrbrack", "{": "\\lbrace", "}": "\\rbrace", "<": "\\langle", ">": "\\rangle", "\u2016": "\\Vert", "\\": "\\backslash", "\u2308": "\\lceil", "\u2309": "\\rceil", "\u230A": "\\lfloor", "\u230B": "\\rfloor", "\u231C": "\\ulcorner", "\u231D": "\\urcorner", "\u231E": "\\llcorner", "\u231F": "\\lrcorner", "\u23B0": "\\lmoustache", "\u23B1": "\\rmoustache" };
function Pr(e12, n) {
  if (h(n) === "InvisibleOperator" && Y(n) === 2 && h(d(n, 2)) === "Delimiter") {
    let r = A(d(n, 1));
    if (!r) return null;
    let s = e12.parseExpression({ minPrec: 0 });
    if (s === null) return null;
    let o = d(d(n, 2), 1), a = [];
    return h(o) === "Sequence" ? a = [...N(o)] : o && (a = [o]), ["Assign", r, ["Function", s, ...a != null ? a : []]];
  }
  let i = h(n);
  if (i) {
    let r = N(n), s = e12.parseExpression({ minPrec: 0 });
    return s === null ? null : ["Assign", i, ["Function", s, ...r]];
  }
  if (!A(n)) return null;
  let t = e12.parseExpression({ minPrec: 0 });
  return t === null ? null : ["Assign", n, t];
}
function eo(e12) {
  var _a2;
  let n = e12.parseTabular();
  if (!n) return ["List"];
  if (n.every((t) => {
    if (t.length !== 1) return false;
    let r = h(t[0]);
    return Er(r) || Nr(r);
  })) return ["List", ...n.map((t) => t[0])];
  let i = [];
  for (let t of n) if (t.length === 1) i.push("True"), i.push(t[0]);
  else if (t.length === 2) {
    let r = V(t[1]);
    i.push(r ? "True" : (_a2 = $s(t[1])) != null ? _a2 : "True"), i.push(t[0]);
  }
  return ["Which", ...i];
}
function no(...e12) {
  return (n, i) => {
    var _a2;
    if (!A(i) && h(i) !== "List") return null;
    let t = null;
    return e12.length === 0 && (t = n.parseGroup()), t != null ? t : t = n.parseExpression({ minPrec: 0 }), t === null || e12.length > 0 && !n.matchAll(e12) || V(t) !== null ? null : (h(t) === "Delimiter" && (t = (_a2 = d(t, 1)) != null ? _a2 : "Nothing"), h(t) === "Sequence" ? ["At", i, ...N(t)] : ["At", i, t]);
  };
}
var zu = [{ name: "Matrix", serialize: (e12, n) => {
  let i = N(d(n, 1));
  return Vu(e12, i, V(d(n, 2)), V(d(n, 3)));
} }, { name: "Vector", serialize: (e12, n) => {
  let i = N(n);
  return Vu(e12, i.map((t) => ["List", t]), V(d(n, 2)), V(d(n, 3)));
} }, { kind: "environment", identifierTrigger: "pmatrix", parse: (e12) => {
  let n = Rn(e12), [i, t] = An(e12);
  return n ? [i, t, { str: "()" }, { str: n }] : [i, t];
} }, { kind: "environment", identifierTrigger: "bmatrix", parse: (e12) => {
  let n = Rn(e12), [i, t] = An(e12);
  return n ? [i, t, { str: "[]" }, { str: n }] : [i, t, { str: "[]" }];
} }, { kind: "environment", identifierTrigger: "Bmatrix", parse: (e12) => {
  let n = Rn(e12), [i, t] = An(e12);
  return n ? [i, t, { str: "{}" }, { str: n }] : [i, t, { str: "{}" }];
} }, { kind: "environment", identifierTrigger: "vmatrix", parse: (e12) => {
  let n = Rn(e12), [i, t] = An(e12);
  return n ? [i, t, { str: "||" }, { str: n }] : [i, t, { str: "||" }];
} }, { kind: "environment", identifierTrigger: "Vmatrix", parse: (e12) => {
  let n = Rn(e12), [i, t] = An(e12);
  return n ? [i, t, { str: "\u2016\u2016" }, { str: n }] : [i, t, { str: "\u2016\u2016" }];
} }, { kind: "environment", identifierTrigger: "smallmatrix", parse: (e12) => {
  let n = Rn(e12), [i, t] = An(e12);
  return n ? [i, t, { str: "()" }, { str: n }] : [i, t];
} }, { kind: "environment", identifierTrigger: "array", parse: (e12) => {
  let n = Rn(e12, false), [i, t] = An(e12);
  return n ? [i, t, { str: ".." }, { str: n }] : [i, t, { str: ".." }];
} }, { kind: "environment", identifierTrigger: "matrix", parse: (e12) => {
  let n = Rn(e12), [i, t] = An(e12);
  return n ? [i, t, { str: ".." }, { str: n }] : [i, t, { str: ".." }];
} }, { kind: "environment", identifierTrigger: "matrix*", parse: (e12) => {
  let n = Rn(e12), [i, t] = An(e12);
  return n ? [i, t, { str: ".." }, { str: n }] : [i, t, { str: ".." }];
} }, { name: "ConjugateTranspose", kind: "postfix", latexTrigger: ["^", "\\star"] }, { kind: "postfix", latexTrigger: ["^", "\\H"], parse: "ConjugateTranspose" }, { kind: "postfix", latexTrigger: ["^", "\\dagger"], parse: (e12, n) => ["ConjugateTranspose", n] }, { kind: "postfix", latexTrigger: ["^", "\\ast"], parse: (e12, n) => ["ConjugateTranspose", n] }, { kind: "postfix", latexTrigger: ["^", "\\top"], parse: (e12, n) => ["Transpose", n] }, { kind: "postfix", latexTrigger: ["^", "\\intercal"], parse: (e12, n) => ["Transpose", n] }, { name: "Transpose", kind: "postfix", latexTrigger: ["^", "T"] }, { name: "PseudoInverse", kind: "postfix", latexTrigger: ["^", "+"] }, { name: "Trace", kind: "function", identifierTrigger: "tr" }, { name: "Determinant", kind: "function", identifierTrigger: "det" }];
function An(e12) {
  let n = e12.parseTabular();
  return n ? ["Matrix", ["List", ...n.map((i) => ["List", ...i])]] : ["", null];
}
function Rn(e12, n = true) {
  var _a2;
  let i = (_a2 = e12.parseStringGroup(n)) == null ? void 0 : _a2.trim();
  if (!i) return "";
  let t = "";
  for (let r of i) r === "c" && (t += "="), r === "l" && (t += "<"), r === "r" && (t += ">"), r === "|" && (t += "|"), r === ":" && (t += ":");
  return t;
}
function Vu(e12, n, i, t) {
  var _a2, _b;
  i != null ? i : i = "()";
  let [r, s] = ["", ""];
  typeof i == "string" && i.length === 2 && ([r, s] = i);
  let o = "";
  if (t) for (let f of t) f === "<" ? o += "l" : f === ">" ? o += "r" : f === "=" ? o += "c" : f === "|" ? o += "|" : f === ":" && (o += ":");
  let a = [];
  for (let f of n != null ? n : []) {
    let c = [];
    for (let p of N(f)) c.push(e12.serialize(p));
    a.push(c.join(" & "));
  }
  let u = a.join(`\\\\
`), l = o.length > 0 ? `[${o}]` : "";
  return r === "(" && s === ")" ? b(["\\begin{pmatrix}", l, u, "\\end{pmatrix}"]) : r === "[" && s === "]" ? b(["\\begin{bmatrix}", l, u, "\\end{bmatrix}"]) : r === "{" && s === "}" ? b(["\\begin{Bmatrix}", l, u, "\\end{Bmatrix}"]) : r === "|" && s === "|" ? b(["\\begin{vmatrix}", l, u, "\\end{vmatrix}"]) : r === "\u2016" && s === "\u2016" ? b(["\\begin{Vmatrix}", l, u, "\\end{Vmatrix}"]) : r === "{" && s === "." ? b(["\\begin{dcases}", l, u, "\\end{dcases}"]) : r === "." && s === "}" ? b(["\\begin{rcases}", l, u, "\\end{rcases}"]) : o || r !== "." || s !== "." ? b(["\\left", (_a2 = ji[r]) != null ? _a2 : r, "\\begin{array}", `{${o}}`, u, "\\end{array}", "\\right", (_b = ji[s]) != null ? _b : s]) : b(["\\begin{matrix}", u, "\\end{matrix}"]);
}
var Gu = [{ name: "True", kind: "symbol", latexTrigger: ["\\top"] }, { kind: "symbol", latexTrigger: "\\mathrm{True}", parse: "True" }, { kind: "symbol", latexTrigger: "\\operatorname{True}", parse: "True" }, { kind: "symbol", latexTrigger: "\\mathsf{T}", parse: "True" }, { name: "False", kind: "symbol", latexTrigger: ["\\bot"] }, { kind: "symbol", latexTrigger: "\\operatorname{False}", parse: "False" }, { kind: "symbol", latexTrigger: "\\mathsf{F}", parse: "False" }, { name: "And", kind: "infix", latexTrigger: ["\\land"], precedence: 317 }, { kind: "infix", latexTrigger: ["\\wedge"], parse: "And", precedence: 317 }, { kind: "infix", latexTrigger: "\\&", parse: "And", precedence: 317 }, { kind: "infix", latexTrigger: "\\operatorname{and}", parse: "And", precedence: 317 }, { name: "Or", kind: "infix", latexTrigger: ["\\lor"], precedence: 310 }, { kind: "infix", latexTrigger: ["\\vee"], parse: "Or", precedence: 310 }, { kind: "infix", latexTrigger: "\\parallel", parse: "Or", precedence: 310 }, { kind: "infix", latexTrigger: "\\operatorname{or}", parse: "Or", precedence: 310 }, { name: "Xor", kind: "infix", latexTrigger: ["\\veebar"], precedence: 315 }, { name: "Not", kind: "prefix", latexTrigger: ["\\lnot"], precedence: 880 }, { kind: "prefix", latexTrigger: ["\\neg"], parse: "Not", precedence: 880 }, { name: "Nand", kind: "infix", latexTrigger: ["\\barwedge"], precedence: 315 }, { name: "Nor", kind: "infix", latexTrigger: ["\u22BD"], precedence: 315 }, { kind: "function", identifierTrigger: "and", parse: "And" }, { kind: "function", identifierTrigger: "or", parse: "Or" }, { kind: "function", identifierTrigger: "not", parse: "Not" }, { name: "Implies", kind: "infix", precedence: 220, associativity: "right", latexTrigger: ["\\implies"], serialize: "\\implies" }, { latexTrigger: ["\\Rightarrow"], kind: "infix", precedence: 220, associativity: "right", parse: "Implies" }, { name: "Equivalent", latexTrigger: ["\\iff"], kind: "infix", associativity: "right", precedence: 219 }, { latexTrigger: ["\\Leftrightarrow"], kind: "infix", associativity: "right", precedence: 219, parse: "Equivalent" }, { latexTrigger: ["\\equiv"], kind: "infix", associativity: "right", precedence: 219, parse: (e12, n, i) => {
  let t = e12.parseExpression({ ...i, minPrec: 219 }), r = e12.index, s = e12.parseExpression({ ...i, minPrec: 219 });
  return s !== null && h(s) === "Mod" ? ["Congruent", n, t, F(d(s, 1))] : (e12.index = r, ["Equivalent", n, F(t)]);
} }, { name: "Proves", kind: "infix", latexTrigger: ["\\vdash"], precedence: 220, associativity: "right", serialize: "\\vdash" }, { name: "Entails", kind: "infix", latexTrigger: ["\\vDash"], precedence: 220, associativity: "right", serialize: "\\vDash" }, { name: "Satisfies", kind: "infix", latexTrigger: ["\\models"], precedence: 220, associativity: "right", serialize: "\\models" }, { name: "ForAll", kind: "prefix", latexTrigger: ["\\forall"], precedence: 200, serialize: "\\forall", parse: Ot("ForAll") }, { name: "Exists", kind: "prefix", latexTrigger: ["\\exists"], precedence: 200, serialize: "\\exists", parse: Ot("Exists") }, { name: "ExistsUnique", kind: "prefix", latexTrigger: ["\\exists", "!"], precedence: 200, serialize: "\\exists!", parse: Ot("ExistsUnique") }, { name: "NotForAll", kind: "prefix", latexTrigger: ["\\lnot", "\\forall"], precedence: 200, serialize: "\\lnot\\forall", parse: Ot("NotForAll") }, { name: "NotExists", kind: "prefix", latexTrigger: ["\\lnot", "\\exists"], precedence: 200, serialize: "\\lnot\\exists", parse: Ot("NotExists") }, { name: "KroneckerDelta", kind: "prefix", latexTrigger: ["\\delta", "_"], precedence: 200, serialize: (e12, n) => {
  let i = N(n);
  return i.length === 0 ? "\\delta" : i.every((t) => A(t)) ? `\\delta_{${i.map((t) => e12.serialize(t)).join("")}}` : `\\delta_{${i.map((t) => e12.serialize(t)).join(", ")}}`;
}, parse: (e12) => {
  let n = e12.parseGroup();
  if (n === null) {
    let t = e12.parseToken();
    return t ? ["KroneckerDelta", t] : null;
  }
  let i = wn(n);
  return i && i.length <= 2 ? ["KroneckerDelta", ...i] : h(n) === "InvisibleOperator" ? ["KroneckerDelta", ...N(n)] : n !== null ? ["KroneckerDelta", n] : null;
} }, { name: "Boole", kind: "matchfix", openTrigger: "[", closeTrigger: "]", parse: (e12, n) => {
  let i = h(n);
  return !i || !ni.some((t) => t.name === i) ? null : ["Boole", n];
} }, { kind: "matchfix", openTrigger: "\\llbracket", closeTrigger: "\\rrbracket", parse: (e12, n) => {
  let i = h(n);
  return !i || !ni.some((t) => t.name === i) ? null : ["Boole", n];
} }];
function Ot(e12) {
  return (n, i) => {
    let t = n.index, r = n.parseSymbol(i);
    if (r) {
      if (n.skipSpace(), n.match(",") || n.match("\\mid") || n.match(".") || n.match(":") || n.match("\\colon")) {
        let a = n.parseExpression(i);
        return [e12, r, F(a)];
      }
      let o = n.parseEnclosure();
      if (o) return [e12, r, F(o)];
    }
    n.index = t;
    let s = n.parseExpression(i);
    if (s === null) return null;
    if (n.skipSpace(), n.matchAny([",", "\\mid", ":", "\\colon"])) {
      let o = n.parseExpression(i);
      return [e12, s, F(o)];
    }
    if (n.match("(")) {
      let o = n.parseExpression(i);
      return n.match(")") ? [e12, s, F(o)] : null;
    }
    return null;
  };
}
function Ce(e12) {
  return (n) => {
    let i = n.parseGroup();
    return i === null ? [e12] : [e12, i];
  };
}
var Uu = [{ name: "Overscript", latexTrigger: ["\\overset"], kind: "infix", precedence: 700 }, { name: "Underscript", latexTrigger: ["\\underset"], kind: "infix", precedence: 700 }, { name: "Increment", latexTrigger: ["+", "+"], kind: "postfix", precedence: 880, parse: (e12, n) => A(n) === null ? null : ["Decrement", n] }, { name: "Decrement", latexTrigger: ["-", "-"], kind: "postfix", precedence: 880, parse: (e12, n) => A(n) === null ? null : ["Decrement", n] }, { name: "PreIncrement", latexTrigger: ["+", "+"], kind: "prefix", precedence: 880, parse: (e12, n) => {
  let i = e12.parseExpression(n);
  return A(i) === null ? null : ["PreIncrement", i];
} }, { name: "PreDecrement", latexTrigger: ["-", "-"], kind: "prefix", precedence: 880, parse: (e12, n) => {
  let i = e12.parseExpression(n);
  return A(i) === null ? null : ["PreDecrement", i];
} }, { name: "Ring", latexTrigger: ["\\circ"], kind: "infix", precedence: 265 }, { name: "StringJoin", latexTrigger: ["\\lt", "\\gt"], kind: "infix", precedence: 780 }, { name: "Starstar", latexTrigger: ["\\star", "\\star"], kind: "infix", precedence: 780 }, { name: "PartialDerivative", latexTrigger: ["\\partial"], kind: "prefix", parse: (e12) => {
  var _a2, _b, _c2, _d2;
  let n = false, i = "Nothing", t = "Nothing";
  for (; !n; ) e12.skipSpace(), e12.match("_") ? t = (_a2 = e12.parseGroup()) != null ? _a2 : e12.parseToken() : e12.match("^") ? i = (_b = e12.parseGroup()) != null ? _b : e12.parseToken() : n = true;
  let r = wn(t);
  if (r && (t = ["List", ...r]), t === null || i === null) return null;
  let s = (_c2 = e12.parseGroup()) != null ? _c2 : "Nothing";
  if (!U(s)) {
    let o = (_d2 = e12.parseArguments()) != null ? _d2 : ["Nothing"];
    s = [s, ...o];
  }
  return ["PartialDerivative", s, t, i];
}, serialize: (e12, n) => {
  let i = "\\partial", t = d(n, 1), r = d(n, 2), s = d(n, 3);
  return r !== null && r !== "Nothing" && (h(r) === "List" ? i += "_{" + e12.serialize(["Sequence", ...N(r)]) + "}" : i += "_{" + e12.serialize(r) + "}"), s !== null && s !== "Nothing" && (i += "^{" + e12.serialize(s) + "}"), t !== null && t !== "Nothing" && (i += e12.serialize(t)), i;
}, precedence: 740 }, { name: "OverBar", latexTrigger: ["\\overline"], parse: Ce("OverBar") }, { name: "UnderBar", latexTrigger: ["\\underline"], parse: Ce("UnderBar") }, { name: "OverVector", latexTrigger: ["\\vec"], parse: Ce("OverVector") }, { name: "OverTilde", latexTrigger: ["\\tilde"], parse: Ce("OverTilde") }, { name: "OverHat", latexTrigger: ["\\hat"], parse: Ce("OverHat") }, { name: "OverRightArrow", latexTrigger: ["\\overrightarrow"], parse: Ce("OverRightArrow") }, { name: "OverLeftArrow", latexTrigger: ["\\overleftarrow"], parse: Ce("OverLeftArrow") }, { name: "OverRightDoubleArrow", latexTrigger: ["\\Overrightarrow"], parse: Ce("OverRightDoubleArrow") }, { name: "OverLeftHarpoon", latexTrigger: ["\\overleftharpoon"], parse: Ce("OverLeftHarpoon") }, { name: "OverRightHarpoon", latexTrigger: ["\\overrightharpoon"], parse: Ce("OverRightHarpoon") }, { name: "OverLeftRightArrow", latexTrigger: ["\\overleftrightarrow"], parse: Ce("OverLeftRightArrow") }, { name: "OverBrace", latexTrigger: ["\\overbrace"], parse: Ce("OverBrace") }, { name: "OverLineSegment", latexTrigger: ["\\overlinesegment"], parse: Ce("OverLineSegment") }, { name: "OverGroup", latexTrigger: ["\\overgroup"], parse: Ce("OverGroup") }, { latexTrigger: ["\\displaystyle"], parse: () => "Nothing" }, { latexTrigger: ["\\textstyle"], parse: () => "Nothing" }, { latexTrigger: ["\\scriptstyle"], parse: () => "Nothing" }, { latexTrigger: ["\\scriptscriptstyle"], parse: () => "Nothing" }, { latexTrigger: ["\\tiny"], parse: () => "Nothing" }, { latexTrigger: ["\\scriptsize"], parse: () => "Nothing" }, { latexTrigger: ["\\footnotesize"], parse: () => "Nothing" }, { latexTrigger: ["\\small"], parse: () => "Nothing" }, { latexTrigger: ["\\normalsize"], parse: () => "Nothing" }, { latexTrigger: ["\\large"], parse: () => "Nothing" }, { latexTrigger: ["\\Large"], parse: () => "Nothing" }, { latexTrigger: ["\\LARGE"], parse: () => "Nothing" }, { latexTrigger: ["\\huge"], parse: () => "Nothing" }, { latexTrigger: ["\\Huge"], parse: () => "Nothing" }, { name: "Style", serialize: (e12, n) => {
  let i = e12.serialize(d(n, 1)), t = zs(d(n, 2));
  if (t === null) return i;
  V(t.display) === "block" ? i = b(["{\\displaystyle", i, "}"]) : V(t.display) === "inline" ? i = b(["{\\textstyle", i, "}"]) : V(t.display) === "script" ? i = b(["{\\scriptstyle", i, "}"]) : V(t.display) === "scriptscript" && (i = b(["{\\scriptscriptstyle", i, "}"]));
  let r = D(t.size);
  return r !== null && r >= 1 && r <= 10 && (i = b(["{", { 1: "\\tiny", 2: "\\scriptsize", 3: "\\footnotesize", 4: "\\small", 5: "\\normalsize", 6: "\\large", 7: "\\Large", 8: "\\LARGE", 9: "\\huge", 10: "\\Huge" }[r], i, "}"])), i;
} }, { latexTrigger: ["\\!"], parse: () => ["HorizontalSpacing", -3] }, { latexTrigger: ["\\ "], parse: () => ["HorizontalSpacing", 6] }, { latexTrigger: ["\\:"], parse: () => ["HorizontalSpacing", 4] }, { latexTrigger: ["\\enskip"], parse: () => ["HorizontalSpacing", 9] }, { latexTrigger: ["\\quad"], parse: () => ["HorizontalSpacing", 18] }, { latexTrigger: ["\\qquad"], parse: () => ["HorizontalSpacing", 36] }, { latexTrigger: ["\\,"], parse: () => ["HorizontalSpacing", 3] }, { latexTrigger: ["\\;"], parse: () => ["HorizontalSpacing", 5] }, { latexTrigger: ["\\enspace"], parse: () => ["HorizontalSpacing", 9] }, { name: "HorizontalSpacing", serialize: (e12, n) => {
  var _a2;
  if (d(n, 2) !== null) return e12.serialize(d(n, 1));
  let i = D(d(n, 1));
  return i === null ? "" : (_a2 = { "-3": "\\!", 6: "\\ ", 3: "\\,", 4: "\\:", 5: "\\;", 9: "\\enspace", 18: "\\quad", 36: "\\qquad" }[i]) != null ? _a2 : "";
} }];
function T(e12) {
  return (n, i) => {
    var _a2, _b, _c2;
    let t = { "\\arcsin": "Arcsin", "\\arccos": "Arccos", "\\arctan": "Arctan", "\\arctg": "Arctan", "\\arcctg": "Arccot", "\\arcsec": "Arcsec", "\\arccsc": "Arccsc", "\\arsinh": "Arsinh", "\\arcosh": "Arccosh", "\\arccosh": "Arccosh", "\\artanh": "Arctanh", "\\arctanh": "Arctanh", "\\arsech": "Arcsech", "\\arcsech": "Arcsech", "\\arcsch": "Arccsch", "\\arccsch": "Arccsch", "\\ch": "Cosh", "\\cos": "Cos", "\\cosh": "Csch", "\\cosec": "Csc", "\\cot": "Cot", "\\cotg": "Cot", "\\ctg": "Cot", "\\csc": "Csc", "\\csch": "Csch", "\\coth": "Coth", "\\cth": "Coth", "\\sec": "Sec", "\\sech": "Sech", "\\sin": "Sin", "\\sinh": "Sinh", "\\sh": "Sinh", "\\tan": "Tan", "\\tg": "Tan", "\\tanh": "Tanh", "\\th": "Tanh" }, r = (_b = (_a2 = t[e12 != null ? e12 : ""]) != null ? _a2 : e12) != null ? _b : "";
    if (n.atTerminator(i)) return r;
    let s = r;
    do {
      let l = n.parsePostfixOperator(s, i);
      if (l === null) break;
      s = l;
    } while (true);
    n.skipSpace();
    let o = null;
    n.match("^") && (o = (_c2 = n.parseGroup()) != null ? _c2 : n.parseToken()), n.skipSpace();
    let a = n.parseArguments("implicit", { minPrec: 390, condition: (l) => {
      var _a3, _b2;
      return t[l.peek] || ((_b2 = (_a3 = i == null ? void 0 : i.condition) == null ? void 0 : _a3.call(i, l)) != null ? _b2 : false);
    } }), u = a === null ? s : typeof s == "string" ? [s, ...a] : ["Apply", s, ...a];
    return o === null ? u : ["Power", u, o];
  };
}
var ju = [{ name: "Arcsin", latexTrigger: ["\\arcsin"], parse: T("Arcsin") }, { name: "Arccos", latexTrigger: ["\\arccos"], parse: T("Arccos") }, { name: "Arctan", latexTrigger: ["\\arctan"], parse: T("Arctan") }, { latexTrigger: ["\\arctg"], parse: T("Arctan") }, { identifierTrigger: "arctg", parse: T("Arctan") }, { name: "Arccot", identifierTrigger: "arcctg", parse: T("Arccot") }, { latexTrigger: ["\\arcctg"], parse: T("Arccot") }, { name: "Arccoth", identifierTrigger: "arccoth", parse: T("Arccoth") }, { identifierTrigger: "arcoth", parse: T("Arccoth") }, { identifierTrigger: "arccoth", parse: T("Arccoth") }, { latexTrigger: ["\\arccoth"], parse: T("Arccoth") }, { name: "Arcsec", identifierTrigger: "arcsec", parse: T("Arcsec") }, { latexTrigger: ["\\arcsec"], parse: T("Arcsec") }, { name: "Arccsc", identifierTrigger: "arccsc", parse: T("Arccsc") }, { latexTrigger: ["\\arccsc"], parse: T("Arccsc") }, { name: "Arcsinh", identifierTrigger: "arcsinh", parse: T("Arcsinh") }, { latexTrigger: ["\\arsinh"], parse: T("Arcsinh") }, { latexTrigger: ["\\arcsinh"], parse: T("Arcsinh") }, { name: "Arccosh", identifierTrigger: "arccosh", parse: T("Arccosh") }, { latexTrigger: "\\arccosh", parse: T("Arccosh") }, { latexTrigger: "\\arcosh", parse: T("Arccosh") }, { identifierTrigger: "arcosh", parse: T("Arccosh") }, { name: "Arctanh", identifierTrigger: "arctanh", parse: T("Arctanh") }, { identifierTrigger: "artanh", parse: T("Arctanh") }, { latexTrigger: "\\artanh", parse: T("Arctanh") }, { latexTrigger: ["\\arctanh"], parse: T("Arctanh") }, { identifierTrigger: "artanh", parse: T("Arctanh") }, { name: "Arcsech", identifierTrigger: "arcsech", parse: T("Arcsech") }, { latexTrigger: ["\\arcsech"], parse: T("Arcsech") }, { latexTrigger: ["\\arsech"], parse: T("Arcsech") }, { name: "Arccsch", identifierTrigger: "arccsch", parse: T("Arccsch") }, { latexTrigger: ["\\arccsch"], parse: T("Arccsch") }, { latexTrigger: ["\\arcsch"], parse: T("Arccsch") }, { name: "Cosec", identifierTrigger: "cosec", parse: T("Cosec") }, { latexTrigger: ["\\cosec"], parse: T("Cosec") }, { name: "Cosh", latexTrigger: ["\\cosh"], parse: T("Cosh") }, { latexTrigger: ["\\ch"], parse: T("Cosh") }, { name: "Cot", latexTrigger: ["\\cot"], parse: T("Cot") }, { latexTrigger: ["\\cotg"], parse: T("Cot") }, { latexTrigger: ["\\ctg"], parse: T("Cot") }, { name: "Csc", latexTrigger: ["\\csc"], parse: T("Csc") }, { name: "Csch", latexTrigger: ["\\csch"], parse: T("Csch") }, { name: "Coth", latexTrigger: ["\\coth"], parse: T("Coth") }, { latexTrigger: ["\\cth"], parse: T("Coth") }, { identifierTrigger: "cth", parse: T("Coth") }, { latexTrigger: ["\\coth"], parse: T("Coth") }, { name: "Sec", latexTrigger: ["\\sec"], parse: T("Sec") }, { name: "Sech", identifierTrigger: "sech", parse: T("Sech") }, { latexTrigger: ["\\sech"], parse: T("Sech") }, { name: "Sinh", latexTrigger: ["\\sinh"], parse: T("Sinh") }, { latexTrigger: ["\\sh"], parse: T("Sinh") }, { name: "Tan", latexTrigger: ["\\tan"], parse: T("Tan") }, { latexTrigger: ["\\tg"], parse: T("Tan") }, { name: "Tanh", latexTrigger: ["\\tanh"], parse: T("Tanh") }, { latexTrigger: ["\\th"], parse: T("Tanh") }, { name: "Cos", latexTrigger: ["\\cos"], parse: T("Cos") }, { name: "Sin", latexTrigger: ["\\sin"], parse: T("Sin") }];
var Hu = [{ name: "AlgebraicNumbers", latexTrigger: "\\overline\\Q" }, { latexTrigger: "\\bar\\Q", parse: "AlgebraicNumbers" }, { name: "ComplexNumbers", latexTrigger: ["\\C"] }, { latexTrigger: "\\mathbb{C}", parse: "ComplexNumbers" }, { name: "ImaginaryNumbers", latexTrigger: ["\\imaginaryI", "\\R"] }, { name: "EmptySet", latexTrigger: ["\\emptyset"] }, { latexTrigger: ["\\varnothing"], parse: "EmptySet" }, { name: "Integers", latexTrigger: ["\\Z"] }, { latexTrigger: "\\mathbb{Z}", parse: "Integers" }, { name: "RationalNumbers", latexTrigger: ["\\Q"] }, { latexTrigger: "\\mathbb{Q}", parse: "RationalNumbers" }, { name: "RealNumbers", latexTrigger: ["\\R"] }, { latexTrigger: "\\mathbb{R}", parse: "RealNumbers" }, { name: "TranscendentalNumbers", latexTrigger: "\\R-\\bar\\Q" }, { latexTrigger: "\\R\\backslash\\bar\\Q", parse: "TranscendentalNumbers" }, { name: "NegativeNumbers", latexTrigger: "\\R_{<0}" }, { latexTrigger: "\\R^-", parse: "NegativeNumbers" }, { latexTrigger: "\\R^{-}", parse: "NegativeNumbers" }, { latexTrigger: "\\R^-", parse: "NegativeNumbers" }, { latexTrigger: "\\R_-", parse: "NegativeNumbers" }, { latexTrigger: "\\R_{-}", parse: "NegativeNumbers" }, { latexTrigger: "\\R^{\\lt}", parse: "NegativeNumbers" }, { latexTrigger: "\\R^{<}", parse: "NegativeNumbers" }, { latexTrigger: "\\R^{\\lt0}", parse: "NegativeNumbers" }, { latexTrigger: "\\R^{<0}", parse: "NegativeNumbers" }, { name: "NonPositiveNumbers", latexTrigger: "\\R_{\\le0}" }, { latexTrigger: "\\R^{\\leq0}", parse: "NonPositiveNumbers" }, { latexTrigger: "\\R^{-0}", parse: "NonPositiveNumbers" }, { latexTrigger: "\\R^{\\leq}", parse: "NonPositiveNumbers" }, { latexTrigger: "\\R^{0-}", parse: "NonPositiveNumbers" }, { name: "PositiveNumbers", latexTrigger: "\\R_{>0}" }, { latexTrigger: "\\R^+", parse: "PositiveNumbers" }, { latexTrigger: "\\R^{+}", parse: "PositiveNumbers" }, { latexTrigger: "\\R_+", parse: "PositiveNumbers" }, { latexTrigger: "\\R_{+}", parse: "PositiveNumbers" }, { latexTrigger: "\\R^{\\gt}", parse: "PositiveNumbers" }, { latexTrigger: "\\R^{\\gt 0}", parse: "PositiveNumbers" }, { latexTrigger: "\\R^{>}", parse: "PositiveNumbers" }, { latexTrigger: "\\R^{>0}", parse: "PositiveNumbers" }, { name: "NonNegativeNumbers", latexTrigger: "\\R_{\\geq0}" }, { latexTrigger: "\\R^{0+}", parse: "NonNegativeNumbers" }, { latexTrigger: "\\R^{\\geq}", parse: "NonNegativeNumbers" }, { name: "ExtendedRealNumbers", latexTrigger: "\\overline\\R" }, { latexTrigger: "\\bar\\R", parse: "ExtendedRealNumbers" }, { name: "NegativeIntegers", latexTrigger: "\\Z_{<0}" }, { latexTrigger: "\\Z_{\\lt0}", parse: "NegativeIntegers" }, { latexTrigger: "\\Z^-", parse: "NegativeIntegers" }, { latexTrigger: "\\Z^{-}", parse: "NegativeIntegers" }, { latexTrigger: "\\Z_-", parse: "NegativeIntegers" }, { latexTrigger: "\\Z_{-}", parse: "NegativeIntegers" }, { latexTrigger: "\\Z^{\\lt}", parse: "NegativeIntegers" }, { name: "NonPositiveIntegers", latexTrigger: "\\Z_{\\le0}" }, { latexTrigger: "\\Z_{\\leq0}", parse: "NonPositiveIntegers" }, { latexTrigger: "\\Z_{<0}", parse: "NonPositiveIntegers" }, { name: "PositiveIntegers", latexTrigger: "\\N^*" }, { latexTrigger: "\\Z_{>0}", parse: "PositiveIntegers" }, { latexTrigger: "\\Z_{\\gt0}", parse: "PositiveIntegers" }, { latexTrigger: "\\Z^{+}", parse: "PositiveIntegers" }, { latexTrigger: "\\Z_+", parse: "PositiveIntegers" }, { latexTrigger: "\\Z_{+}", parse: "PositiveIntegers" }, { latexTrigger: "\\Z^{\\gt}", parse: "PositiveIntegers" }, { latexTrigger: "\\Z^{\\gt0}", parse: "PositiveIntegers" }, { latexTrigger: "\\N^+", parse: "PositiveIntegers" }, { latexTrigger: "\\N^{+}", parse: "PositiveIntegers" }, { latexTrigger: "\\N^*", parse: "PositiveIntegers" }, { latexTrigger: "\\N^{*}", parse: "PositiveIntegers" }, { latexTrigger: "\\N^\\star", parse: "PositiveIntegers" }, { latexTrigger: "\\N^{\\star}", parse: "PositiveIntegers" }, { latexTrigger: "\\N_1", parse: "PositiveIntegers" }, { latexTrigger: "\\N_{1}", parse: "PositiveIntegers" }, { name: "NonNegativeIntegers", latexTrigger: ["\\N"] }, { latexTrigger: "\\Z^{+0}", parse: "NonNegativeIntegers" }, { latexTrigger: "\\Z^{\\geq}", parse: "NonNegativeIntegers" }, { latexTrigger: "\\Z^{\\geq0}", parse: "NonNegativeIntegers" }, { latexTrigger: "\\Z^{0+}", parse: "NonNegativeIntegers" }, { latexTrigger: "\\mathbb{N}", parse: "NonNegativeIntegers" }, { latexTrigger: "\\N_0", parse: "NonNegativeIntegers" }, { latexTrigger: "\\N_{0}", parse: "NonNegativeIntegers" }, { name: "ExtendedIntegers", latexTrigger: "\\overline\\Z" }, { latexTrigger: "\\bar\\Z", parse: "ExtendedIntegers" }, { name: "ExtendedRationalNumbers", latexTrigger: "\\overline\\Q" }, { latexTrigger: "\\bar\\Q", parse: "ExtendedRationalNumbers" }, { name: "ExtendedComplexNumbers", latexTrigger: "\\overline\\C" }, { latexTrigger: "\\bar\\C", parse: "ExtendedComplexNumbers" }, { latexTrigger: ["^", "\\complement"], kind: "postfix", parse: (e12, n) => ["Complement", n] }, { name: "Complement", latexTrigger: ["^", "<{>", "\\complement", "<}>"], kind: "postfix" }, { name: "Intersection", latexTrigger: ["\\cap"], kind: "infix", precedence: 350 }, { name: "Interval", serialize: Zu }, { name: "Multiple", serialize: Zu }, { name: "Union", latexTrigger: ["\\cup"], kind: "infix", precedence: 350 }, { name: "Set", kind: "matchfix", openTrigger: "{", closeTrigger: "}", parse: (e12, n) => U(n) ? "EmptySet" : (h(n) == "Delimiter" && V(d(n, 2)) === "," && (n = d(n, 1)), h(n) !== "Sequence" ? ["Set", n] : ["Set", ...N(n)]), serialize: (e12, n) => b(["\\lbrace", N(n).map((i) => e12.serialize(i)).join(", "), "\\rbrace"]) }, { name: "SetMinus", latexTrigger: ["\\setminus"], kind: "infix", precedence: 650 }, { name: "SymmetricDifference", latexTrigger: ["\\triangle"], kind: "infix", precedence: 245 }, { latexTrigger: ["\\ni"], kind: "infix", associativity: "none", precedence: 160, parse: (e12, n, i) => {
  let t = e12.parseExpression(i);
  return t === null ? null : ["Element", t, n];
} }, { name: "Element", latexTrigger: ["\\in"], kind: "infix", precedence: 240 }, { name: "NotElement", latexTrigger: ["\\notin"], kind: "infix", precedence: 240 }, { name: "NotSubset", latexTrigger: ["\\nsubset"], kind: "infix", associativity: "none", precedence: 240 }, { name: "NotSuperset", latexTrigger: ["\\nsupset"], kind: "infix", associativity: "none", precedence: 240 }, { name: "NotSubsetNotEqual", latexTrigger: ["\\nsubseteq"], kind: "infix", associativity: "none", precedence: 240 }, { name: "NotSupersetNotEqual", latexTrigger: ["\\nsupseteq"], kind: "infix", associativity: "none", precedence: 240 }, { name: "SquareSubset", latexTrigger: ["\\sqsubset"], kind: "infix", associativity: "none", precedence: 265 }, { name: "SquareSubsetEqual", latexTrigger: ["\\sqsubseteq"], kind: "infix", associativity: "none", precedence: 265 }, { name: "SquareSuperset", latexTrigger: ["\\sqsupset"], kind: "infix", associativity: "none", precedence: 265 }, { name: "SquareSupersetEqual", latexTrigger: ["\\sqsupseteq"], kind: "infix", associativity: "none", precedence: 265 }, { name: "Subset", latexTrigger: ["\\subset"], kind: "infix", associativity: "none", precedence: 240 }, { latexTrigger: ["\\subsetneq"], kind: "infix", associativity: "none", precedence: 240, parse: "Subset" }, { latexTrigger: ["\\varsubsetneqq"], kind: "infix", associativity: "none", precedence: 240, parse: "Subset" }, { name: "SubsetEqual", latexTrigger: ["\\subseteq"], kind: "infix", associativity: "none", precedence: 240 }, { name: "Superset", latexTrigger: ["\\supset"], kind: "infix", associativity: "none", precedence: 240 }, { latexTrigger: ["\\supsetneq"], kind: "infix", associativity: "none", precedence: 240, parse: "Superset" }, { latexTrigger: ["\\varsupsetneq"], kind: "infix", associativity: "none", precedence: 240, parse: "Superset" }, { name: "SupersetEqual", latexTrigger: ["\\supseteq"], kind: "infix", associativity: "none", precedence: 240 }];
function Zu(e12, n) {
  if (n === null) return "";
  let i = h(n);
  if (!i) return "";
  if (i === "Set") return Y(n) === 0 ? "\\emptyset" : Y(n) === 2 && h(d(n, 2)) === "Condition" ? b(["\\left\\lbrace", e12.serialize(d(n, 1)), "\\middle\\mid", e12.serialize(d(n, 2)), "\\right\\rbrace"]) : b(["\\left\\lbrace", ...N(n).map((r) => e12.serialize(r) + " ,"), "\\right\\rbrace"]);
  if (i === "Range") return b(["\\mathopen\\lbrack", e12.serialize(d(n, 1)), ", ", e12.serialize(d(n, 2)), "\\mathclose\\rbrack"]);
  if (i === "Interval") {
    let r = d(n, 1), s = d(n, 2), o = false, a = false;
    return h(r) === "Open" && (r = d(r, 1), o = true), h(s) === "Open" && (s = d(s, 1), a = true), b([`\\mathopen${o ? "\\rbrack" : "\\lbrack"}`, e12.serialize(r), ", ", e12.serialize(s), `\\mathclose${a ? "\\lbrack" : "\\rbrack"}`]);
  }
  let t = e12.numericSetStyle(n, e12.level);
  return "";
}
function Zi(e12, n = 1) {
  return (i) => {
    var _a2, _b;
    i.skipSpace(), i.match("\\limits"), i.skipSpace();
    let t = null, r = null;
    for (; !(r !== null && t !== null) && (i.peek === "_" || i.peek === "^"); ) i.match("_") ? r = (_a2 = i.parseGroup()) != null ? _a2 : i.parseToken() : i.match("^") && (t = (_b = i.parseGroup()) != null ? _b : i.parseToken()), i.skipSpace();
    U(r) && (r = null), U(t) && (t = null);
    let [s, o] = ed(i, n);
    if (s && !o) {
      if (h(s) === "Add" || h(s) === "Subtract") {
        let a = [], u = [];
        for (let l of N(s)) if (o) u.push(l);
        else {
          let f;
          [f, o] = yn(l), a.push(f != null ? f : l);
        }
        if (o !== null && u.length > 0) return ["Add", Wu(i, e12, ["Add", ...a], [{ index: o, sub: r, sup: t }]), ...u];
      } else if (h(s) === "Divide") {
        let a;
        [a, o] = yn(d(s, 1)), a !== null && o !== null && (s = ["Divide", a, d(s, 2)]);
      }
    }
    return Wu(i, e12, s, [{ index: o, sub: r, sup: t }]);
  };
}
function Wu(e12, n, i, t) {
  if (i && t.length === 0) return [n, i];
  i != null ? i : i = "Nothing", e12.pushSymbolTable();
  for (let r of t) r.index && e12.addSymbol(r.index, "symbol");
  return e12.popSymbolTable(), [n, i, ...t.map((r) => Kp(r))];
}
function Kp(e12) {
  var _a2;
  let n = e12.index ? ["Hold", e12.index] : "Nothing";
  return e12.sup !== null ? ["Tuple", n, (_a2 = e12.sub) != null ? _a2 : "Nothing", e12.sup] : e12.sub !== null ? ["Tuple", n, e12.sub] : n;
}
function ed(e12, n = 1) {
  var _a2;
  let i = e12.index, t = false, r = e12.parseExpression({ minPrec: 266, condition: () => {
    let o = e12.index;
    for (; e12.match("\\cdot") || e12.match("\\,"); ) ;
    return (e12.matchAll(["\\mathrm", "<{>", "d", "<}>"]) || e12.matchAll(["\\operatorname", "<{>", "d", "<}>"])) && (t = true), t || (e12.index = o), t;
  } });
  if (t || (e12.index = i, r = e12.parseExpression({ minPrec: 266, condition: () => {
    for (; e12.match("\\cdot") || e12.match("\\,"); ) ;
    return (e12.match("d") || e12.match("\\differentialD")) && (t = true), t;
  } })), r !== null && !t) return yn(r);
  let s = nd(e12, n);
  return [r, (_a2 = s[0]) != null ? _a2 : null];
}
function nd(e12, n = 1) {
  e12.skipSpace();
  let i = [], t = A(e12.parseSymbol());
  return t === null ? [] : (i.push(t), i);
}
function yn(e12) {
  let n = h(e12), i = d(e12, 1);
  if (!i) return [e12, null];
  if (n === "Sequence" && Y(e12) === 1) return yn(i);
  if (n === "Multiply" || n === "InvisibleOperator") {
    let t = N(e12);
    if (t && t.length > 1) {
      let r = A(t[t.length - 2]);
      if (r === "d" || r === "d_upright") return t.length === 2 ? [null, A(t[1])] : t.length === 3 ? [t[0], A(t[2])] : [["Multiply", ...t.slice(0, -2)], A(t[t.length - 1])];
      let [s, o] = yn(t[t.length - 1]);
      if (s) return [["Multiply", ...t.slice(0, -1), s], o];
    }
  } else if (n === "Delimiter") {
    let [t, r] = yn(i);
    if (r) return t ? [["Delimiter", ["Sequence", t], ...N(e12).slice(1)], r] : [null, r];
  } else if (n === "Add") {
    let t = N(e12);
    if (t.length > 0) {
      let [r, s] = yn(t[t.length - 1]);
      if (s) {
        if (r) return [["Add", ...t.slice(0, -1), r], s];
        if (t.length > 2) return [["Add", ...t.slice(0, -1)], s];
        if (t.length > 2) return [t[0], s];
      }
    }
  } else if (n === "Negate") {
    let [t, r] = yn(i);
    if (r) return [t ? ["Negate", t] : null, r];
  } else if (n === "Divide") {
    let [t, r] = yn(i);
    if (r) return [["Divide", t != null ? t : 1, d(e12, 2)], r];
  } else {
    let t = N(e12);
    if (t.length === 1) {
      let [r, s] = yn(t[0]);
      if (s) return [[h(e12), r], s];
    }
  }
  return [e12, null];
}
function Ju(e12) {
  return (n, i) => {
    var _a2;
    if (!d(i, 1)) return e12;
    let t = d(i, 2), r = h(t), s = null;
    r === "Tuple" || r === "Triple" || r === "Pair" || r === "Single" ? s = d(t, 1) : r === "Hold" ? s = d(t, 1) : (s = (_a2 = d(t, 1)) != null ? _a2 : "x", t = null), h(s) === "Hold" && (s = d(s, 1));
    let o = s !== null ? A(s) : null, a = d(i, 1);
    if (h(a) === "Lambda" && d(a, 1) !== null && (a = Br(d(a, 1), { _: o != null ? o : "x", _1: o != null ? o : "x" })), !t) return !o || o === "Nothing" ? b([e12, "\\!", n.serialize(a)]) : b([e12, "\\!", n.serialize(a), "\\,\\operatorname{d}", n.serialize(o)]);
    let u = d(t, 2) ? A(d(t, 2)) : null, l = t && u !== "Nothing" ? n.serialize(d(t, 2)) : "";
    l.length > 0 && (l = `_{${l}}`);
    let f = "", c = d(t, 3) ? A(d(t, 3)) : null;
    return d(t, 3) !== null && c !== "Nothing" && (f = `^{${n.serialize(d(t, 3))}}`), b([e12, f, l, "\\!", n.serialize(a), ...o && A(o) !== "Nothing" ? ["\\,\\operatorname{d}", n.serialize(o)] : []]);
  };
}
var Yu = [{ kind: "expression", name: "Integrate", latexTrigger: ["\\int"], parse: Zi("Integrate"), serialize: Ju("\\int") }, { kind: "expression", latexTrigger: ["\\iint"], parse: Zi("Integrate", 2) }, { kind: "expression", latexTrigger: ["\\iiint"], parse: Zi("Integrate", 3) }, { kind: "expression", name: "CircularIntegrate", latexTrigger: ["\\oint"], parse: Zi("CircularIntegrate"), serialize: Ju("\\oint") }, { kind: "expression", latexTrigger: ["\\oiint"], parse: Zi("CircularIntegrate", 2) }, { kind: "expression", latexTrigger: ["\\oiiint"], parse: Zi("CircularIntegrate", 3) }];
var sn = [["alpha", "\\alpha", 945], ["beta", "\\beta", 946], ["gamma", "\\gamma", 947], ["delta", "\\delta", 948], ["epsilon", "\\epsilon", 949], ["epsilonSymbol", "\\varepsilon", 1013], ["zeta", "\\zeta", 950], ["eta", "\\eta", 951], ["theta", "\\theta", 952], ["thetaSymbol", "\\vartheta", 977], ["iota", "\\iota", 953], ["kappa", "\\kappa", 954], ["kappaSymbol", "\\varkappa", 1008], ["lambda", "\\lambda", 955], ["mu", "\\mu", 956], ["nu", "\\nu", 957], ["xi", "\\xi", 958], ["omicron", "\\omicron", 959], ["pi", "\\pi", 960], ["piSymbol", "\\varpi", 982], ["rho", "\\rho", 961], ["rhoSymbol", "\\varrho", 1009], ["sigma", "\\sigma", 963], ["finalSigma", "\\varsigma", 962], ["tau", "\\tau", 964], ["phi", "\\phi", 981], ["phiLetter", "\\varphi", 966], ["upsilon", "\\upsilon", 965], ["chi", "\\chi", 967], ["psi", "\\psi", 968], ["omega", "\\omega", 969], ["Alpha", "\\Alpha", 913], ["Beta", "\\Beta", 914], ["Gamma", "\\Gamma", 915], ["Delta", "\\Delta", 916], ["Epsilon", "\\Epsilon", 917], ["Zeta", "\\Zeta", 918], ["Eta", "\\Eta", 919], ["Theta", "\\Theta", 920], ["Iota", "\\Iota", 921], ["Kappa", "\\Kappa", 922], ["Lambda", "\\Lambda", 923], ["Mu", "\\Mu", 924], ["Nu", "\\Nu", 925], ["Xi", "\\Xi", 926], ["Omicron", "\\Omicron", 927], ["Rho", "\\Rho", 929], ["Sigma", "\\Sigma", 931], ["Tau", "\\Tau", 932], ["Phi", "\\Phi", 934], ["Upsilon", "\\Upsilon", 933], ["Chi", "\\Chi", 935], ["Psi", "\\Psi", 936], ["Omega", "\\Omega", 937], ["digamma", "\\digamma", 989], ["aleph", "\\aleph", 8501], ["bet", "\\beth", 8502], ["gimel", "\\gimel", 8503], ["dalet", "\\daleth", 8504], ["ell", "\\ell", 8499], ["turnedCapitalF", "\\Finv", 8498], ["turnedCapitalG", "\\Game", 8513], ["weierstrass", "\\wp", 8472], ["eth", "\\eth", 240], ["invertedOhm", "\\mho", 8487], ["hBar", "\\hbar", 295], ["hSlash", "\\hslash", 8463], ["blackClubSuit", "\\clubsuit", 9827], ["whiteHeartSuit", "\\heartsuit", 9825], ["blackSpadeSuit", "\\spadesuit", 9824], ["whiteDiamondSuit", "\\diamondsuit", 9826], ["sharp", "\\sharp", 9839], ["flat", "\\flat", 9837], ["natural", "\\natural", 9838]];
var Qu = [...sn.map(([e12, n, i]) => ({ kind: "symbol", name: e12, latexTrigger: [n], parse: e12 })), ...sn.map(([e12, n, i]) => ({ kind: "symbol", latexTrigger: [String.fromCodePoint(i)], parse: e12 }))];
var Xu = [{ name: "Real", kind: "function", latexTrigger: ["\\Re"] }, { name: "Imaginary", kind: "function", latexTrigger: ["\\Im"] }, { name: "Argument", kind: "function", latexTrigger: ["\\arg"] }, { name: "Conjugate", latexTrigger: ["^", "\\star"], kind: "postfix" }];
var Ku = [{ name: "Mean", kind: "function", identifierTrigger: "mean" }, { name: "Median", kind: "function", identifierTrigger: "median" }, { name: "StandarDeviation", kind: "function", identifierTrigger: "stddev" }, { latexTrigger: ["\\bar"], kind: "expression", parse: (e12, n) => {
  var _a2;
  let i = (_a2 = e12.parseGroup()) != null ? _a2 : e12.parseToken();
  return !i || !A(i) ? null : ["Mean", i];
} }];
var el = { "(": "(", ")": ")", "[": "\\lbrack", "]": "\\rbrack", "{": "\\lbrace", "}": "\\rbrace", "<": "\\langle", ">": "\\rangle", "|": "\\vert", "||": "\\Vert", "\\lceil": "\\lceil", "\\lfloor": "\\lfloor", "\\rceil": "\\rceil", "\\rfloor": "\\rfloor" };
function nl(e12, n, i) {
  let t = id(n, i);
  if (t === null) return;
  let r = "kind" in n ? n.kind : "expression", s = t.latexTrigger;
  typeof s == "string" && (e12.lookahead = Math.max(e12.lookahead, yr(s)));
  let o = de(s != null ? s : "");
  if (o.length === 2 && /[_^]/.test(o[0]) && o[1] !== "<{>" && r !== "function" && r !== "environment" && r !== "matchfix") {
    let a = n.parse;
    !a && n.name && (r === "postfix" || r === "prefix" ? a = (u, l) => [n.name, l] : a = n.name), nl(e12, { ...n, kind: r, name: void 0, serialize: void 0, parse: a, latexTrigger: [o[0], "<{>", o[1], "<}>"] }, i);
  }
  e12.defs.push(t), t.name !== void 0 && (e12.ids.has(t.name) && i({ severity: "warning", message: ["invalid-dictionary-entry", t.name, "Duplicate definition. The name (MathJSON identifier) must be unique, but triggers can be shared by multiple definitions."] }), e12.ids.set(t.name, t));
}
function to(e12, n) {
  let i = { lookahead: 1, ids: /* @__PURE__ */ new Map(), defs: [] };
  for (let t of e12) nl(i, t, n);
  return i;
}
function id(e12, n) {
  var _a2, _b, _c2, _d2, _e2;
  if (!sd(e12, n)) return null;
  let i = { kind: "kind" in e12 ? e12.kind : "expression" }, t = null;
  "latexTrigger" in e12 && (typeof e12.latexTrigger == "string" ? t = de(e12.latexTrigger) : t = e12.latexTrigger);
  let r = null;
  "identifierTrigger" in e12 && (r = e12.identifierTrigger), t !== null && (i.latexTrigger = tn(t)), r !== null && (i.identifierTrigger = r), e12.name && (i.name = e12.name, i.serialize = td(e12, t, r)), i.kind === "matchfix" && bt(e12) && (i.openTrigger = e12.openTrigger, i.closeTrigger = e12.closeTrigger), i.kind === "symbol" && za(e12) && (i.precedence = (_a2 = e12.precedence) != null ? _a2 : 1e4), i.kind === "expression" && Va(e12) && (i.precedence = (_b = e12.precedence) != null ? _b : 1e4), (i.kind === "prefix" || i.kind === "postfix") && (br(e12) || _s(e12)) && (t && (t[0] === "^" || t[0] === "_") ? (i.precedence = 720, e12.precedence) : i.precedence = (_c2 = e12.precedence) != null ? _c2 : 1e4), i.kind === "infix" && Ss(e12) && (!t || t[0] !== "^" && t[0] !== "_" || !e12.associativity || e12.associativity, i.associativity = (_d2 = e12.associativity) != null ? _d2 : "none", i.precedence = (_e2 = e12.precedence) != null ? _e2 : 1e4);
  let s = rd(e12, t, r);
  return s && (i.parse = s), i;
}
function td(e12, n, i) {
  var _a2, _b, _c2, _d2;
  if (typeof e12.serialize == "function") return e12.serialize;
  let t = (_a2 = e12.kind) != null ? _a2 : "expression";
  if (t === "environment") {
    let o = (_c2 = (_b = e12.identifierTrigger) != null ? _b : e12.name) != null ? _c2 : "unknown";
    return (a, u) => b([`\\begin{${o}}`, a.serialize(d(u, 1)), `\\end{${o}}`]);
  }
  if (bt(e12)) {
    let o = typeof e12.openTrigger == "string" ? el[e12.openTrigger] : tn(e12.openTrigger), a = typeof e12.closeTrigger == "string" ? el[e12.closeTrigger] : tn(e12.closeTrigger);
    return (u, l) => b([o, u.serialize(d(l, 1)), a]);
  }
  let r = e12.serialize;
  if (r === void 0 && n && (r = tn(n)), r) return t === "postfix" ? (o, a) => b([o.serialize(d(a, 1)), r]) : t === "prefix" ? (o, a) => b([r, o.serialize(d(a, 1))]) : t === "infix" ? (o, a) => {
    var _a3;
    let u = Y(a);
    if (u === 0) return "";
    let l = (_a3 = e12.precedence) != null ? _a3 : 1e4;
    return b(N(a).flatMap((f, c) => {
      let p = o.wrap(f, l + 1);
      return c < u - 1 ? [p, r] : [p];
    }));
  } : (o, a) => h(a) ? b([r, o.wrapArguments(a)]) : r;
  let s = (_d2 = i != null ? i : e12.name) != null ? _d2 : "unknown";
  return t === "postfix" ? (o, a) => b([o.serialize(d(a, 1)), o.serializeSymbol(s)]) : t === "prefix" ? (o, a) => b([o.serializeSymbol(s), o.serialize(d(a, 1))]) : t === "infix" ? (o, a) => b([o.serialize(d(a, 1)), o.serializeSymbol(s), o.serialize(d(a, 2))]) : (o, a) => h(a) ? b([o.serializeSymbol(s), o.wrapArguments(a)]) : o.serializeSymbol(s);
}
function rd(e12, n, i) {
  var _a2, _b, _c2, _d2, _e2, _f2, _g, _h, _i2, _j, _k, _l2, _m2, _n2, _o2, _p2, _q, _r2, _s2, _t2;
  if ("parse" in e12 && typeof e12.parse == "function") return e12.parse;
  let t = (_a2 = "kind" in e12 ? e12.kind : "expression") != null ? _a2 : "expression";
  if (t === "environment") {
    let r = (_c2 = (_b = e12.parse) != null ? _b : e12.name) != null ? _c2 : i;
    if (r) return (s, o) => {
      let a = s.parseTabular();
      return a === null ? null : [r, ["List", a.map((u) => ["List", ...u])]];
    };
  }
  if (t === "function") {
    let r = (_e2 = (_d2 = e12.parse) != null ? _d2 : e12.name) != null ? _e2 : i;
    if (r) return (s, o) => {
      let a = s.parseArguments("enclosure", o);
      return a === null ? r : [r, ...a];
    };
  }
  if (t === "symbol") {
    let r = (_g = (_f2 = e12.parse) != null ? _f2 : e12.name) != null ? _g : i;
    if (r) return (s, o) => r;
  }
  if (t === "prefix") {
    let r = (_i2 = (_h = e12.parse) != null ? _h : e12.name) != null ? _i2 : i;
    if (r) {
      let s = (_j = e12.precedence) != null ? _j : 1e4;
      return (o, a) => {
        let u = o.parseExpression({ ...a != null ? a : [], minPrec: s });
        return u === null ? null : [r, u];
      };
    }
  }
  if (t === "postfix") {
    let r = (_k = e12.parse) != null ? _k : e12.name;
    if (r) return (s, o) => o === null ? null : [r, o];
  }
  if (t === "infix") {
    if (/[_^]/.test((_l2 = n == null ? void 0 : n[0]) != null ? _l2 : "")) {
      let s = (_m2 = e12.name) != null ? _m2 : e12.parse;
      return (o, a) => [s, F(d(a, 1)), F(d(a, 2))];
    }
    let r = (_o2 = (_n2 = e12.parse) != null ? _n2 : e12.name) != null ? _o2 : i;
    if (r) {
      let s = (_p2 = e12.precedence) != null ? _p2 : 1e4, o = (_q = e12.associativity) != null ? _q : "none";
      return o === "none" ? (a, u, l) => {
        if (u === null) return null;
        let f = F(a.parseExpression({ ...l, minPrec: s }));
        return [r, u, f];
      } : o === "left" ? (a, u, l) => {
        if (u === null) return null;
        let f = F(a.parseExpression({ ...l, minPrec: s + 1 }));
        return typeof r != "string" ? [r, u, f] : [r, u, f];
      } : o === "right" ? (a, u, l) => {
        if (u === null) return null;
        let f = F(a.parseExpression({ ...l, minPrec: s }));
        return typeof r != "string" ? [r, u, f] : [r, u, f];
      } : (a, u, l) => {
        if (u === null) return null;
        let f = F(a.parseExpression({ ...l, minPrec: s }));
        return typeof r != "string" ? [r, u, f] : $i(r, u, f);
      };
    }
  }
  if (t === "matchfix") {
    let r = (_r2 = e12.parse) != null ? _r2 : e12.name;
    if (r) return (s, o) => U(o) ? null : [r, o];
  }
  if (t === "expression") {
    let r = (_t2 = (_s2 = e12.parse) != null ? _s2 : e12.name) != null ? _t2 : i;
    if (r) return () => r;
  }
  if ("parse" in e12) {
    let r = e12.parse;
    return () => r;
  }
}
function sd(e12, n) {
  var _a2, _b, _c2;
  let i = (_c2 = (_b = (_a2 = e12.name) != null ? _a2 : e12.latexTrigger) != null ? _b : e12.identifierTrigger) != null ? _c2 : e12.openTrigger;
  if (!i) try {
    i = JSON.stringify(e12);
  } catch (e13) {
    i = "???";
  }
  if (Array.isArray(i) && (i = tn(i)), "trigger" in e12 && n({ severity: "warning", message: ["invalid-dictionary-entry", i, "The 'trigger' property is deprecated. Use 'latexTrigger' or 'identifierTrigger' instead"] }), "kind" in e12 && !["expression", "symbol", "function", "infix", "postfix", "prefix", "matchfix", "environment"].includes(e12.kind) && n({ severity: "warning", message: ["invalid-dictionary-entry", i, "The 'kind' property must be one of 'expression', 'symbol', 'function', 'infix', 'postfix', 'prefix', 'matchfix', 'environment'"] }), e12.serialize !== void 0 && !e12.name) return n({ severity: "warning", message: ["invalid-dictionary-entry", i, "A 'name' property must be provided if a 'serialize' handler is provided"] }), false;
  if ("identifierTrigger" in e12 && (!("kind" in e12) || e12.kind !== "environment") && (typeof e12.identifierTrigger != "string" || !xe(e12.identifierTrigger)) && n({ severity: "warning", message: ["invalid-dictionary-entry", i, "The 'identifierTrigger' property must be a valid identifier"] }), "name" in e12 && (typeof e12.name != "string" ? e12.name !== void 0 && n({ severity: "warning", message: ["invalid-dictionary-entry", i, "The 'name' property must be a string"] }) : xe(e12.name) || n({ severity: "warning", message: ["invalid-dictionary-entry", e12.name, "The 'name' property must be a valid identifier"] })), bt(e12)) {
    if ("latexTrigger" in e12 || "identifierTrigger" in br) return n({ severity: "warning", message: ["invalid-dictionary-entry", i, "'matchfix' operators use a 'openTrigger' and 'closeTrigger' instead of a 'latexTrigger' or 'identifierTrigger'. "] }), false;
    if (!e12.openTrigger || !e12.closeTrigger) return n({ severity: "warning", message: ["invalid-dictionary-entry", i, "Expected `openTrigger` and a `closeTrigger` for matchfix operator"] }), false;
    if (typeof e12.openTrigger != typeof e12.closeTrigger) return n({ severity: "warning", message: ["invalid-dictionary-entry", i, "Expected `openTrigger` and `closeTrigger` to both be strings or array of LatexToken"] }), false;
  }
  if (Ss(e12) || _s(e12) || br(e12)) {
    if (Array.isArray(e12.latexTrigger) && (e12.latexTrigger[0] === "_" || e12.latexTrigger[0] === "^") || typeof e12.latexTrigger == "string" && (e12.latexTrigger.startsWith("^") || e12.latexTrigger.startsWith("_"))) {
      if (e12.precedence !== void 0 || e12.associativity !== void 0) return n({ severity: "warning", message: ["invalid-dictionary-entry", i, 'Unexpected "precedence" or "associativity" for superscript/subscript operator'] }), false;
    } else if (e12.precedence === void 0) return n({ severity: "warning", message: ["invalid-dictionary-entry", i, `Expected a "precedence" for ${e12.kind} operator`] }), false;
  } else if (e12.associativity !== void 0) return n({ severity: "warning", message: ["invalid-dictionary-entry", i, 'Unexpected "associativity" operator'] }), false;
  return !bt(e12) && !Ga(e12) && !e12.latexTrigger && !e12.identifierTrigger && !e12.name ? (n({ severity: "warning", message: ["invalid-dictionary-entry", i, "Expected a 'name', a 'latexTrigger' or a 'identifierTrigger'"] }), false) : e12.parse === void 0 && e12.name === void 0 ? (n({ severity: "warning", message: ["invalid-dictionary-entry", i, "Expected a 'parse' or 'name'"] }), false) : true;
}
var Lt = { symbols: Qu, algebra: Tu, arithmetic: Fu, calculus: Yu, complex: Xu, core: qu, "linear-algebra": zu, logic: Gu, relop: ni, other: Uu, physics: [{ name: "mu0", kind: "symbol", latexTrigger: "\\mu_0" }], sets: Hu, statistics: Ku, trigonometry: ju };
function il(e12 = "all") {
  if (e12 === "all") {
    let n = [];
    for (let i of Object.keys(Lt)) Lt[i] && n.push(...Lt[i]);
    return n;
  }
  return Lt[e12] ? Object.freeze([...Lt[e12]]) : [];
}
function Or(e12, n) {
  switch (n) {
    case "float64":
    case "float32":
    case "int32":
    case "uint8":
      return new ro(e12);
    case "complex128":
    case "complex64":
      return new oo(e12);
    case "bool":
    case "string":
    case "expression":
      return new so(e12);
  }
  throw new Error(`Unknown dtype ${n}`);
}
var ro = class {
  constructor(n) {
    this.ce = n;
    this.one = 1;
    this.zero = 0;
    this.nan = NaN;
  }
  cast(n, i) {
    let t = this.ce;
    switch (i) {
      case "float64":
      case "float32":
      case "int32":
      case "uint8":
        return n;
      case "complex128":
      case "complex64":
        return Array.isArray(n) ? n.map((r) => t.complex(r)) : this.ce.complex(n);
      case "bool":
        return Array.isArray(n) ? n.map((r) => r !== 0) : n !== 0;
      case "string":
        return Array.isArray(n) ? n.map((r) => Number(r).toString()) : Number(n).toString();
      case "expression":
        return Array.isArray(n) ? n.map((r) => t.number(r)) : t.number(n);
    }
    throw new Error(`Cannot cast ${n} to ${i}`);
  }
  expression(n) {
    return this.ce.number(n);
  }
  isZero(n) {
    return n === 0;
  }
  isOne(n) {
    return n === 1;
  }
  equals(n, i) {
    return n === i;
  }
  add(n, i) {
    return n + i;
  }
  addn(...n) {
    return n.reduce((i, t) => i + t, 0);
  }
  neg(n) {
    return -n;
  }
  sub(n, i) {
    return n - i;
  }
  mul(n, i) {
    return n * i;
  }
  muln(...n) {
    return n.reduce((i, t) => i * t, 1);
  }
  div(n, i) {
    return n / i;
  }
  pow(n, i) {
    return n ** i;
  }
  conjugate(n) {
    return n;
  }
};
var so = class {
  constructor(n) {
    this.one = n.One, this.zero = n.Zero, this.nan = n.NaN, this.ce = n;
  }
  cast(n, i) {
    if (Array.isArray(n)) return n.map((r) => this.cast(r, i));
    let t = n.value;
    switch (i) {
      case "float64":
      case "float32":
        return typeof t == "number" ? t : void 0;
      case "int32":
        return typeof t == "number" ? Math.round(t) : void 0;
      case "uint8":
        if (typeof t != "number") return;
        let r = Math.round(t);
        return r >= 0 && r <= 255 ? r : void 0;
      case "complex128":
      case "complex64":
        return typeof t == "number" ? this.ce.complex(t) : isNaN(n.im) ? void 0 : this.ce.complex(n.re, n.im);
      case "bool":
        return typeof t == "boolean" ? t : void 0;
      case "string":
        return typeof t == "string" ? t : void 0;
      case "expression":
        return n;
    }
    throw new Error(`Cannot cast ${n} to ${i}`);
  }
  expression(n) {
    return n;
  }
  isZero(n) {
    return n.is(0);
  }
  isOne(n) {
    return n.is(1);
  }
  equals(n, i) {
    return n.isSame(i) === true;
  }
  add(n, i) {
    return n.add(i);
  }
  addn(...n) {
    return H(...n);
  }
  neg(n) {
    return n.neg();
  }
  sub(n, i) {
    return n.sub(i);
  }
  mul(n, i) {
    return n.mul(i);
  }
  muln(...n) {
    return ae(...n);
  }
  div(n, i) {
    return n.div(i);
  }
  pow(n, i) {
    return n.pow(i);
  }
  conjugate(n) {
    return this.ce.function("Conjugate", [n]).evaluate();
  }
};
var oo = class {
  constructor(n) {
    this.ce = n, this.one = n.complex(1), this.zero = n.complex(0), this.nan = n.complex(NaN);
  }
  cast(n, i) {
    if (Array.isArray(n)) return n.map((t) => this.cast(t, i));
    switch (i) {
      case "float64":
        return n.im === 0 ? n.re : void 0;
      case "float32":
        return n.im === 0 ? n.re : void 0;
      case "int32":
        return n.im === 0 ? Math.round(n.re) : void 0;
      case "uint8":
        if (n.im !== 0) return;
        let t = Math.round(n.re);
        return t >= 0 && t <= 255 ? t : void 0;
      case "complex128":
        return n;
      case "complex64":
        return n;
      case "bool":
        return !(n.im === 0 && n.re === 0);
      case "string":
        return n.toString();
      case "expression":
        return this.ce.number(n);
    }
    throw new Error(`Cannot cast ${n} to ${i}`);
  }
  expression(n) {
    return this.ce.number(n);
  }
  isZero(n) {
    return n.isZero();
  }
  isOne(n) {
    return n.re === 1 && n.im === 0;
  }
  equals(n, i) {
    return n.equals(i);
  }
  add(n, i) {
    return n.add(i);
  }
  addn(...n) {
    return n.reduce((i, t) => i.add(t), this.zero);
  }
  neg(n) {
    return n.neg();
  }
  sub(n, i) {
    return n.sub(i);
  }
  mul(n, i) {
    return n.mul(i);
  }
  muln(...n) {
    return n.reduce((i, t) => i.mul(t), this.one);
  }
  div(n, i) {
    return n.div(i);
  }
  pow(n, i) {
    return n.pow(i);
  }
  conjugate(n) {
    return n.conjugate();
  }
};
function Lr(e12, n) {
  return e12 === void 0 ? n : e12 === n ? e12 : e12 === "expression" || n === "expression" || e12 === "string" || n === "string" ? "expression" : e12 === "complex128" || n === "complex128" ? "complex128" : e12 === "complex64" || n === "complex64" ? "complex64" : e12 === "float64" || n === "float64" ? "float64" : e12 === "float32" || n === "float32" ? "float32" : e12 === "int32" || n === "int32" ? "int32" : e12 === "uint8" || n === "uint8" ? "uint8" : e12 === "bool" || n === "bool" ? "bool" : "expression";
}
function tl(e12) {
  if (we(e12)) return "bool";
  if (!e12.isNumberLiteral) return "expression";
  switch (e12.type.type) {
    case "real":
    case "rational":
    case "finite_real":
    case "finite_rational":
    case "integer":
      return "float64";
    case "complex":
    case "finite_complex":
    case "imaginary":
      return "complex128";
    case "finite_integer": {
      let n = e12.re;
      return n >= 0 && n <= 255 ? "uint8" : "int32";
    }
    case "boolean":
      return "bool";
    case "string":
      return "string";
    default:
      return "expression";
  }
}
var Hn = class e4 {
  constructor(n, i) {
    this.ce = n;
    this.shape = i.shape, this.rank = this.shape.length, this._strides = od(this.shape), this.field = Or(n, i.dtype);
  }
  static align(n, i) {
    if (n.dtype === i.dtype) return [n, i];
    let t = Lr(n.dtype, i.dtype);
    return n.dtype === t ? [n, i.upcast(t)] : [n.upcast(t), i];
  }
  static broadcast(n, i, t) {
    if (!(t instanceof e4)) return i.map1(n, t);
    let [r, s] = e4.align(i, t), o = r.data.map((a, u) => n(a, s.data[u]));
    return bn(r.ce, { dtype: r.dtype, shape: r.shape, rank: r.rank, data: o });
  }
  get expression() {
    let n = this.shape, i = this.rank, t = this.data, r = this._index.bind(this), s = this.field.expression.bind(this.field), o = (a) => {
      if (a.length === i - 1) {
        let u = r(a), l = this.ce._fn("List", t.slice(u, u + n[i - 1]).map((f) => s(f)));
        return l.isCanonical = l.ops.every((f) => f.isCanonical), l;
      } else {
        let u = [];
        for (let f = 0; f <= n[a.length] - 1; f++) u.push(o([...a, f + 1]));
        let l = this.ce._fn("List", u);
        return l.isCanonical = l.ops.every((f) => f.isCanonical), l;
      }
    };
    return o([]);
  }
  get array() {
    let n = this.shape, i = this.rank, t = this.data;
    if (i === 1) return t;
    if (i === 2) {
      let [o, a] = n, u = new Array(o);
      for (let l = 0; l < o; l++) u[l] = t.slice(l * a, (l + 1) * a);
      return u;
    }
    let r = this._index.bind(this), s = (o) => {
      if (o.length === i - 1) {
        let a = r(o);
        return t.slice(a, a + n[i - 1]);
      } else {
        let a = [];
        for (let u = 0; u < n[o.length]; u++) a.push(s([...o, u + 1]));
        return a;
      }
    };
    return s([]);
  }
  _index(n) {
    let i = this._strides;
    return n.reduce((t, r, s) => t + (r - 1) * i[s], 0);
  }
  get isSquare() {
    let n = this.shape;
    return n.length === 2 && n[0] === n[1];
  }
  get isSymmetric() {
    if (!this.isSquare) return false;
    let n = this.shape[0], i = this.data, t = this.field.equals.bind(this.field);
    for (let r = 0; r < n; r++) for (let s = r + 1; s < n; s++) if (!t(i[r * n + s], i[s * n + r])) return false;
    return true;
  }
  get isSkewSymmetric() {
    if (!this.isSquare) return false;
    let n = this.shape[0], i = this.data, t = this.field.equals.bind(this.field), r = this.field.neg.bind(this.field);
    for (let s = 0; s < n; s++) for (let o = s + 1; o < n; o++) if (!t(i[s * n + o], r(i[o * n + s]))) return false;
    return true;
  }
  get isUpperTriangular() {
    if (!this.isSquare) return false;
    let n = this.shape[0], i = this.data, t = this.field.isZero.bind(this.field);
    for (let r = 1; r < n; r++) for (let s = 0; s < r; s++) if (t(i[r * n + s])) return false;
    return true;
  }
  get isLowerTriangular() {
    if (!this.isSquare) return false;
    let n = this.shape[0], i = this.data, t = this.field.isZero.bind(this.field);
    for (let r = 0; r < n - 1; r++) for (let s = r + 1; s < n; s++) if (!t(i[r * n + s])) return false;
    return true;
  }
  get isTriangular() {
    if (!this.isSquare) return false;
    let n = this.shape[0], i = this.data, t = this.field.isZero.bind(this.field);
    for (let r = 0; r < n; r++) for (let s = 0; s < n; s++) if (r < s && !t(i[r * n + s]) || r > s && !t(i[r * n + s])) return false;
    return true;
  }
  get isDiagonal() {
    if (!this.isSquare) return false;
    let n = this.shape[0], i = this.data, t = this.field.isZero.bind(this.field);
    for (let r = 0; r < n; r++) for (let s = 0; s < n; s++) if (r === s && !t(i[r * n + s]) || r !== s && !t(i[r * n + s])) return false;
    return true;
  }
  get isIdentity() {
    if (!this.isSquare) return false;
    let [n, i] = this.shape, t = this.data, r = this.field.isOne.bind(this.field), s = this.field.isZero.bind(this.field);
    for (let o = 0; o < i; o++) for (let a = 0; a < i; a++) if (o === a && !r(t[o * i + a]) || o !== a && !s(t[o * i + a])) return false;
    return true;
  }
  get isZero() {
    let n = this.field.isZero.bind(this.field);
    return this.data.every((i) => n(i));
  }
  at(...n) {
    let i = this.data.length;
    return this.data[this._index(n) % i];
  }
  diagonal(n, i) {
    if (n != null ? n : n = 1, i != null ? i : i = 2, n === i || n <= 0 || n > this.shape.length || this.shape[n - 1] !== this.shape[i - 1]) return;
    let t = new Array(this.shape[n - 1]), r = this.data, s = this.shape[n - 1];
    for (let o = 0; o < s; o++) t[o] = r[o * s + o];
    return t;
  }
  trace(n, i) {
    if (this.rank !== 2) return;
    let [t, r] = this.shape;
    if (t !== r) return;
    let s = this.data, o = new Array(t);
    for (let a = 0; a < t; a++) o[a] = s[a * t + a];
    return this.field.addn(...o);
  }
  reshape(...n) {
    return bn(this.ce, { dtype: this.dtype, shape: n, rank: n.length, data: this.data });
  }
  flatten() {
    return this.data;
  }
  upcast(n) {
    let i = this.field.cast(this.data, n);
    if (i === void 0) throw Error(`Cannot cast tensor to ${n}`);
    return bn(this.ce, { dtype: n, shape: this.shape, rank: this.rank, data: i });
  }
  transpose(n, i, t) {
    if (this.rank !== 2) return;
    if (n != null ? n : n = 1, i != null ? i : i = 2, n === i) return this;
    if (n <= 0 || n > 2 || i <= 0 || i > 2) return;
    let [r, s] = this.shape, o = this.data;
    t && (o = o.map((f) => t(f)));
    let a = 0, u = new Array(r * s), l = s;
    for (let f = 0; f < s; f++) for (let c = 0; c < r; c++) u[a++] = o[c * l + f];
    return bn(this.ce, { dtype: this.dtype, shape: [s, r], rank: 2, data: u });
  }
  conjugateTranspose(n, i) {
    let t = this.field.conjugate.bind(this.field);
    return this.transpose(n, i, t);
  }
  determinant() {
    if (this.rank !== 2) return;
    let [n, i] = this.shape;
    if (n !== i) return;
    if (n === 1) return this.data[0];
    let t = this.field.add.bind(this.field), r = this.field.mul.bind(this.field), s = this.field.neg.bind(this.field);
    if (n === 2) {
      let [x, E, _, R] = this.data;
      return t(r(x, R), s(r(E, _)));
    }
    let o = this.field.addn.bind(this.field), a = this.field.muln.bind(this.field);
    if (n === 3) {
      let [x, E, _, R, I, q, be, Ee, vi] = this.data;
      return o([a(x, I, vi), a(E, q, be), a(_, R, Ee), s(a(_, I, be)), s(a(E, R, vi)), s(a(x, q, Ee))]);
    }
    let u = this.shape[0], l = false, f = this.field.div.bind(this.field), c = this.field.sub.bind(this.field), p = new Array(u).fill(0).map((x, E) => E), m = [...this.data];
    for (let x = 0; x < u; x++) {
      let E = p[x - 1];
      if (this.at(E, x) === 0) {
        let I;
        for (I = x + 1; I < u; I++) if (this.at(p[I], x) !== 0) {
          E = p[I], p[I - 1] = p[x - 1], p[x - 1] = E, l = !l;
          break;
        }
        if (I === u) return this.at(E, x);
      }
      let _ = this.at(E, x), R = x === 0 ? 1 : this.at(p[x - 2], x - 2);
      for (let I = x + 1; I < u; I++) {
        let q = p[I - 1];
        for (let be = x + 1; be < u; be++) m[q][be] = f(c(r(m[q][be], _), r(m[q][x], m[E][be])), R);
      }
    }
    let y = m[p[u - 1]][u - 1];
    return l ? this.field.neg(y) : y;
  }
  inverse() {
    if (this.rank !== 2) return;
    let [n, i] = this.shape;
    if (n !== i) return;
    if (n === 2) {
      let [p, m, y, x] = this.data, E = this.determinant();
      if (E === void 0 || this.field.isZero(E)) return;
      let _ = this.field.div.bind(this.field), R = this.field.neg.bind(this.field), I = [_(x, E), R(_(m, E)), R(_(y, E)), _(p, E)];
      return bn(this.ce, { dtype: this.dtype, shape: [i, i], rank: 2, data: I });
    }
    let t = this.shape[0], r = this.field.div.bind(this.field), s = this.field.sub.bind(this.field), o = this.field.mul.bind(this.field), a = this.array, u = new Array(t).fill(0).map((p, m) => {
      let y = new Array(t).fill(0);
      return y[m] = 1, y;
    }), l = a.map((p, m) => [...p, ...u[m]]), f = new Array(t).fill(0).map((p, m) => m);
    for (let p = 0; p < t; p++) {
      let m = f[p - 1];
      if (this.at(m, p) === 0) {
        let E;
        for (E = p + 1; E < t; E++) if (this.at(f[E], p) !== 0) {
          m = f[E], f[E - 1] = f[p - 1], f[p - 1] = m;
          break;
        }
        if (E === t) return;
      }
      let y = this.at(m, p), x = p === 0 ? 1 : this.at(f[p - 2], p - 2);
      for (let E = p + 1; E < t; E++) {
        let _ = f[E - 1];
        for (let R = p + 1; R < t * 2; R++) l[_][R] = s(l[_][R], o(r(o(l[_][p], l[m][R]), y), x));
      }
    }
    for (let p = t - 1; p >= 0; p--) {
      let m = l[f[p], p];
      for (let y = 0; y < p; y++) {
        let x = f[y];
        for (let E = t; E < t * 2; E++) l[x][E] = s(l[x][E], o(r(o(l[x][p], l[p][E]), m), m));
      }
      for (let y = t; y < t * 2; y++) l[p][y] = r(l[p][y], m);
    }
    let c = l.map((p) => p.slice(t));
    return bn(this.ce, { dtype: this.dtype, shape: [i, i], rank: 2, data: c });
  }
  pseudoInverse() {
  }
  adjugateMatrix() {
  }
  minor(n, i) {
  }
  map1(n, i) {
    return bn(this.ce, { dtype: this.dtype, shape: this.shape, rank: this.rank, data: this.data.map((t) => n(t, i)) });
  }
  map2(n, i) {
    let t = i.data;
    return bn(this.ce, { dtype: this.dtype, shape: this.shape, rank: this.rank, data: this.data.map((r, s) => n(r, t[s])) });
  }
  add(n) {
    return e4.broadcast(this.field.add.bind(this.field), this, n);
  }
  subtract(n) {
    return e4.broadcast(this.field.sub.bind(this.field), this, n);
  }
  multiply(n) {
    return e4.broadcast(this.field.mul.bind(this.field), this, n);
  }
  divide(n) {
    return e4.broadcast(this.field.div.bind(this.field), this, n);
  }
  power(n) {
    return e4.broadcast(this.field.pow.bind(this.field), this, n);
  }
  equals(n) {
    if (this.rank !== n.rank || !this.shape.every((s, o) => s === n.shape[o])) return false;
    let i = this.field.equals.bind(this.field), t = this.field.cast.bind(this.field), r = this.dtype;
    return this.dtype !== n.dtype ? !!this.data.every((s, o) => i(s, t(n.data[o], r))) : this.data.every((s, o) => i(s, n.data[o]));
  }
};
function od(e12) {
  let n = new Array(e12.length);
  for (let i = e12.length - 1, t = 1; i >= 0; i--) n[i] = t, t *= e12[i];
  return n;
}
var ao = class extends Hn {
  constructor(i, t) {
    super(i, t);
    this.dtype = "float64";
    this.data = t.data;
  }
  get isZero() {
    return this.data.every((i) => i === 0);
  }
};
var uo = class extends Hn {
  constructor(i, t) {
    super(i, t);
    this.dtype = "complex128";
    this.data = t.data;
  }
};
var lo = class extends Hn {
  constructor(i, t) {
    super(i, t);
    this.dtype = "bool";
    this.data = t.data;
  }
};
var fo = class extends Hn {
  constructor(i, t) {
    super(i, t);
    this.dtype = "expression";
    this.data = t.data;
  }
};
function bn(e12, n) {
  let i = n.dtype;
  return i === "float64" || i === "float32" || i === "uint8" || i === "int32" ? new ao(e12, n) : i === "bool" ? new lo(e12, n) : i === "complex64" || i === "complex128" ? new uo(e12, n) : new fo(e12, n);
}
function En(e12, n) {
  if (e12.operator === "Negate" && n.operator === "Negate") return En(e12.op1, n.op1);
  let i = e12.engine;
  if (e12.operator === "Negate") return En(e12.op1, n).neg();
  if (n.operator === "Negate") return En(e12, n.op1).neg();
  if (e12.operator === "Divide" && n.operator === "Divide") {
    let t = e12.op2.mul(n.op2);
    return En(e12.op1, n.op1).div(t);
  }
  return e12.operator === "Divide" ? En(e12.op1, n).div(e12.op2) : n.operator === "Divide" ? En(e12, n.op1).div(n.op2) : e12.operator === "Add" ? H(...e12.ops.map((t) => En(t, n))) : n.operator === "Add" ? H(...n.ops.map((t) => En(e12, t))) : new Be(i, [e12, n]).asExpression();
}
function qt(e12, n) {
  if (n.length === 0) return null;
  if (n.length === 1) return n[0];
  if (n.length === 2) return En(n[0], n[1]);
  let i = qt(e12, n.slice(1));
  return i === null ? null : En(n[0], i);
}
var Ft = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56, 28, 8, 1]];
function po(e12, n) {
  for (; e12 >= Ft.length; ) {
    let i = Ft.length, t = [1], r = Ft[i - 1];
    for (let s = 1; s < i; s++) t[s] = r[s - 1] + r[s];
    t[i] = 1, Ft.push(t);
  }
  return Ft[e12][n];
}
function ad(e12) {
  let n = e12.reduce((t, r) => t + r, 0), i = 1;
  for (let t = 0; t < e12.length; t += 1) i *= po(n, e12[t]), n -= e12[t];
  return i;
}
function* rl(e12, n) {
  if (e12 === 1) {
    yield [n];
    return;
  }
  for (let i = 0; i <= n; i += 1) for (let t of rl(e12 - 1, n - i)) yield [i, ...t];
}
function co(e12, n) {
  let i = e12.engine;
  if (n < 0) {
    let o = co(e12, -n);
    return o ? o.inv() : null;
  }
  if (n === 0) return i.One;
  if (n === 1) return Pe(e12);
  if (e12.operator === "Negate" && Number.isInteger(n)) {
    let o = n % 2 === 0 ? 1 : -1, a = co(e12.op1, n);
    return a === null ? null : o > 0 ? a : a.neg();
  }
  if (e12.operator, e12.operator !== "Add") return null;
  let t = e12.ops, r = rl(t.length, n), s = [];
  for (let o of r) {
    let a = [i.number(ad(o))];
    for (let u = 0; u < o.length; u += 1) o[u] !== 0 && (o[u] === 1 ? a.push(t[u]) : a.push(t[u].pow(o[u])));
    s.push(ae(...a));
  }
  return H(...s);
}
function sl(e12, n, i) {
  var _a2, _b;
  let t = null;
  if (n === "Divide") {
    let r = Pe(i[0]);
    return r === null ? null : r.operator === "Add" ? H(...r.ops.map((s) => s.div(i[1]))) : e12._fn("Divide", [r, i[1]]);
  }
  if (n === "Multiply") return qt(e12, i);
  if (n === "Negate") return (_b = (_a2 = Pe(i[0])) == null ? void 0 : _a2.neg()) != null ? _b : null;
  if (n === "Add") return H(...i.map((r) => {
    var _a3;
    return (_a3 = Pe(r)) != null ? _a3 : r;
  }));
  if (n === "Power") {
    let r = G(i[1]);
    t = r !== null ? co(i[0], r) : null;
  }
  return t;
}
function Pe(e12) {
  var _a2;
  return e12 = e12 == null ? void 0 : e12.canonical, !e12 || typeof e12.operator != "string" ? null : we(e12.operator) ? e12.engine._fn(e12.operator, e12.ops.map((n) => {
    var _a3;
    return (_a3 = Pe(n)) != null ? _a3 : n;
  })) : sl(e12.engine, e12.operator, (_a2 = e12.ops) != null ? _a2 : []);
}
function ol(e12) {
  var _a2;
  if (!e12.operator || !e12.ops) return null;
  let n = e12.engine, i = e12.ops.map((r) => {
    var _a3;
    return r.ops ? (_a3 = sl(n, r.operator, r.ops)) != null ? _a3 : r : r;
  }), t = e12.engine.function(e12.operator, i);
  return (_a2 = Pe(t)) != null ? _a2 : t;
}
function al(e12) {
  let n = -1;
  for (; e12.operator === "Negate"; ) e12 = e12.op1, n = -n;
  return n === 1 ? e12 : e12.isNumberLiteral ? e12.neg() : e12.engine._fn("Negate", [e12]);
}
function pi(e12) {
  let n = -1;
  for (; e12.operator === "Negate"; ) e12 = e12.op1, n = -n;
  if (n === 1) return e12;
  if (e12.numericValue !== null) return e12.neg();
  let i = e12.engine;
  return e12.operator === "Subtract" ? e12.op2.sub(e12.op1) : e12.operator === "Add" ? H(...e12.ops.map((t) => pi(t))) : e12.operator === "Multiply" ? mo(i, e12.ops) : e12.operator === "Divide" ? pi(e12.op1).div(e12.op2) : i._fn("Negate", [e12]);
}
function mo(e12, n) {
  if (n.length === 0) return e12.NegativeOne;
  if (n.length === 1) return pi(n[0]);
  let i = [], t = false;
  for (let r of n) !t && r.operator === "Negate" ? (t = true, r.op1.is(1) || i.push(r.op1)) : i.push(r);
  if (!t) {
    i = [];
    for (let r of n) t || r.numericValue === null && !r.isInteger ? i.push(r) : (t = true, r.is(-1) || i.push(r.neg()));
  }
  if (t) return e12._fn("Multiply", i.sort(fe));
  if (!t) {
    i = [];
    for (let r of n) t || r.numericValue === null || !r.isNumber ? i.push(r) : (t = true, r.is(-1) || i.push(r.neg()));
  }
  return t ? e12._fn("Multiply", i.sort(fe)) : e12._fn("Negate", [e12._fn("Multiply", [...n].sort(fe))]);
}
function He(e12, n) {
  let i = e12.engine;
  if (!e12.isValid || !n.isValid) return i._fn("Divide", [e12, n]);
  if (e12.isNaN || n.isNaN) return i.NaN;
  if (n.is(0)) return e12.is(0) ? i.NaN : i.ComplexInfinity;
  if (e12.is(0)) return i.Zero;
  if (n.is(0) === false && (e12.symbol !== null && e12.symbol === n.symbol && e12.isConstant || e12.isSame(n))) return i.One;
  if (e12.operator === "Negate" && n.operator === "Negate" && (e12 = e12.op1, n = n.op1), e12.operator === "Divide" && n.operator === "Divide") return He(pe(i, [e12.op1, n.op2]), pe(i, [e12.op2, n.op1]));
  if (e12.operator === "Divide") return He(e12.op1, pe(i, [e12.op2, n]));
  if (n.operator === "Divide") return He(pe(i, [e12, n.op2]), n.op1);
  if (n.is(1)) return e12;
  if (n.is(-1)) return e12.neg();
  if (e12.is(1)) return n.inv();
  if (n.isInfinity) return e12.isInfinity ? i.NaN : i.Zero;
  if (e12.operator === "Sqrt" && n.operator === "Sqrt") {
    let f = G(e12.op1), c = G(n.op1);
    if (f !== null && c !== null) return i.number(i._numericValue({ radical: f * c, rational: [1, c] }));
  } else if (e12.operator === "Sqrt") {
    let f = G(e12.op1), c = G(n);
    if (f !== null && c !== null) return i.number(i._numericValue({ radical: f, rational: [1, c] }));
  } else if (n.operator === "Sqrt") {
    let f = G(e12), c = G(n.op1);
    if (f !== null && c !== null) return i.number(i._numericValue({ radical: c, rational: [f, c] }));
  }
  let t = e12.numericValue, r = n.numericValue;
  if (t !== null && r !== null) {
    if (typeof t != "number" && t.im !== 0 || typeof r != "number" && r.im !== 0) return i._fn("Divide", [e12, n]);
    if (typeof t == "number" && Number.isInteger(t) && typeof r == "number" && Number.isInteger(r)) return i.number([t, r]);
    if (typeof t == "number" && Number.isInteger(t)) {
      if (t === 0) return i.Zero;
      if (typeof r != "number" && v(r.type, "integer")) {
        let f = r.bignumRe;
        if (f !== void 0) {
          if (f.isInteger()) return i.number([K(t), K(f)]);
        } else {
          let c = r.re;
          if (Number.isInteger(c)) return i.number([t, c]);
        }
      }
    }
    return i._fn("Divide", [e12, n]);
  }
  let [s, o] = e12.toNumericValue();
  if (s.isZero) return i.Zero;
  let [a, u] = n.toNumericValue();
  if (a.isZero) return i.NaN;
  let l = s.div(a);
  return l.isOne ? u.is(1) ? o : i._fn("Divide", [o, u]) : l.isNegativeOne ? u.is(1) ? o.neg() : i._fn("Divide", [o.neg(), u]) : l.isExact ? o.is(1) && u.is(1) ? i.number(l) : u.is(1) ? pe(i, [i.number(l), o]) : i._fn("Divide", [pe(i, [i.number(l.numerator), o]), pe(i, [i.number(l.denominator), u])]) : i._fn("Divide", [e12, n]);
}
function Hi(e12, n) {
  let i = e12.engine;
  if (e12 = e12.canonical, typeof n != "number" && (n = n.canonical), e12.isNaN) return i.NaN;
  if (typeof n == "number") {
    if (isNaN(n)) return i.NaN;
    if (e12.is(0)) return n === 0 || !isFinite(n) ? i.NaN : e12;
    if (n === 1) return e12;
    if (n === -1) return e12.neg();
    if (n === 0) return i.NaN;
    if (e12.isNumberLiteral) {
      let r = e12.numericValue;
      if (typeof r == "number") {
        if (Number.isInteger(r) && Number.isInteger(n)) return i.number(i._numericValue({ rational: [r, n] }));
      } else if (r.isExact && Number.isInteger(n)) return i.number(r.asExact.div(n));
    }
  } else {
    if (n.isNaN) return i.NaN;
    if (e12.is(0)) return n.is(0) || n.isFinite === false ? i.NaN : i.Zero;
    if (n.is(1)) return e12;
    if (n.is(-1)) return e12.neg();
    if (n.is(0)) return i.NaN;
    if (e12.isNumberLiteral && n.isNumberLiteral) {
      let r = e12.numericValue, s = n.numericValue;
      if (typeof r == "number" && typeof s == "number" && Number.isInteger(r) && Number.isInteger(s)) return i.number(i._numericValue({ rational: [r, s] }));
      if (typeof r == "number" && Number.isInteger(r) && typeof s != "number") {
        if (s.isExact) return i.number(i._numericValue(r).div(s.asExact));
      } else if (typeof s == "number" && Number.isInteger(s) && typeof r != "number") {
        if (r.isExact) return i.number(r.asExact.div(s));
      } else if (typeof r != "number" && typeof s != "number" && r.isExact && s.isExact) return i.number(r.asExact.div(s.asExact));
    }
  }
  let t = new Be(i, [e12]);
  return t.div(typeof n == "number" ? i._numericValue(n) : n), t.asRationalExpression();
}
function pe(e12, n) {
  let i = 1, t = [];
  for (let s of n) {
    let [o, a] = ud(s);
    i *= a, t.push(o);
  }
  t = t.filter((s) => !s.is(1));
  let r = [];
  for (let s = 0; s < t.length; s++) {
    let o = t[s];
    if (s + 1 >= t.length) {
      r.push(o);
      continue;
    }
    let a = t[s + 1];
    if (o.isNumberLiteral) {
      if (a.operator === "Sqrt" && a.op1.isNumberLiteral && a.op1.type.matches("finite_integer")) {
        let u = a.op1.numericValue;
        if (typeof u != "number" && (u = u.re), u >= O) {
          r.push(o);
          continue;
        }
        if (o.type.matches("finite_rational")) {
          let l = o.numericValue, [f, c] = typeof l == "number" ? [l, 1] : [l.numerator.re, l.denominator.re];
          r.push(e12.number(e12._numericValue({ rational: [f, c], radical: u }))), s++;
          continue;
        }
      } else if (a.isNumberLiteral && a.numericValue instanceof z) {
        let u = a.numericValue;
        if (u instanceof Z && ve(u.rational) && u.radical !== 1) {
          let l = je(o);
          if (l) {
            r.push(e12.number(e12._numericValue({ rational: l, radical: u.radical }))), s++;
            continue;
          }
        } else if (u.im === 1) {
          let l = o.numericValue;
          if (typeof l == "number") {
            r.push(e12.number(e12.complex(0, l))), s++;
            continue;
          } else if (l.im === 0) {
            if (Number.isInteger(l.re)) {
              r.push(e12.number(e12.complex(0, l.re))), s++;
              continue;
            } else if (!l.isExact) {
              r.push(e12.number(e12.complex(0, l.re))), s++;
              continue;
            }
          }
        }
      }
    }
    r.push(o);
  }
  return i < 0 ? r.length === 0 ? e12.number(-1) : r.length === 1 ? r[0].neg() : mo(e12, r) : r.length === 0 ? e12.number(1) : r.length === 1 ? r[0] : e12._fn("Multiply", [...r].sort(fe));
}
function ud(e12) {
  let n = 1;
  for (; e12.operator === "Negate"; ) n = -n, e12 = e12.op1;
  return e12.isNumberLiteral && e12.isNegative && (n = -n, e12 = e12.neg()), [e12, n];
}
function ae(...e12) {
  if (e12.length > 0, e12.length === 1) return e12[0];
  let n = e12[0].engine, i = qt(n, e12);
  if (i) {
    if (i.operator !== "Multiply") return i;
    e12 = i.ops;
  }
  return new Be(n, e12).asRationalExpression();
}
function ul(...e12) {
  e12.length > 0;
  let n = e12[0].engine;
  e12 = e12.map((t) => t.N());
  let i = qt(n, e12);
  if (i) {
    if (i.operator !== "Multiply") return i;
    e12 = i.ops;
  }
  return new Be(n, e12).asExpression({ numericApproximation: true });
}
var di = class e5 extends z {
  constructor(n, i) {
    var _a2, _b;
    if (super(), this.bignum = i, typeof n == "number") this.decimal = i(n), this.im = 0;
    else if (n instanceof M) this.decimal = n, this.im = 0;
    else {
      let t = i((_a2 = n.re) != null ? _a2 : 0);
      this.decimal = t, this.im = (_b = n.im) != null ? _b : 0;
    }
    this.decimal.isNaN() && (this.im = NaN), this.decimal.isNaN(), isNaN(this.im);
  }
  get type() {
    return this.isNaN ? "number" : this.isComplexInfinity ? "complex" : this.im !== 0 ? this.decimal.isZero() ? "imaginary" : "finite_complex" : this.decimal.isFinite() ? this.decimal.isInteger() ? "finite_integer" : "finite_real" : "non_finite_number";
  }
  get isExact() {
    return this.im === 0 && this.decimal.isInteger();
  }
  get asExact() {
    if (this.isExact) return this._makeExact(K(this.decimal));
  }
  toJSON() {
    return this.isNaN ? "NaN" : this.isPositiveInfinity ? "PositiveInfinity" : this.isNegativeInfinity ? "NegativeInfinity" : this.isComplexInfinity ? "ComplexInfinity" : this.im === 0 ? fi(this.decimal) ? this.decimal.toNumber() : { num: Fr(this.decimal) } : fi(this.decimal) ? ["Complex", Ie(this.decimal.toNumber()), Ie(this.im)] : ["Complex", { num: Fr(this.decimal) }, Ie(this.im)];
  }
  toString() {
    if (this.isZero) return "0";
    if (this.isOne) return "1";
    if (this.isNegativeOne) return "-1";
    if (this.im === 0) return Fr(this.decimal);
    if (this.decimal.isZero()) return this.im === 1 ? "i" : this.im === -1 ? "-i" : `${ge(this.im)}i`;
    if (this.isComplexInfinity) return "~oo";
    let n = "";
    return this.im === 1 ? n = "+ i" : this.im === -1 ? n = "- i" : this.im > 0 ? n = `+ ${this.im}i` : n = `- ${-this.im}i`, `(${Fr(this.decimal)} ${n})`;
  }
  clone(n) {
    return new e5(n, this.bignum);
  }
  _makeExact(n) {
    return new Z(n, (i) => this.clone(i), this.bignum);
  }
  get re() {
    return this.decimal.toNumber();
  }
  get bignumRe() {
    return this.decimal;
  }
  get numerator() {
    return this;
  }
  get denominator() {
    return this._makeExact(1);
  }
  get isNaN() {
    return this.decimal.isNaN();
  }
  get isPositiveInfinity() {
    return this.im === 0 && !this.decimal.isFinite() && !this.decimal.isNaN() && this.decimal.isPositive();
  }
  get isNegativeInfinity() {
    return this.im === 0 && !this.decimal.isFinite() && !this.decimal.isNaN() && this.decimal.isNegative();
  }
  get isComplexInfinity() {
    return !Number.isFinite(this.im) && !Number.isNaN(this.im);
  }
  get isZero() {
    return this.im === 0 && this.decimal.isZero();
  }
  isZeroWithTolerance(n) {
    if (this.im !== 0) return false;
    let i = typeof n == "number" ? this.bignum(n) : n;
    return this.decimal.abs().lte(i);
  }
  get isOne() {
    return this.im === 0 && this.decimal.eq(1);
  }
  get isNegativeOne() {
    return this.im === 0 && this.decimal.eq(-1);
  }
  sgn() {
    if (this.im === 0) {
      if (this.decimal.isZero()) return 0;
      if (this.decimal.isPositive()) return 1;
      if (this.decimal.isNegative()) return -1;
    }
  }
  N() {
    return this;
  }
  neg() {
    return this.isZero ? this : this.clone({ re: this.decimal.neg(), im: -this.im });
  }
  inv() {
    if (this.isOne) return this;
    if (this.isNegativeOne) return this;
    if (this.im === 0) return this.clone(this.decimal.pow(-1));
    let n = Math.hypot(this.re, this.im), i = this.decimal.mul(this.decimal).add(this.im * this.im).sqrt();
    return this.clone({ re: this.decimal.div(i), im: -this.im / n });
  }
  add(n) {
    var _a2;
    return typeof n == "number" ? n === 0 ? this : this.clone({ re: this.decimal.add(n), im: this.im }) : n.isZero ? this : this.isZero ? this.clone(n) : this.clone({ re: this.decimal.add((_a2 = n.bignumRe) != null ? _a2 : n.re), im: this.im + n.im });
  }
  sub(n) {
    return this.add(n.neg());
  }
  mul(n) {
    var _a2, _b, _c2, _d2;
    if (this.isZero) return this;
    if (n === 1) return this;
    if (n === -1) return this.neg();
    if (n === 0) return this.clone(0);
    if (this.isOne) return typeof n == "number" || n instanceof M ? this.clone(n) : this.clone({ re: (_a2 = n.bignumRe) != null ? _a2 : n.re, im: n.im });
    if (typeof n == "number") return this.im === 0 ? this.clone(this.decimal.mul(n)) : this.clone({ re: this.decimal.mul(n), im: this.im * n });
    if (n instanceof M) return this.im === 0 ? this.clone(this.decimal.mul(n)) : this.clone({ re: this.decimal.mul(n), im: this.im * n.toNumber() });
    if (this.isNegativeOne) {
      let i = n.neg();
      return this.clone({ re: (_b = i.bignumRe) != null ? _b : i.re, im: i.im });
    }
    return n.isOne ? this : n.isNegativeOne ? this.neg() : n.isZero ? this.clone(0) : this.im === 0 && n.im === 0 ? this.clone(this.decimal.mul((_c2 = n.bignumRe) != null ? _c2 : n.re)) : this.clone({ re: this.decimal.mul((_d2 = n.bignumRe) != null ? _d2 : n.re).sub(this.im * n.im), im: this.re * n.im + this.im * n.re });
  }
  div(n) {
    var _a2, _b;
    if (typeof n == "number") return n === 1 ? this : n === -1 ? this.neg() : n === 0 ? this.clone(NaN) : this.clone({ re: this.decimal.div(n), im: this.im / n });
    if (n.isOne) return this;
    if (n.isNegativeOne) return this.neg();
    if (n.isZero) return this.clone(this.isZero ? NaN : 1 / 0);
    if (this.im === 0 && n.im === 0) return this.clone(this.decimal.div((_a2 = n.bignumRe) != null ? _a2 : n.re));
    let [i, t] = [this.re, this.im], [r, s] = [n.re, n.im], o = r * r + s * s, a = (_b = n.bignumRe) != null ? _b : this.bignum(n.re), u = a.mul(a).add(s * s);
    return this.clone({ re: this.decimal.mul(a).add(t * s).div(u), im: (t * r - i * s) / o });
  }
  pow(n) {
    var _a2, _b;
    if (Array.isArray(n), this.isNaN) return this;
    if (typeof n == "number" && isNaN(n)) return this.clone(NaN);
    if (n instanceof z) {
      if (n.isNaN) return this.clone(NaN);
      if (n.isZero) return this.clone(1);
      if (n.isOne) return this;
      n.im ? n = { re: n.re, im: n.im } : n = n.re;
    }
    if (typeof n == "object" && ("re" in n || "im" in n)) {
      let [u, l] = [(_a2 = n == null ? void 0 : n.re) != null ? _a2 : 0, (_b = n == null ? void 0 : n.im) != null ? _b : 0];
      if (Number.isNaN(l) || Number.isNaN(u)) return this.clone(NaN);
      if (l === 0) n = u;
      else {
        if (this.im === 1 / 0) return this.clone(NaN);
        if (this.isNegativeInfinity) return this.clone(0);
        if (this.isPositiveInfinity) return this.clone({ im: 1 / 0 });
        let f = this.pow(u), c = this.decimal.ln().mul(l), p = this.clone({ re: c.cos(), im: Wi(c.sin().toNumber()) });
        return f.mul(p);
      }
    }
    if (this.isPositiveInfinity) {
      if (n === -1) return this.clone(0);
      if (n === 1 / 0) return this.clone(1 / 0);
      if (n === -1 / 0) return this.clone(0);
    } else if (this.isNegativeInfinity && n === 1 / 0) return this.clone(NaN);
    if ((n === 1 / 0 || n === -1 / 0) && (this.isOne || this.isNegativeOne)) return this.clone(NaN);
    if (n === 1) return this;
    if (n === -1) return this.inv();
    if (n === 0) return this.clone(1);
    if (this.isZero) {
      if (n > 0) return this;
      if (n < 0) return this.clone({ im: 1 / 0 });
    }
    if (n < 0) return this.pow(-n).inv();
    if (this.im === 0) return this.clone(this.decimal.pow(n));
    let i = this.decimal, t = this.im, r = i.mul(i).add(t * t).sqrt(), s = M.atan2(t, i), o = r.pow(n), a = s.mul(n);
    return this.clone({ re: o.mul(a.cos()), im: Wi(o.mul(a.sin()).toNumber()) });
  }
  root(n) {
    if (!Number.isInteger(n)) return this._makeExact(NaN);
    if (n === 0) return this._makeExact(NaN);
    if (n === 1) return this;
    if (this.isZero) return this;
    if (this.isOne) return this;
    if (this.isNegativeOne) return this;
    if (this.im === 0) return this.decimal.isNegative() ? this._makeExact(NaN) : n === 2 ? this.clone(this.decimal.sqrt()) : n === 3 ? this.clone(this.decimal.cbrt()) : this.clone(this.decimal.pow(1 / n));
    let i = this.decimal, t = this.im, r = i.mul(i).add(t * t).sqrt(), s = M.atan2(t, i), o = r.pow(1 / n), a = s.div(n);
    return this.clone({ re: o.mul(a.cos()), im: Wi(o.mul(a.sin()).toNumber()) });
  }
  sqrt() {
    if (this.isZero || this.isOne) return this;
    if (this.im !== 0) {
      let n = this.decimal, i = this.im, t = n.mul(n).add(i * i).sqrt(), r = n.add(t).div(2).sqrt(), s = Wi(Math.sign(i) * t.sub(n).div(2).sqrt().toNumber());
      return this.clone({ re: r, im: s });
    }
    return this.decimal.isPositive() ? this.clone(this.decimal.sqrt()) : this.clone({ im: Math.sqrt(-this.re) });
  }
  gcd(n) {
    var _a2;
    if (this.isZero) return n;
    if (n.isZero) return this;
    if (this.im !== 0 || n.im !== 0) return this._makeExact(NaN);
    if (!this.decimal.isInteger()) return this._makeExact(1);
    let i = this.bignum((_a2 = n.bignumRe) != null ? _a2 : n.re);
    if (!i.isInteger()) return this._makeExact(1);
    let t = this.decimal;
    for (; !i.isZero(); ) {
      let r = i;
      i = t.mod(i), t = r;
    }
    return this.clone(t.abs());
  }
  abs() {
    return this.im === 0 ? this.decimal.isPositive() ? this : this.clone(this.decimal.neg()) : this.clone(this.decimal.pow(2).add(this.im ** 2).sqrt());
  }
  ln(n) {
    if (this.isZero) return this._makeExact(NaN);
    if (this.isNegativeInfinity) return this._makeExact(NaN);
    if (this.isPositiveInfinity) return this._makeExact(1 / 0);
    if (this.im === 0) return this.decimal.isNegative() ? this._makeExact(NaN) : this.isOne ? this._makeExact(0) : this.isNegativeOne ? this.clone({ im: Math.PI }) : n === void 0 ? this.clone(this.decimal.ln()) : this.clone(this.decimal.log(n));
    let i = this.decimal, t = this.im, r = i.mul(i).add(t * t).sqrt(), s = M.atan2(t, i).toNumber();
    return n === void 0 ? this.clone({ re: r.ln(), im: s }) : this.clone({ re: r.log(n), im: s });
  }
  exp() {
    if (this.isNaN) return this._makeExact(NaN);
    if (this.isZero) return this._makeExact(1);
    if (this.isNegativeInfinity) return this._makeExact(0);
    if (this.isPositiveInfinity) return this._makeExact(1 / 0);
    if (this.im !== 0) {
      let n = this.decimal.exp();
      return this.clone({ re: n.mul(Wi(Math.cos(this.im))), im: Wi(n.mul(Math.sin(this.im)).toNumber()) });
    }
    return this.clone(this.decimal.exp());
  }
  floor() {
    return this.isNaN || this.im !== 0 ? this._makeExact(NaN) : this.decimal.isInteger() ? this : this._makeExact(K(this.decimal.floor()));
  }
  ceil() {
    return this.isNaN || this.im !== 0 ? this._makeExact(NaN) : this.decimal.isInteger() ? this : this._makeExact(K(this.decimal.ceil()));
  }
  round() {
    return this.isNaN || this.im !== 0 ? this._makeExact(NaN) : this.decimal.isInteger() ? this : this._makeExact(K(this.decimal.round()));
  }
  eq(n) {
    var _a2;
    return this.isNaN ? false : typeof n == "number" ? this.im === 0 && this.decimal.eq(n) : n.isNaN ? false : Number.isFinite(this.im) ? this.decimal.eq((_a2 = n.bignumRe) != null ? _a2 : n.re) && this.im - n.im === 0 : !Number.isFinite(n.im);
  }
  lt(n) {
    var _a2;
    return this.im, typeof n == "number" ? this.decimal.lt(n) : this.decimal.lt((_a2 = n.bignumRe) != null ? _a2 : n.re);
  }
  lte(n) {
    var _a2;
    return this.im, typeof n == "number" ? this.decimal.lte(n) : this.decimal.lte((_a2 = n.bignumRe) != null ? _a2 : n.re);
  }
  gt(n) {
    var _a2;
    return this.im, typeof n == "number" ? this.decimal.gt(n) : this.decimal.gt((_a2 = n.bignumRe) != null ? _a2 : n.re);
  }
  gte(n) {
    var _a2;
    return this.im, typeof n == "number" ? this.decimal.gte(n) : this.decimal.gte((_a2 = n.bignumRe) != null ? _a2 : n.re);
  }
};
function Fr(e12) {
  let n = e12.toString();
  if (e12.isInteger() && n.includes("e")) {
    let i = e12.toFixed(), t = i.match(/0+$/);
    if ((t ? t[0].length : 0) <= 5) return i;
  }
  return n;
}
function Wi(e12) {
  return Math.abs(e12) <= 1e-14 ? 0 : e12;
}
var mi = class e6 extends z {
  constructor(n, i) {
    var _a2;
    if (super(), this.bignum = i, typeof n == "number") this.decimal = n, this.im = 0;
    else if (n instanceof M) this.decimal = n.toNumber(), this.im = 0;
    else {
      let t = n.re === void 0 ? 0 : n.re instanceof M ? n.re.toNumber() : n.re;
      this.decimal = t, this.im = (_a2 = n.im) != null ? _a2 : 0, isFinite(this.im) || (this.decimal = this.im);
    }
    isNaN(this.im);
  }
  _makeExact(n) {
    return new Z(n, (i) => this.clone(i), this.bignum);
  }
  get type() {
    return this.isNaN ? "number" : this.isComplexInfinity ? "complex" : this.im !== 0 ? this.decimal === 0 ? "imaginary" : "finite_complex" : Number.isFinite(this.decimal) ? Number.isInteger(this.decimal) ? "finite_integer" : "finite_real" : "non_finite_number";
  }
  get isExact() {
    return this.im === 0 && Number.isInteger(this.decimal);
  }
  get asExact() {
    if (this.isExact) return this._makeExact(this.decimal);
  }
  toJSON() {
    return this.isNaN ? "NaN" : this.isPositiveInfinity ? "PositiveInfinity" : this.isNegativeInfinity ? "NegativeInfinity" : this.im === 0 ? Ie(this.decimal) : ["Complex", Ie(this.decimal), Ie(this.im)];
  }
  toString() {
    if (this.isZero) return "0";
    if (this.isOne) return "1";
    if (this.isNegativeOne) return "-1";
    if (this.im === 0) return ge(this.decimal);
    if (this.decimal === 0) return this.im === 1 ? "i" : this.im === -1 ? "-i" : `${ge(this.im)}i`;
    if (this.isComplexInfinity) return "~oo";
    let n = "";
    return this.im === 1 ? n = "+ i" : this.im === -1 ? n = "- i" : this.im > 0 ? n = `+ ${ge(this.im)}i` : n = `- ${ge(-this.im)}i`, `(${ge(this.decimal)} ${n})`;
  }
  clone(n) {
    return new e6(n, this.bignum);
  }
  get re() {
    return this.decimal;
  }
  get bignumRe() {
  }
  get numerator() {
    return this;
  }
  get denominator() {
    return this._makeExact(1);
  }
  get isNaN() {
    return Number.isNaN(this.decimal);
  }
  get isPositiveInfinity() {
    return !Number.isFinite(this.decimal) && this.decimal > 0 && this.im === 0;
  }
  get isNegativeInfinity() {
    return !Number.isFinite(this.decimal) && this.decimal < 0 && this.im === 0;
  }
  get isComplexInfinity() {
    return !Number.isFinite(this.im) && !Number.isNaN(this.im);
  }
  get isZero() {
    return this.im === 0 && this.decimal === 0;
  }
  isZeroWithTolerance(n) {
    if (this.im !== 0) return false;
    let i = n instanceof M ? n.toNumber() : n;
    return Math.abs(this.decimal) < i;
  }
  get isOne() {
    return this.im === 0 && this.decimal === 1;
  }
  get isNegativeOne() {
    return this.im === 0 && this.decimal === -1;
  }
  sgn() {
    if (!(this.im !== 0 || !Number.isFinite(this.decimal))) return Math.sign(this.decimal);
  }
  N() {
    return this;
  }
  neg() {
    return this.isNaN ? this._makeExact(NaN) : this.isZero ? this : this.clone({ re: -this.decimal, im: -this.im });
  }
  inv() {
    if (this.isNaN) return this._makeExact(NaN);
    if (this.isOne) return this;
    if (this.isNegativeOne) return this;
    if (this.im === 0) return this.clone(1 / this.decimal);
    let n = Math.hypot(this.re, this.im);
    return this.clone({ re: this.decimal / n, im: -this.im / n });
  }
  add(n) {
    var _a2;
    return this.isNaN ? this._makeExact(NaN) : typeof n == "number" ? n === 0 ? this : this.clone({ re: this.decimal + n, im: this.im }) : n.isZero ? this : this.isZero ? this.clone({ re: (_a2 = n.bignumRe) != null ? _a2 : n.re, im: n.im }) : this.clone({ re: this.decimal + n.re, im: this.im + n.im });
  }
  sub(n) {
    return this.add(n.neg());
  }
  mul(n) {
    var _a2, _b;
    if (this.isNaN) return this._makeExact(NaN);
    if (this.isZero) return this;
    if (n instanceof M && (n = n.toNumber()), n === 1) return this;
    if (n === -1) return this.neg();
    if (n === 0) return this.clone(0);
    if (this.isOne) return typeof n == "number" || n instanceof M ? this.clone(n) : this.clone({ re: (_a2 = n.bignumRe) != null ? _a2 : n.re, im: n.im });
    if (typeof n == "number") return this.im === 0 ? this.clone(this.decimal * n) : this.clone({ re: this.decimal * n, im: this.im * n });
    if (this.isNegativeOne) {
      let i = n.neg();
      return this.clone({ re: (_b = i.bignumRe) != null ? _b : i.re, im: i.im });
    }
    return n.isOne ? this : n.isNegativeOne ? this.neg() : n.isZero ? this.clone(0) : this.im === 0 && n.im === 0 ? this.clone(this.decimal * n.re) : this.clone({ re: this.decimal * n.re - this.im * n.im, im: this.re * n.im + this.im * n.re });
  }
  div(n) {
    if (this.isNaN) return this._makeExact(NaN);
    if (typeof n == "number") return n === 1 ? this : n === -1 ? this.neg() : n === 0 ? this.clone(NaN) : this.clone({ re: this.decimal / n, im: this.im / n });
    if (n.isOne) return this;
    if (n.isNegativeOne) return this.neg();
    if (n.isZero) return this.clone(this.isZero ? NaN : 1 / 0);
    if (this.im === 0 && n.im === 0) return this.clone(this.decimal / n.re);
    let [i, t] = [this.decimal, this.im], [r, s] = [n.re, n.im], o = r * r + s * s;
    return this.clone({ re: (i * r + t * s) / o, im: (t * r - i * s) / o });
  }
  pow(n) {
    var _a2, _b;
    if (Array.isArray(n), this.isNaN) return this._makeExact(NaN);
    if (typeof n == "number" && isNaN(n)) return this.clone(NaN);
    if (n instanceof z) {
      if (n.isNaN) return this.clone(NaN);
      if (n.isZero) return this.clone(1);
      if (n.isOne) return this;
      n.im ? n = { re: n.re, im: n.im } : n = n.re;
    }
    if (typeof n == "object" && ("re" in n || "im" in n)) {
      let [u, l] = [(_a2 = n == null ? void 0 : n.re) != null ? _a2 : 0, (_b = n == null ? void 0 : n.im) != null ? _b : 0];
      if (Number.isNaN(l) || Number.isNaN(u)) return this.clone(NaN);
      if (l === 0) n = u;
      else {
        if (this.im === 1 / 0) return this.clone(NaN);
        if (this.isNegativeInfinity) return this.clone(0);
        if (this.isPositiveInfinity) return this.clone({ im: 1 / 0 });
        let f = this.pow(u).re, c = Math.log(this.decimal) * l;
        return this.clone({ re: ll(f * Math.cos(c)), im: ll(f * Math.sin(c)) });
      }
    }
    if (this.isPositiveInfinity) {
      if (n === -1) return this.clone(0);
      if (n === 1 / 0) return this.clone(1 / 0);
      if (n === -1 / 0) return this.clone(0);
    } else if (this.isNegativeInfinity && n === 1 / 0) return this.clone(NaN);
    if ((n === 1 / 0 || n === -1 / 0) && (this.isOne || this.isNegativeOne)) return this.clone(NaN);
    if (n === 1) return this;
    if (n === -1) return this.inv();
    if (n === 0) return this.clone(1);
    if (this.isZero) {
      if (n > 0) return this;
      if (n < 0) return this.clone({ im: 1 / 0 });
    }
    if (n < 0) return this.clone(1 / this.decimal ** -n);
    if (this.im === 0) return this.clone(this.decimal ** n);
    let i = this.decimal, t = this.im, r = Math.sqrt(i * i + t * t), s = Math.atan2(t, i), o = r ** n, a = s ** n;
    return this.clone({ re: o * Math.cos(a), im: o * Math.sin(a) });
  }
  root(n) {
    if (this.isNaN) return this._makeExact(NaN);
    if (n === 0) return this.clone(NaN);
    if (this.isNaN) return this;
    if (this.isZero) return this;
    if (this.isOne) return this;
    if (this.isNegativeOne) return this;
    if (n === 1) return this;
    if (n === 2) return this.sqrt();
    if (n === 3) return this.clone(Math.cbrt(this.decimal));
    if (this.im === 0) return this.decimal < 0 ? n % 2 === 0 ? this.clone(NaN) : this.clone(-Math.pow(-this.decimal, 1 / n)) : this.clone(Math.pow(this.decimal, 1 / n));
    let i = this.decimal, t = this.im, r = Math.hypot(i, t), s = Math.atan2(t, i), o = Math.pow(r, 1 / n), a = s / n;
    return this.clone({ re: o * Math.cos(a), im: o * Math.sin(a) });
  }
  sqrt() {
    if (this.isNaN) return this._makeExact(NaN);
    if (this.isZero || this.isOne) return this;
    if (this.im !== 0) {
      let n = this.decimal, i = this.im, t = Math.sqrt(n * n + i * i), r = Math.sqrt((n + t) / 2), s = Math.sign(i) * Math.sqrt((t - n) / 2);
      return this.clone({ re: r, im: s });
    }
    return this.decimal > 0 ? this.clone(Math.sqrt(this.decimal)) : this.clone({ im: Math.sqrt(-this.decimal) });
  }
  gcd(n) {
    if (this.isNaN) return this._makeExact(NaN);
    if (this.isZero) return n;
    if (n.isZero) return this;
    if (this.im !== 0 || n.im !== 0) return this._makeExact(NaN);
    if (!Number.isInteger(this.decimal)) return this._makeExact(1);
    let i = n.re;
    if (!Number.isInteger(i)) return this._makeExact(1);
    let t = this.decimal;
    for (; i !== 0; ) {
      let r = i;
      i = t % i, t = r;
    }
    return this.clone(Math.abs(t));
  }
  abs() {
    return this.isNaN ? this._makeExact(NaN) : this.im === 0 ? this.decimal > 0 ? this : this.clone(-this.decimal) : this.clone(Math.sqrt(this.decimal ** 2 + this.im ** 2));
  }
  ln(n) {
    if (this.isNaN) return this._makeExact(NaN);
    if (this.isZero) return this._makeExact(NaN);
    if (this.isNegativeInfinity) return this._makeExact(NaN);
    if (this.isPositiveInfinity) return this._makeExact(1 / 0);
    if (this.im === 0) return this.decimal < 0 ? this._makeExact(NaN) : this.isOne ? this._makeExact(0) : this.isNegativeOne ? this.clone({ im: Math.PI }) : n === void 0 ? this.clone(Math.log(this.decimal)) : this.clone(Math.log(this.decimal) / Math.log(n));
    let i = this.decimal, t = this.im, r = Math.hypot(i, t), s = Math.atan2(t, i), o = n === void 0 ? Math.log(r) : Math.log(r) / Math.log(n);
    return this.clone({ re: o, im: s });
  }
  exp() {
    if (this.isNaN) return this._makeExact(NaN);
    if (this.isZero) return this._makeExact(1);
    if (this.isNegativeInfinity) return this._makeExact(0);
    if (this.isPositiveInfinity) return this._makeExact(1 / 0);
    if (this.im !== 0) {
      let n = Math.exp(this.decimal);
      return this.clone({ re: n * Math.cos(this.im), im: n * Math.sin(this.im) });
    }
    return this.clone(Math.exp(this.decimal));
  }
  floor() {
    return this.isNaN || this.im !== 0 ? this._makeExact(NaN) : Number.isInteger(this.decimal) ? this : this._makeExact(Math.floor(this.decimal));
  }
  ceil() {
    return this.isNaN || this.im !== 0 ? this._makeExact(NaN) : Number.isInteger(this.decimal) ? this : this._makeExact(Math.ceil(this.decimal));
  }
  round() {
    return this.isNaN || this.im !== 0 ? this._makeExact(NaN) : Number.isInteger(this.decimal) ? this : this._makeExact(Math.round(this.decimal));
  }
  eq(n) {
    return this.isNaN ? false : typeof n == "number" ? this.im === 0 && this.decimal - n === 0 : n.isNaN ? false : Number.isFinite(this.im) ? this.decimal - n.re === 0 && this.im - n.im === 0 : !Number.isFinite(n.im);
  }
  lt(n) {
    return this.im, typeof n == "number" ? this.decimal < n : this.decimal < n.re;
  }
  lte(n) {
    return this.im, typeof n == "number" ? this.decimal <= n : this.decimal <= n.re;
  }
  gt(n) {
    return this.im, typeof n == "number" ? this.decimal > n : this.decimal > n.re;
  }
  gte(n) {
    return this.im, typeof n == "number" ? this.decimal >= n : this.decimal >= n.re;
  }
};
function ll(e12) {
  return Math.abs(e12) <= 1e-14 ? 0 : e12;
}
var $t = class {
  constructor(n, i) {
    this.terms = [];
    this.engine = n;
    let t = 0, r = 0, s = [];
    for (let o of i) {
      if (o.type.is("complex") && o.isInfinity) {
        this.terms = [{ term: n.ComplexInfinity, coef: [] }];
        return;
      }
      if (o.isNaN || o.symbol === "Undefined") {
        this.terms = [{ term: n.NaN, coef: [] }];
        return;
      }
      let [a, u] = o.toNumericValue();
      a.isPositiveInfinity ? t += 1 : a.isNegativeInfinity && (r += 1), u.is(1) ? a.isZero || s.push(a) : this.add(a, u);
    }
    if (t > 0 && r > 0) {
      this.terms = [{ term: n.NaN, coef: [] }];
      return;
    }
    if (t > 0) {
      this.terms = [{ term: n.PositiveInfinity, coef: [] }];
      return;
    }
    if (r > 0) {
      this.terms = [{ term: n.NegativeInfinity, coef: [] }];
      return;
    }
    s.length === 1 ? this.add(s[0], n.One) : s.length > 0 && fl(n, s).forEach((o) => this.add(o, n.One));
  }
  add(n, i) {
    if (i.is(0) || n.isZero) return;
    if (i.is(1)) {
      let r = this.engine;
      this.terms.push({ coef: [], term: r.number(n) });
      return;
    }
    if (i.operator === "Add") {
      for (let r of i.ops) {
        let [s, o] = r.toNumericValue();
        this.add(n.mul(s), o);
      }
      return;
    }
    if (i.operator === "Negate") {
      this.add(n.neg(), i.op1);
      return;
    }
    let t = this.find(i);
    if (t >= 0) {
      this.terms[t].coef.push(n);
      return;
    }
    i.numericValue === null || i.is(1), this.terms.push({ coef: [n], term: i });
  }
  find(n) {
    return this.terms.findIndex((i) => i.term.isSame(n));
  }
  N() {
    let n = this.engine, i = this.terms;
    if (i.length === 0) return n.Zero;
    let t = [], r = [];
    for (let { coef: o, term: a } of i) if (o.length === 0) a.isNumberLiteral ? typeof a.numericValue == "number" ? r.push(n._numericValue(a.numericValue)) : r.push(a.numericValue) : t.push(a);
    else {
      let u = o.reduce((l, f) => l.add(f)).N();
      if (u.isZero) continue;
      u.eq(1) ? t.push(a.N()) : u.eq(-1) ? t.push(a.N().neg()) : t.push(a.N().mul(n.box(u)));
    }
    let s = ld(n, r);
    if (!s.isZero) {
      if (t.length === 0) return n.box(s);
      t.push(n.box(s));
    }
    return Ve(n, t);
  }
  asExpression() {
    let n = this.engine, i = this.terms;
    return i.length === 0 ? n.Zero : Ve(n, i.map(({ coef: t, term: r }) => {
      if (t.length === 0) return r;
      let s = fl(n, t);
      if (s.length === 0) return r;
      if (s.length > 1) return pe(n, [Ve(n, s.map((a) => n.box(a))), r]);
      let o = s[0];
      return o.isNaN ? n.NaN : o.isZero ? n.Zero : o.eq(1) ? r : o.eq(-1) ? r.neg() : r.is(1) ? n.box(o) : r.mul(n.box(o));
    }));
  }
};
function fl(e12, n) {
  let i = (s) => e12.bignum(s), t = (s) => new Z(s, r, i), r = e12.precision > cn ? (s) => new di(s, i) : (s) => new mi(s, t);
  return Z.sum(n, r, i);
}
function ld(e12, n) {
  let i = (o) => e12.bignum(o), t = (o) => new Z(o, r, i), r = e12.precision > cn ? (o) => new di(o, i) : (o) => new mi(o, t), s = Z.sum(n, r, i);
  return s.length === 0 ? t(0) : s.length === 1 ? s[0].N() : s.reduce((o, a) => o.add(a).N());
}
function Ve(e12, n) {
  var _a2;
  if (n = J(n, "Add"), n = n.filter((t) => t.numericValue === null || !t.is(0)), n.length === 0) return e12.Zero;
  if (n.length === 1 && !si(n[0])) return n[0];
  let i = [];
  for (let t = 0; t < n.length; t++) {
    let r = n[t];
    if (r.isNumberLiteral) {
      let s = r.numericValue;
      if (typeof s == "number" || v(s.type, "real") && !s.isExact || v(s.type, "integer")) {
        let o = n[t + 1];
        if (o) {
          let a = (_a2 = wi(o)) == null ? void 0 : _a2.numericValue;
          if (a !== void 0) {
            let u = typeof a == "number" ? a : a == null ? void 0 : a.re;
            if (u !== 0) {
              let l = typeof s == "number" ? s : s.re;
              i.push(e12.number(e12._numericValue({ re: l, im: u != null ? u : 0 }))), t++;
              continue;
            }
          }
        }
      }
    }
    i.push(r);
  }
  return i.length === 1 ? i[0] : e12._fn("Add", [...i].sort(At));
}
function cl(e12) {
  return e12.length === 0 ? "finite_integer" : e12.length === 1 ? e12[0].type : ke(...e12.map((n) => n.type.type));
}
function H(...e12) {
  return e12.length > 0, e12.every((n) => n.isValid) ? new $t(e12[0].engine, e12).asExpression() : e12[0].engine._fn("Add", e12);
}
function pl(...e12) {
  return e12.length > 0, e12.every((n) => n.isValid) ? (e12 = e12.map((n) => n.isNumberLiteral ? n.evaluate() : n.N()), new $t(e12[0].engine, e12).N()) : e12[0].engine._fn("Add", e12);
}
function Ji(e12, n) {
  if (e12 === n) return true;
  if (e12.ops) return e12.operator !== n.operator || e12.nops !== n.nops ? false : e12.ops.every((i, t) => Ji(i, n.ops[t]));
  if (e12.isNumberLiteral) {
    if (!n.isNumberLiteral) return false;
    let i = e12.numericValue, t = n.numericValue;
    return i === t ? true : typeof i == "number" ? typeof t == "number" ? i === t : t.eq(i) : i.eq(t);
  }
  if (e12.string || n.string) return e12.string === n.string;
  if (e12.symbol || n.symbol) return e12.symbol === n.symbol;
  if (e12.rank !== 0) {
    if (e12.rank !== n.rank) return false;
    for (let i = 0; i < e12.rank; i++) if (e12.shape[i] !== n.shape[i]) return false;
    return e12.tensor.equals(n.tensor);
  }
  return false;
}
function qr(e12, n) {
  var _a2, _b, _c2, _d2, _e2, _f2, _g, _h, _i2, _j;
  if ((_a2 = e12.functionDefinition) == null ? void 0 : _a2.eq) {
    let r = e12.functionDefinition.eq(e12, e12.engine.box(n));
    if (r !== void 0) return r;
  }
  if (typeof n != "number" && ((_b = n.functionDefinition) == null ? void 0 : _b.eq)) {
    let r = n.functionDefinition.eq(n, e12);
    if (r !== void 0) return r;
  }
  e12 = e12.N();
  let i = typeof n != "number" ? n.N() : e12.engine.box(n);
  if (e12.ops || i.ops) {
    let r = (_d2 = (_c2 = e12.functionDefinition) == null ? void 0 : _c2.eq) == null ? void 0 : _d2.call(_c2, e12, i);
    return r !== void 0 || (r = (_f2 = (_e2 = i.functionDefinition) == null ? void 0 : _e2.eq) == null ? void 0 : _f2.call(_e2, i, e12), r !== void 0) ? r : e12.isSame(i) ? true : e12.unknowns.length === 0 && i.unknowns.length === 0 ? e12.isFinite && i.isFinite ? dl(e12.sub(i).simplify().N()) : e12.isNaN || i.isNaN ? false : !!(e12.isInfinity && i.isInfinity && e12.sgn === i.sgn) : (e12 = e12.expand().simplify(), i = i.expand().simplify(), fd(e12, i) ? Ji(e12, i) : void 0);
  }
  if (e12.symbol) {
    let r = (_h = (_g = e12.symbolDefinition) == null ? void 0 : _g.eq) == null ? void 0 : _h.call(_g, i);
    if (r !== void 0) return r;
  }
  if (i.symbol) {
    let r = (_j = (_i2 = i.symbolDefinition) == null ? void 0 : _i2.eq) == null ? void 0 : _j.call(_i2, e12);
    if (r !== void 0) return r;
  }
  if (e12.symbol && i.symbol) return e12.symbol === i.symbol;
  let t = e12.engine;
  if (e12.isNumberLiteral && i.isNumberLiteral) return e12.isFinite && i.isFinite ? dl(e12.sub(i)) : e12.isNaN || i.isNaN ? false : !!(e12.isInfinity && i.isInfinity && e12.sgn === i.sgn);
  if (t.ask(t.box(["Equal", e12, i])).length > 0) return true;
  if (t.ask(t.box(["NotEqual", e12, i])).length > 0) return false;
  if (!(e12.unknowns.length > 0 || i.unknowns.length > 0)) return Ji(e12, i);
}
function Yi(e12, n) {
  var _a2, _b, _c2, _d2, _e2, _f2;
  if (e12.isNumberLiteral) {
    if (typeof n != "number" && typeof n.numericValue == "number" && (n = n.numericValue), typeof n == "number") {
      if (n === 0) {
        let r = e12.sgn;
        return r === void 0 ? void 0 : r === "zero" ? "=" : r === "positive" || r === "positive-infinity" ? ">" : r === "negative" || r === "negative-infinity" ? "<" : r === "non-negative" ? ">=" : r === "non-positive" ? "<=" : void 0;
      }
      if (e12.isNumberLiteral) {
        let r = e12.numericValue;
        return typeof r == "number" ? Math.abs(r - n) <= e12.engine.tolerance ? "=" : r < n ? "<" : ">" : r.eq(n) ? "=" : r.lt(n) ? "<" : ">";
      }
      return;
    }
    if (!n.isNumberLiteral) return;
    let i = e12.numericValue, t = n.numericValue;
    return typeof i == "number" ? t.eq(i) ? "=" : t.lt(i) ? ">" : "<" : i.eq(t) ? "=" : i.lt(t) ? "<" : ">";
  }
  if (typeof n != "number") {
    if (e12.ops || n.ops) {
      if (((_b = (_a2 = e12.functionDefinition) == null ? void 0 : _a2.eq) == null ? void 0 : _b.call(_a2, e12, n)) !== void 0) return "=";
      let t = e12.sub(n).N();
      if (!t.isNumberLiteral) return;
      if (typeof t.numericValue == "number") return t.numericValue === 0 ? "=" : t.numericValue < 0 ? "<" : ">";
      let r = e12.engine.tolerance;
      return t.numericValue.isZeroWithTolerance(r) ? "=" : t.numericValue.lt(0) ? "<" : ">";
    }
    if (e12.symbol) {
      if (e12.symbol === n.symbol) return "=";
      let i = (_d2 = (_c2 = e12.symbolDefinition) == null ? void 0 : _c2.cmp) == null ? void 0 : _d2.call(_c2, n);
      return i || (((_f2 = (_e2 = e12.symbolDefinition) == null ? void 0 : _e2.eq) == null ? void 0 : _f2.call(_e2, n)) === true ? "=" : void 0);
    }
    if (e12.string) return n.string ? e12.string === n.string ? "=" : e12.string < n.string ? "<" : ">" : void 0;
    if (e12.tensor) return n.tensor && e12.tensor.equals(n.tensor) ? "=" : void 0;
  }
}
function dl(e12) {
  if (!e12.isNumberLiteral) return false;
  let n = e12.numericValue, i = e12.engine;
  return typeof n == "number" ? i.chop(n) === 0 : n.isZeroWithTolerance(i.tolerance);
}
function fd(e12, n) {
  let i = e12.unknowns, t = n.unknowns;
  if (i.length !== t.length) return false;
  for (let r of i) if (!t.includes(r)) return false;
  return true;
}
function $r(e12, n = []) {
  let i = n.map((o, a) => !o.symbol || o.symbol === "Nothing" ? `_${a + 1}` : o.symbol), t = e12.unknowns;
  t.includes("_") && (e12 = e12.subs({ _: "_1" }), t = e12.unknowns);
  let r = i.length;
  for (let o of t) if (o.startsWith("_")) {
    let a = Number(o.slice(1));
    a <= i.length && (e12 = e12.subs({ [o]: i[a - 1] })), a > r && (r = a);
  }
  for (let o = i.length; o < r; o++) i.push(`_${o + 1}`);
  let s = r;
  for (; s > 0 && i[s - 1] === `_${s}`; ) {
    t.includes(`_${s}`) || i.pop();
    s--;
  }
  return [e12, ...i];
}
function ho(e12) {
  let n = e12.engine;
  if (e12.symbol) {
    let a = n.lookupFunction(e12.symbol);
    if (a) {
      let u = a.evaluate;
      return u ? (l) => {
        var _a2;
        return (_a2 = u(l, { engine: n })) != null ? _a2 : n._fn(e12.symbol, l);
      } : (l) => n._fn(e12.symbol, l);
    }
  }
  let i;
  e12.operator === "Function" ? i = $r(e12.op1, e12.ops.slice(1)) : i = $r(e12);
  let [t, ...r] = i;
  n.pushScope();
  for (let a of r) n.declare(a, { inferred: true, type: "unknown" });
  let s = t.canonical;
  s.bind(), n.popScope();
  let o = s.scope;
  return o ? r.length === 0 ? () => {
    var _a2;
    let a = n.swapScope(o);
    n.resetContext();
    let u = (_a2 = s.N()) != null ? _a2 : s.evaluate();
    return n.swapScope(a), u;
  } : (a) => {
    if (a.length > r.length || n.strict && !a.every((c) => c.isValid)) return;
    if (a.length < r.length) {
      let c = r.slice(a.length).map((m, y) => n.symbol(`_${y + 1}`)), p = Qi(n.function("Function", [t, ...r]), [...a, ...c]).evaluate();
      return n.function("Function", [p]);
    }
    a = a.map((c) => c.evaluate());
    let u = n.swapScope(o);
    n.resetContext();
    let l = 0;
    for (let c of r) n.assign(c, a[l++]);
    let f = s.evaluate();
    return n.swapScope(u), f.isValid ? f : void 0;
  } : () => {
    var _a2;
    return (_a2 = s.N()) != null ? _a2 : s.evaluate();
  };
}
function Qi(e12, n) {
  var _a2;
  let i = (_a2 = ho(e12)) == null ? void 0 : _a2(n);
  return i || e12.engine.function("Apply", [e12, ...n]);
}
function ze(e12) {
  var _a2;
  return (_a2 = ho(e12)) != null ? _a2 : (n) => e12.engine.function("Apply", [e12.N(), ...n]).N();
}
function go(e12) {
  let n = e12.engine, i = ho(e12);
  return i ? (t) => {
    var _a2, _b;
    return (_b = (_a2 = i([n.number(t)])) == null ? void 0 : _a2.value) != null ? _b : NaN;
  } : (t) => n.function("Apply", [e12.evaluate(), n.number(t)]).value;
}
function xo(e12) {
  let n = e12.match(/(.+)\((.*)\)/);
  if (!n) return [e12, void 0];
  let i = n[1], t = n[2].split(",").map((r) => r.trim());
  return [i, t];
}
function Xi(e12) {
  if (e12.operator === "Interval") {
    let n = e12.op1, i = e12.op2, t = false, r = false;
    n.operator === "Open" ? (t = true, n = n.op1) : n.operator === "Closed" && (n = n.op1), i.operator === "Open" ? (r = true, i = i.op1) : i.operator === "Closed" && (i = i.op1);
    let s = n.N(), o = i.N();
    return !s.isNumberLiteral || !o.isNumberLiteral ? void 0 : { start: s.re, openStart: t, end: o.re, openEnd: r };
  }
  if (e12.symbol === "EmptySet") return { start: 0, openStart: true, end: 0, openEnd: true };
  if (e12.symbol === "RealNumbers") return { start: -1 / 0, openStart: false, end: 1 / 0, openEnd: false };
  if (e12.symbol === "NegativeNumbers") return { start: -1 / 0, openStart: false, end: 0, openEnd: true };
  if (e12.symbol === "NonPositiveNumbers") return { start: -1 / 0, openStart: false, end: 0, openEnd: false };
  if (e12.symbol === "PositiveNumbers") return { start: 0, openStart: true, end: 1 / 0, openEnd: false };
  if (e12.symbol === "NonNegativeNumbers") return { start: 0, openStart: false, end: 1 / 0, openEnd: false };
}
var Vt = 50;
var bl = { List: { complexity: 8200, signature: "(...any) -> list", type: (e12) => k(`list<${ke(...e12.map((n) => n.type.type))}>`), canonical: cd, eq: yl, collection: yo() }, Set: { complexity: 8200, signature: "(...any) -> set", type: (e12) => k(`set<${ke(...e12.map((n) => n.type.type))}>`), canonical: pd, eq: (e12, n) => {
  if (e12.operator !== n.operator || e12.nops !== n.nops) return false;
  let i = (t) => n.ops.some((r) => t.isSame(r));
  return e12.ops.every(i);
}, collection: { ...yo(), at: void 0, indexOf: void 0 } }, Dictionary: { complexity: 8200, signature: "(...(string | tuple<string|symbol, expression>)) -> map", type: (e12) => k(`tuple<${Object.entries(bo(e12)).map(([n, i]) => n ? `${n}: ${i.type}` : i.type).join(", ")}>`), canonical: (e12, { engine: n }) => {
  var _a2;
  let i = {};
  for (let t of e12) {
    let r = vo(n, t);
    if (r.operator === "Dictionary") for (let s of r.ops) {
      s.operator;
      let [o, a] = s.ops;
      i[(_a2 = o.string) != null ? _a2 : o.symbol] = a;
    }
  }
  return n._fn("Dictionary", Object.entries(i).map(([t, r]) => n._fn("Tuple", [n.string(t), r])));
}, eq: (e12, n) => {
  if (e12.operator !== n.operator || e12.nops !== n.nops) return false;
  let i = bo(e12.ops), t = bo(n.ops);
  return Object.entries(i).every(([r, s]) => {
    let o = t[r];
    return o && s.isSame(o);
  });
}, collection: { ...yo(), at: (e12, n) => {
}, indexOf: (e12, n) => {
}, elttype: (e12) => k("tuple<string, any>") } }, Range: { complexity: 8200, signature: "(number, number?, step: number?) -> collection<integer>", eq: (e12, n) => {
  if (e12.operator !== n.operator) return false;
  let [i, t, r] = Je(e12), [s, o, a] = Je(n);
  return i === s && t === o && r === a;
}, collection: { size: (e12) => {
  let [n, i, t] = Je(e12);
  return t === 0 ? 0 : !isFinite(n) || !isFinite(i) ? 1 / 0 : 1 + Math.max(0, Math.floor((i - n) / t));
}, contains: (e12, n) => {
  if (!n.type.matches("integer")) return false;
  let i = n.re, [t, r, s] = Je(e12);
  return s === 0 ? false : s > 0 ? i >= t && i <= r : i <= t && i >= r;
}, iterator: (e12, n, i) => {
  let [t, r, s] = Je(e12), o = n != null ? n : 1, a = s === 0 ? 0 : Math.floor((r - t) / s) + 1;
  return i = Math.min(i != null ? i : a, a), i <= 0 ? { next: () => ({ value: void 0, done: true }) } : { next: () => i > 0 ? (i--, { value: e12.engine.number(t + s * (o++ - 1)), done: false }) : { value: void 0, done: true } };
}, at: (e12, n) => {
  if (typeof n != "number") return;
  let [i, t, r] = Je(e12);
  if (!(n < 1 || n > 1 + (t - i) / r)) return e12.engine.number(i + r * (n - 1));
}, indexOf: void 0, subsetOf: (e12, n) => {
  var _a2, _b, _c2;
  if (n.operator === "Range") {
    let [r, s, o] = Je(e12), [a, u, l] = Je(n);
    return r >= a && s <= u && o % l === 0;
  }
  if (!ri(n)) return false;
  let i = n.baseDefinition;
  if (!((_a2 = i == null ? void 0 : i.collection) == null ? void 0 : _a2.iterator) || !((_b = i == null ? void 0 : i.collection) == null ? void 0 : _b.at)) return false;
  let t = 1;
  for (let r of ee(n)) {
    if (!e12.contains(r) || !((_c2 = e12.at(t)) == null ? void 0 : _c2.isSame(r))) return false;
    t++;
  }
  return true;
}, eltsgn: (e12) => {
  let [n, i, t] = Je(e12);
  return t === 0 ? "zero" : t > 0 ? n <= i ? "positive" : "negative" : n >= i ? "positive" : "negative";
}, elttype: (e12) => "finite_integer" } }, Interval: { description: "A set of real numbers between two endpoints. The endpoints may or may not be included.", complexity: 8200, lazy: true, signature: "(expression, expression) -> set<real>", eq: (e12, n) => {
  let i = Xi(e12), t = Xi(n);
  return !i || !t ? false : i.start === t.start && i.end === t.end && i.openStart === t.openStart && i.openEnd === t.openEnd;
}, collection: { size: (e12) => 1 / 0, contains: (e12, n) => {
  let i = Xi(e12);
  return !i || i.openStart && n.isLessEqual(i.start) || i.openEnd && n.isGreaterEqual(i.end) ? false : n.isGreaterEqual(i.start) && n.isLessEqual(i.end);
}, eltsgn: (e12) => {
  let n = Xi(e12);
  if (!n) return "unsgined";
  if (n.start === n.end) return "unsigned";
  if (n.start >= 0 && !n.openStart) return "non-negative";
  if (n.end <= 0 && !n.openEnd) return "non-positive";
  if (n.start > 0 && n.end > 0) return "positive";
  if (n.start < 0 && n.end < 0) return "negative";
}, elttype: (e12) => {
  let n = Xi(e12);
  return n ? isFinite(n.start) && isFinite(n.end) ? "finite_real" : "real" : "never";
} } }, Linspace: { complexity: 8200, signature: "(start: number, end: number?, count: number?) -> collection", collection: { size: (e12) => {
  let n = e12.op3.re;
  return isFinite(n) || (n = Vt), Math.max(0, Math.floor(n));
}, at: (e12, n) => {
  if (typeof n != "number") return;
  let i = e12.op1.re, t = e12.op2.re, r = e12.op3.re;
  if (isFinite(r) || (r = Vt), !(!isFinite(i) || !isFinite(t)) && !(n < 1 || n > r)) return e12.engine.number(i + (t - i) * (n - 1) / r);
}, iterator: (e12, n, i) => {
  let t = e12.op1.re, r = e12.op2.re, s;
  isFinite(r) ? s = Math.max(0, isFinite(e12.op3.re) ? e12.op3.re : Vt) : (r = t, t = 1, s = Vt);
  let o = n != null ? n : 1;
  return i = Math.min(i != null ? i : s, s), i <= 0 ? { next: () => ({ value: void 0, done: true }) } : { next: () => i > 0 ? (i--, { value: e12.engine.number(t + (r - t) * (o++ - 1) / s), done: false }) : { value: void 0, done: true } };
}, contains: (e12, n) => {
  if (!n.type.matches("finite_real")) return false;
  let i = n.re, t = e12.op1.re, r = e12.op2.re;
  if (i < t || i > r) return false;
  let s = e12.op3.re;
  if (isFinite(s) || (s = Vt), s === 0) return false;
  let o = (r - t) / s;
  return (i - t) % o === 0;
} } }, Tuple: { description: "A fixed number of heterogeneous elements", complexity: 8200, signature: "(...any) -> tuple", type: (e12) => k(`tuple<${e12.map((n) => n.type).join(", ")}>`), canonical: (e12, { engine: n }) => n.tuple(...e12), eq: yl, collection: { size: (e12) => e12.nops, contains: (e12, n) => e12.ops.some((i) => i.isSame(n)), keys: (e12) => ["first", "second", "last"], at: (e12, n) => {
  if (typeof n == "number") return e12.ops[n - 1];
} } }, KeyValuePair: { description: "A key/value pair", complexity: 8200, signature: "(key: string, value: any) -> tuple<string, unknown>", type: ([e12, n]) => k(`tuple<string, ${n.type}>`), canonical: (e12, { engine: n }) => {
  let [i, t] = Sr(n, e12, ["string", "any"]);
  return !i.isValid || !t.isValid ? n._fn("KeyValuePair", [i, t]) : n.tuple(i, t);
} }, Single: { description: "A tuple with a single element", complexity: 8200, signature: "(value: any) -> tuple<any>", type: ([e12]) => k(`tuple<${e12.type}>`), canonical: (e12, { engine: n }) => n.tuple(...qe(n, e12, 1)) }, Pair: { description: "A tuple of two elements", complexity: 8200, signature: "(first: any, second: any) -> tuple<any, any>", type: ([e12, n]) => k(`tuple<${e12.type}, ${n.type}>`), canonical: (e12, { engine: n }) => n.tuple(...qe(n, e12, 2)) }, Triple: { description: "A tuple of three elements", complexity: 8200, signature: "(first: any, second: any, third: any) -> tuple<any, any, any>", type: ([e12, n, i]) => k(`tuple<${e12.type}, ${n.type}, ${i.type}>`), canonical: (e12, { engine: n }) => n.tuple(...qe(n, e12, 3)) }, String: { threadable: true, signature: "(...any) -> string", evaluate: (e12, { engine: n }) => e12.length === 0 ? n.string("") : n.string(e12.map((i) => {
  var _a2;
  return (_a2 = i.string) != null ? _a2 : i.toString();
}).join("")) }, Length: { complexity: 8200, signature: "any -> integer", evaluate: ([e12], { engine: n }) => n.number(et(e12)), sgn: ([e12]) => et(e12) === 0 ? "zero" : "positive" }, IsEmpty: { complexity: 8200, signature: "any -> boolean", evaluate: ([e12], { engine: n }) => et(e12) === 0 ? n.True : n.False }, At: { description: ["Access an element of a collection or a character of a string.", "If the index is negative, it is counted from the end.", "If the collection has a rank greater than 1, the index is a tuple of indexes.", "If the index is a list, each element of the list is used as an index and the result if a list of the elements."], complexity: 8200, signature: "(value: list|tuple|string, index: number | string) -> unknown", evaluate: (e12, { engine: n }) => {
  var _a2, _b, _c2, _d2;
  let i = e12[0], t = 1;
  for (; e12[t]; ) {
    let s = (_b = (_a2 = i.baseDefinition) == null ? void 0 : _a2.collection) == null ? void 0 : _b.at;
    if (!s) return;
    let o = e12[t].string;
    if (o !== null) i = (_c2 = s(i, o)) != null ? _c2 : n.Nothing;
    else {
      let a = e12[t].re;
      if (!Number.isInteger(a)) return;
      i = (_d2 = s(i, a)) != null ? _d2 : n.Nothing;
    }
    t += 1;
  }
  return i;
} }, Take: { description: ["Take a range of elements from a collection or a string.", "If the index is negative, it is counted from the end."], complexity: 8200, signature: "(value: collection|string, count: number) -> list|string", type: (e12) => e12[0].type.matches("string") ? "string" : k(`list<${ei(e12[0].type.type)}>`), evaluate: (e12, { engine: n }) => {
  if (e12.length < 2) return;
  let i = e12[0].string;
  if (i !== null) {
    let r = e12.slice(1).map((s) => Ki(s, i.length));
    return n.string(ml(i, r));
  }
  let t = et(e12[0]);
  return zt(e12[0], e12.slice(1).map((r) => Ki(r, t)));
} }, Drop: { complexity: 8200, signature: "(value: collection|string, indexes: ...(number | string)) -> list", evaluate: (e12, { engine: n }) => {
  var _a2;
  if (e12.length < 2) return;
  let i = e12[0].string;
  if (i !== null) {
    let u = hl(e12.slice(1).map((l) => Ki(l, i.length)));
    return n.string(i.split("").filter((l, f) => !u.includes(f + 1)).join(""));
  }
  let t = e12[0].baseDefinition, r = et(e12[0]);
  if (r === 0) return n.Nothing;
  let s = (_a2 = t == null ? void 0 : t.collection) == null ? void 0 : _a2.at;
  if (!s) return;
  let o = hl(e12.slice(1).map((u) => Ki(u, r))), a = [];
  for (let u = 1; u <= r; u++) if (!o.includes(u)) {
    let l = s(e12[0], u);
    l && a.push(l);
  }
  return n.function("List", a);
} }, First: { complexity: 8200, signature: "(value: collection|string) -> any", evaluate: ([e12], { engine: n }) => {
  var _a2;
  return (_a2 = Eo(e12, 1)) != null ? _a2 : n.Nothing;
} }, Second: { complexity: 8200, signature: "(value: collection|string) -> any", evaluate: ([e12], { engine: n }) => {
  var _a2;
  return (_a2 = Eo(e12, 2)) != null ? _a2 : n.Nothing;
} }, Last: { complexity: 8200, signature: "(value: collection|string) -> any", evaluate: ([e12], { engine: n }) => {
  var _a2;
  return (_a2 = Eo(e12, -1)) != null ? _a2 : n.Nothing;
} }, Rest: { complexity: 8200, signature: "(value: collection|string) -> list", evaluate: (e12) => zt(e12[0], [[2, -1, 1]]) }, Slice: { description: ["Return a range of elements from a collection or a string.", "If the index is negative, it is counted from the end."], complexity: 8200, signature: "(value: collection|string, start: number, end: number) -> list|string", type: (e12) => e12[0].type.matches("string") ? "string" : k(`list<${ei(e12[0].type.type)}>`), evaluate: (e12, { engine: n }) => {
  if (e12.length < 3) return;
  let i = e12[0].string;
  if (i !== null) {
    let [o, a] = e12.slice(1).map((u) => Ki(u, i.length));
    return n.string(ml(i, [o, a]));
  }
  let t = et(e12[0]), [r, s] = e12.slice(1).map((o) => Ki(o, t));
  return zt(e12[0], [r, s]);
} }, Most: { complexity: 8200, signature: "(value: collection|string) -> list", evaluate: (e12) => zt(e12[0], [[1, -2, 1]]) }, Reverse: { complexity: 8200, signature: "(value: collection|string) -> collection", type: (e12) => e12[0].type, evaluate: ([e12]) => zt(e12, [[-1, 2, 1]]) }, Ordering: { complexity: 8200, lazy: true, signature: "(value: collection, f: function?) -> list<integer>", evaluate: (e12) => {
} }, Sort: { complexity: 8200, lazy: true, signature: "(value: collection, f: function?) -> collection", type: (e12) => e12[0].type, evaluate: (e12) => {
} }, Shuffle: { complexity: 8200, signature: "(value: collection) -> collection", type: (e12) => e12[0].type, evaluate: (e12) => {
} }, Map: { complexity: 8200, lazy: true, signature: "(collection, function) -> collection", evaluate: (e12, { engine: n }) => {
  var _a2, _b;
  let [i, t] = dd(e12);
  if (!t) return;
  let r = [];
  for (let a of i) r.push((_a2 = t([a])) != null ? _a2 : n.Nothing);
  let s = e12[0].operator, o = (_b = { List: "List", Set: "Set", Range: "List", Linspace: "List", Single: "List", Pair: "List", Triple: "List", Tuple: "List", String: "String" }[s]) != null ? _b : "List";
  return n.function(o, r);
} }, Filter: { complexity: 8200, lazy: true, signature: "(collection, function) -> collection", type: (e12) => e12[0].type, evaluate: (e12, { engine: n }) => {
  var _a2, _b;
  let i = ze(e12[1]);
  if (!i) return;
  let t = e12[0];
  if (t.string) return n.string(t.string.split("").map((a) => {
    var _a3;
    return ((_a3 = i([n.string(a)])) == null ? void 0 : _a3.symbol) === "True" ? a : "";
  }).join(""));
  if (!ie(e12[0]) || !e12[1]) return;
  let r = [];
  for (let a of ee(t)) ((_a2 = i([a])) == null ? void 0 : _a2.symbol) === "True" && r.push(a);
  let s = t.operator, o = (_b = { List: "List", Set: "Set", Range: "List", Linspace: "List", Single: "List", Pair: "List", Triple: "List", Tuple: "List" }[s]) != null ? _b : "List";
  return n.function(o, r);
} }, Reduce: { complexity: 8200, lazy: true, signature: "(collection, function, initial:value) -> collection", evaluate: (e12) => {
} }, Tabulate: { complexity: 8200, lazy: true, signature: "(function, integer, integer?) -> collection", evaluate: (e12, { engine: n }) => {
  var _a2;
  let i = ze(e12[0]);
  if (!i) return;
  if (e12.length === 1) return n._fn("List", []);
  let t = e12.slice(1).map((s) => G(s));
  if (t.some((s) => s === null || s <= 0)) return;
  if (t.length === 1) return n._fn("List", Array.from({ length: (_a2 = t[0]) != null ? _a2 : 0 }, (s, o) => {
    var _a3;
    return (_a3 = i([n.number(o + 1)])) != null ? _a3 : n.Nothing;
  }));
  let r = (s, o, a = 0) => {
    if (a === s.length) {
      let l = o.map((f) => n.number(f));
      return i(l);
    }
    let u = ["List"];
    for (let l = 1; l <= s[a]; l++) o[a] = l, u.push(r(s, o, a + 1));
    return u;
  };
  return n.box(r(t, Array(t.length).fill(0)));
} }, Tally: { complexity: 8200, signature: "(collection) -> tuple<list, list<integer>>", type: (e12) => k(`tuple<list<${ei(e12[0].type.type)}>, list<integer>>`), evaluate: (e12, { engine: n }) => {
  if (!ri(e12[0])) return;
  let [i, t] = gl(e12[0]);
  return n.tuple(n.function("List", i), n.function("List", t));
} }, Unique: { complexity: 8200, signature: "(collection) -> list", type: (e12) => k(`list<${ei(e12[0].type.type)}>`), evaluate: (e12, { engine: n }) => {
  if (!ri(e12[0])) return;
  let [i, t] = gl(e12[0]);
  return n.function("List", i);
} }, Zip: { complexity: 8200, signature: "(collection, ...collection) -> list", evaluate: (e12) => {
} }, RotateLeft: { complexity: 8200, signature: "(collection, integer?) -> collection", evaluate: (e12) => {
} }, RotateRight: { complexity: 8200, signature: "(collection, integer?) -> collection", evaluate: (e12) => {
} }, Join: { description: ["Join the elements of a sequence of collections or scalar values.", "If all collections are `Set`, return a `Set`.", "If all collections are `Map`, return a `Map`."], complexity: 8200, signature: "(...any) -> collection", type: xl, evaluate: (e12, { engine: n }) => {
  let i = xl(e12);
  if (v(i, "map")) {
    let t = {};
    for (let r of e12) if (t = vl(t, r), !t) return;
    return n._fn("Dictionary", Object.entries(t).map(([r, s]) => n._fn("Tuple", [n.string(r), s])));
  }
  if (v(i, "set")) {
    let t = [];
    for (let r of e12) if (t = Tl(t, r), !t) return;
    return n.function("Set", t);
  }
  if (v(i, "list")) {
    let t = [];
    for (let r of e12) if (t = Sl(t, r), !t) return;
    return n.function("List", t);
  }
} }, Iterate: { complexity: 8200, signature: "(function, initial: any?) -> list", evaluate: (e12) => {
} }, Repeat: { complexity: 8200, signature: "(value: any) -> list", type: (e12) => k(`collection<${e12[0].type}>`), evaluate: (e12) => {
} }, Cycle: { complexity: 8200, signature: "(list) -> list", type: (e12) => k(`list<${e12[0].type}>`), evaluate: (e12) => {
} }, Fill: { complexity: 8200, signature: "(function, tuple) -> list", evaluate: (e12) => {
} } };
function Je(e12) {
  if (e12.nops === 0) return [1, 0, 0];
  let n = Math.round(e12.op1.re);
  if (isFinite(n) || (n = 1), e12.nops === 1) return [1, n, 1];
  let i = Math.round(e12.op2.re);
  if (isFinite(i) || (i = 1), e12.nops === 2) return [n, i, i > n ? 1 : -1];
  let t = Math.abs(Math.round(e12.op3.re));
  return isFinite(t) || (t = 1), [n, i, n < i ? t : -t];
}
function El(e12) {
  let [n, i, t] = e12;
  return Number.isFinite(i) ? t > 0 ? i - (i - n) % t : i + (n - i) % t : t > 0 ? 1 / 0 : -1 / 0;
}
function Ki(e12, n) {
  if (!e12) return [0, 0, 0];
  let i = e12.re;
  if (isFinite(i)) {
    if (i = Math.round(i), i < 0) {
      if (n === void 0) return [0, 0, 0];
      i = n + i + 1;
    }
    return [i, i, 1];
  }
  let t = e12.operator;
  if (!t || typeof t != "string" || !/^(Single|Pair|Triple|Tuple|)$/.test(t)) return [0, 0, 0];
  let [r, s, o] = Je(e12);
  return (r < 0 || s < 0) && n === void 0 ? [0, 0, 0] : (r < 0 && (r = n + r + 1), s < 0 && (s = n + s + 1), o = Math.abs(Math.round(o)), o === 0 ? [0, 0, 0] : (r > s && (o = -o), [r, s, o]));
}
function zt(e12, n) {
  var _a2, _b;
  let i = e12.engine, r = (_b = (_a2 = e12.baseDefinition) == null ? void 0 : _a2.collection) == null ? void 0 : _b.at;
  if (!r) return i.Nothing;
  let s = [];
  for (let o of n) {
    let [a, u, l] = o;
    if (l !== 0) if (l < 0) for (let f = a; f >= u; f += l) {
      let c = r(e12, f);
      c && s.push(c);
    }
    else for (let f = a; f <= u; f += l) {
      let c = r(e12, f);
      c && s.push(c);
    }
  }
  return i.function("List", s);
}
function ml(e12, n) {
  let i = "";
  for (let t of n) {
    let [r, s, o] = t;
    if (o === 1) i += e12.slice(r - 1, s);
    else if (o < 0) for (let a = r; a >= s; a += o) i += e12[a - 1];
    else for (let a = r; a <= s; a += o) i += e12[a - 1];
  }
  return i;
}
function hl(e12) {
  let n = [];
  for (let i of e12) {
    let [t, r, s] = i;
    if (s !== 0) if (s < 0) for (let o = t; o >= r; o += s) n.push(o);
    else for (let o = t; o <= r; o += s) n.push(o);
  }
  return n;
}
function cd(e12, { engine: n }) {
  let i = e12[0];
  if (e12.length === 1 && i.operator === "Matrix") {
    let [t, r, s] = i.ops;
    if (!r || r.string === "..") return s ? n._fn("Matrix", [t, n.string("[]"), s]) : n._fn("Matrix", [t, r]);
  }
  return e12 = e12.map((t) => {
    var _a2, _b;
    return t.operator === "Delimiter" ? t.op1.operator === "Sequence" ? n._fn("List", Fe(n, t.op1.ops)) : n._fn("List", [(_b = (_a2 = t.op1) == null ? void 0 : _a2.canonical) != null ? _b : n.Nothing]) : t.canonical;
  }), n._fn("List", e12);
}
function pd(e12, { engine: n }) {
  let i = [], t = (r) => i.some((s) => s.isSame(r));
  for (let r of e12) t(r) || i.push(r);
  return n._fn("Set", i);
}
function dd(e12) {
  if (e12.length !== 2) return [[], void 0];
  let n = ze(e12[1]);
  return n ? e12[0].string ? [[e12[0]], (i) => {
    let t = i[0].string;
    if (t === null) return;
    let r = i[0].engine;
    return r.string(t.split("").map((s) => {
      var _a2, _b;
      return (_b = (_a2 = n([r.string(s)])) == null ? void 0 : _a2.string) != null ? _b : "";
    }).join(""));
  }] : !ie(e12[0]) || !e12[1] ? [[], void 0] : [ee(e12[0]), n] : [[], void 0];
}
function gl(e12) {
  let n = [], i = [], t = (r) => {
    for (let s = 0; s < n.length; s++) if (n[s].isSame(r)) return s;
    return -1;
  };
  for (let r of ee(e12)) {
    let s = t(r);
    s >= 0 ? i[s]++ : (n.push(r), i.push(1));
  }
  return [n, i];
}
function* Nl(e12, n, i) {
  let t = i, r = 0;
  for (let s of ee(e12)) {
    let o = n(t, s);
    if (o === null) return;
    r += 1, r % 1e3 === 0 && (yield t), t = o;
  }
  return t;
}
function xl(e12) {
  return e12.some((n) => n.type.matches("map")) ? "map" : e12.some((n) => n.type.matches("set")) ? "set" : "list";
}
function vl(e12, n) {
  if (n.operator === "KeyValuePair") {
    let i = n.op1.string;
    return i ? (e12[i] = n.op2, e12) : void 0;
  }
  if (n.operator === "Tuple") {
    let [i, t] = n.ops;
    return i.string ? (e12[i.string] = t, e12) : void 0;
  }
  if (n.operator === "List" || n.operator === "Set" || n.operator === "Dictionary") {
    for (let i of n.ops) {
      let t = vl(e12, i);
      if (!t) return;
      e12 = t;
    }
    return e12;
  }
}
function Tl(e12, n) {
  if (n.operator === "Set" || n.operator === "List") {
    for (let t of n.ops) if (e12 = Tl(e12, t), !e12) return;
  }
  return ((t) => e12.some((r) => r.isSame(t)))(n) || e12.push(n), e12;
}
function Sl(e12, n) {
  if (n.operator === "List" || n.operator === "Set") {
    for (let i of n.ops) if (e12 = Sl(e12, i), !e12) return;
  }
  return e12.push(n), e12;
}
function md(e12, n, i) {
  var _a2, _b, _c2;
  if (e12.string && n.string) return i && e12.string === n.string ? false : (_c2 = (_b = e12.string) == null ? void 0 : _b.includes((_a2 = n.string) != null ? _a2 : "")) != null ? _c2 : false;
  if (!e12.isCollection || !n.isCollection) return false;
  for (let t of ee(e12)) if (!n.contains(t)) return false;
  if (i) {
    let t = e12.size, r = n.size;
    if (t === r || t === void 0 || r === void 0) return false;
  }
  return true;
}
function yo() {
  return { size: (e12) => e12.nops, contains: (e12, n) => e12.ops.some((i) => i.isSame(n)), iterator: (e12, n, i) => {
    let t = (n != null ? n : 1) - 1;
    return i = Math.min(i != null ? i : e12.nops, e12.nops), { next: () => i <= 0 ? { value: void 0, done: true } : (i--, { value: e12.ops[t++], done: false }) };
  }, at: (e12, n) => {
    if (typeof n == "number" && !(n < 1 || n > e12.nops)) return e12.ops[n - 1];
  }, keys: (e12) => [], indexOf: (e12, n, i) => {
    if (i != null ? i : i = 1, i < 0) {
      if (i < -e12.nops) return;
      i = e12.nops + i + 1;
      for (let t = i; t >= 1; t--) if (e12.ops[t - 1].isSame(n)) return t;
      return;
    }
    for (let t = i; t <= e12.nops; t++) if (e12.ops[t - 1].isSame(n)) return t;
  }, subsetOf: md, eltsgn: (e12) => {
  }, elttype: (e12) => e12.nops === 0 ? "unknown" : e12.nops === 1 ? e12.ops[0].type.type : ke(...e12.ops.map((n) => n.type.type)) };
}
function bo(e12) {
  var _a2, _b;
  let n = {}, i = 1;
  for (let t of e12) {
    if (t.operator === "KeyValuePair" || t.operator === "Tuple" || t.operator === "Pair") {
      let [r, s] = t.ops;
      if (r.symbol === "Nothing") continue;
      n[(_b = (_a2 = r == null ? void 0 : r.string) != null ? _a2 : r == null ? void 0 : r.toString()) != null ? _b : i.toString()] = s != null ? s : t.engine.Nothing;
    } else n[i.toString()] = t;
    i += 1;
  }
  return n;
}
function et(e12) {
  var _a2;
  if (e12.operator === "List" || e12.operator === "Set") return e12.nops;
  let n = e12.baseDefinition;
  if ((_a2 = n == null ? void 0 : n.collection) == null ? void 0 : _a2.size) return n.collection.size(e12);
  let i = e12.string;
  return i !== null ? i.length : 0;
}
function Eo(e12, n) {
  var _a2;
  let i = e12.baseDefinition;
  if ((_a2 = i == null ? void 0 : i.collection) == null ? void 0 : _a2.at) return i.collection.at(e12, n);
}
function yl(e12, n) {
  return e12.operator !== n.operator || e12.nops !== n.nops ? false : e12.ops.every((i, t) => i.isSame(n.ops[t]));
}
function No(e12, n) {
  return Array.from({ length: n - e12 + 1 }, (i, t) => e12 + t);
}
function vo(e12, n) {
  if (n.string && n.string[0] === "{" && n.string[n.string.length - 1] === "}") {
    let i;
    try {
      i = Oi.parse(n.string);
    } catch (e13) {
      return e12._fn("Dictionary", []);
    }
    return typeof i != "object" ? e12._fn("Dictionary", []) : e12._fn("Dictionary", Object.entries(i).map(([t, r]) => e12._fn("Tuple", [e12.string(t), e12.box(r)])));
  }
  if (n.operator === "Tuple" || n.operator === "Pair" || n.operator === "KeyValuePair") {
    let [i, t] = n.ops, r;
    if (i.string) r = i.string;
    else if (i.symbol) r = i.symbol;
    else return e12._fn("Dictionary", []);
    return e12._fn("Dictionary", [e12._fn("Tuple", [e12.string(r), t.canonical])]);
  }
  if (n.operator === "Dictionary") {
    let i = {};
    for (let t of n.ops) if (t.operator === "KeyValuePair" || t.operator === "Pair" || t.operator === "Tuple") {
      let [r, s] = t.ops, o;
      if (r.string) o = r.string;
      else if (r.symbol) o = r.symbol;
      else return e12._fn("Dictionary", []);
      i[o] = s.canonical;
    }
    return e12._fn("Dictionary", Object.entries(i).map(([t, r]) => e12._fn("Tuple", [e12.string(t), r])));
  }
  return e12._fn("Dictionary", []);
}
function nt(e12) {
  var _a2;
  e12 == null ? void 0 : e12.operator;
  let n = 1, i = n + Et, t, r = true;
  return t = e12.op1.symbol, n = Math.floor(e12.op2.re), isNaN(n) && (n = 1), Number.isFinite(n) || (r = false), e12.op3.symbol === "Nothing" || e12.op3.isInfinity ? r = false : (isNaN(e12.op3.re) || (i = Math.floor((_a2 = e12.op3.re) != null ? _a2 : i)), Number.isFinite(i) || (r = false)), !r && Number.isFinite(n) && (i = n + Et), { index: t, lower: n, upper: i, isFinite: r };
}
function hd(e12) {
  return e12.map((n) => nt(n));
}
function gd(e12) {
  e12.length > 0;
  let { index: n, lower: i, upper: t, isFinite: r } = e12[0];
  r || (t = i + Et);
  let s = No(i, t).map((o) => [o]);
  if (e12.length === 1) return s;
  for (let o = 1; o < e12.length; o++) {
    let { index: a, lower: u, upper: l, isFinite: f } = e12[o];
    f || (l = u + Et), s = xd(s.map((c) => c[0]), No(u, l));
  }
  return s;
}
function xd(e12, n) {
  return e12.flatMap((i) => n.map((t) => [i, t]));
}
function yd(e12) {
  var _a2, _b, _c2, _d2;
  let n = e12.engine, i, t = null, r = null;
  if (e12.operator === "Tuple" || e12.operator === "Triple" || e12.operator === "Pair" || e12.operator === "Single" ? (i = e12.op1, r = (_b = (_a2 = e12.ops[1]) == null ? void 0 : _a2.canonical) != null ? _b : null, t = (_d2 = (_c2 = e12.ops[2]) == null ? void 0 : _c2.canonical) != null ? _d2 : null) : i = e12, i.operator === "Hold" && (i = i.op1), !!i.symbol) return i.symbol && i.symbol !== "Nothing" && n.declare(i.symbol, "integer"), t && r ? n.tuple(i, r, t) : t ? n.tuple(i, n.One, t) : r ? n.tuple(i, r) : n.tuple(i);
}
function To(e12, n, i) {
  let t = n.engine;
  t.pushScope(), n != null ? n : n = t.error("missing");
  let r = i.map((o) => yd(o)).filter((o) => o !== void 0), s = t._fn(e12, [n.canonical, ...r]);
  return t.popScope(), s;
}
function* Gt(e12, n, i, t) {
  var _a2, _b;
  if (e12.isCollection) return yield* Nl(e12.evaluate(), i, t);
  if (n.length === 0) return (_a2 = i(t, e12)) != null ? _a2 : void 0;
  let r = e12.engine, s = r.swapScope(e12.scope), o = hd(n), a = gd(o), u = t, l = 0;
  for (let f of a) if (o.forEach((c, p) => r.assign(c.index, f[p])), u = (_b = i(u, e12)) != null ? _b : void 0, l += 1, l % 1e3 === 0 && (yield u), u === void 0) break;
  for (let f of o) r.assign(f.index, void 0);
  return r.swapScope(s), u != null ? u : void 0;
}
function So(e12) {
  if (e12 !== void 0) return isNaN(e12) ? "unsigned" : e12 > 0 ? "positive" : e12 < 0 ? "negative" : "zero";
}
function _o(e12) {
  return e12 === "positive" ? "negative" : e12 === "non-negative" ? "non-positive" : e12 === "negative" ? "positive" : e12 === "non-positive" ? "non-negative" : e12;
}
function it(e12) {
  if (e12.isGreater(1)) return "positive";
  if (e12.isGreaterEqual(1)) return "non-negative";
  if (e12.isLessEqual(1) && e12.isGreaterEqual(0)) return "non-positive";
  if (e12.isLess(1) && e12.isGreaterEqual(0)) return "negative";
  if (e12.is(1)) return "zero";
  if (e12.isNegative || e12.isReal === false) return "unsigned";
}
var Il = [{ Abs: { wikidata: "Q3317982", threadable: true, idempotent: true, complexity: 1200, signature: "number -> number", type: ([e12]) => e12.type, sgn: ([e12]) => e12.is(0) ? "zero" : e12.isNumberLiteral ? "positive" : "non-negative", evaluate: ([e12]) => bd(e12) }, Add: { wikidata: "Q32043", associative: true, commutative: true, commutativeOrder: At, threadable: true, idempotent: true, complexity: 1300, lazy: true, signature: "(number, ...number) -> number", type: cl, sgn: (e12) => {
  if (e12.some((n) => n.isNaN)) return "nan";
  if (e12.some((n) => n.isReal === false)) return "unsigned";
  if (e12.every((n) => n.is(0))) return "zero";
  if (e12.every((n) => n.isNonNegative)) return e12.some((n) => n.isPositive) ? "positive" : "non-negative";
  if (e12.every((n) => n.isNonPositive)) return e12.some((n) => n.isNegative) ? "negative" : "non-positive";
  if (e12.every((n) => n.isReal)) return "real";
}, evaluate: (e12, { numericApproximation: n }) => n ? pl(...e12) : H(...e12.map((i) => i.evaluate())) }, Ceil: { description: "Rounds a number up to the next largest integer", complexity: 1250, threadable: true, signature: "real -> integer", sgn: ([e12]) => {
  if (e12.isLessEqual(-1)) return "negative";
  if (e12.isPositive) return "positive";
  if (e12.isNonNegative) return "non-negative";
  if (e12.isNonPositive && e12.isGreater(-1)) return "zero";
  if (e12.isNonPositive) return "non-positive";
  if (e12.isReal == false && e12.isNumberLiteral) return e12.im > 0 || e12.im <= -1 ? "unsigned" : So(e12.re);
}, evaluate: ([e12]) => Q(e12, Math.ceil, (n) => n.ceil(), (n) => n.ceil(0)) }, Chop: { associative: true, threadable: true, idempotent: true, complexity: 1200, signature: "number -> number", type: ([e12]) => e12.type, evaluate: (e12) => {
  let n = e12[0], i = n.engine;
  return Q(n, (t) => i.chop(t), (t) => i.chop(t), (t) => i.complex(i.chop(t.re), i.chop(t.im)));
} }, Divide: { wikidata: "Q1226939", complexity: 2500, threadable: true, signature: "(number, ...number) -> number", type: ([e12, n]) => n.is(1) ? e12.type : n.isNaN || e12.isNaN ? "number" : n.isFinite === false || e12.isFinite === false ? "non_finite_number" : n.isInteger && e12.isInteger ? "finite_rational" : n.isReal && e12.isReal ? "finite_real" : "finite_number", sgn: (e12) => {
  let [n, i] = [e12[0], e12[1]];
  if (i.is(0)) return "unsigned";
  if (i.is(0) === false && n.is(0)) return "zero";
  if (i.isPositive) return n.sgn;
  if (i.isNegative) return _o(n.sgn);
  if (n.is(0) || n.isFinite && i.isInfinity) return "zero";
  if (!n.is(0) && !i.is(0)) return "not-zero";
}, canonical: (e12, { engine: n }) => {
  let i = n;
  e12 = Me(i, e12);
  let t = e12[0];
  if (t === void 0) return i.error("missing");
  if (e12.length < 2) return t;
  let r = e12.slice(1);
  for (let s of r) t = He(t, s);
  return t;
}, evaluate: ([e12, n]) => e12.div(n) }, Exp: { wikidata: "Q168698", threadable: true, complexity: 3500, signature: "number -> number", canonical: (e12, { engine: n }) => (e12 = Me(n, e12, 1), n.function("Power", [n.E, ...e12])) }, Factorial: { description: "Factorial function: the product of all positive integers less than or equal to n", wikidata: "Q120976", threadable: true, complexity: 9e3, signature: "integer -> integer", sgn: ([e12]) => e12.isNonNegative ? "positive" : e12.isNegative || e12.isReal === false ? "unsigned" : void 0, canonical: (e12, { engine: n }) => {
  let i = e12[0];
  return i.isNumberLiteral && i.isNegative ? n._fn("Factorial", [i.neg()]).neg() : n._fn("Factorial", [i]);
}, evaluate: ([e12]) => {
  var _a2;
  let n = e12.engine;
  if (e12.im !== 0 && e12.im !== void 0) return n.number(n.complex(e12.re, e12.im).add(1));
  if (e12.isFinite) {
    if (e12.isNegative) return n.number(ci(1 + e12.re));
    try {
      return n.number(Ri(_r(BigInt(((_a2 = e12.bignumRe) != null ? _a2 : e12.re).toFixed())), n._timeRemaining));
    } catch (e13) {
      return;
    }
  }
}, evaluateAsync: async ([e12], { signal: n }) => {
  var _a2, _b;
  let i = e12.engine;
  if (e12.im !== 0 && e12.im !== void 0) return i.number(i.complex(e12.re, e12.im).add(1));
  if (e12.isFinite) {
    if (e12.isNegative) return i.number(ci(1 + e12.re));
    try {
      return i.number(await Ai(_r(BigInt(((_a2 = e12.bignumRe) != null ? _a2 : e12.re).toFixed())), ((_b = i._deadline) != null ? _b : 1 / 0) - Date.now(), n));
    } catch (e13) {
      return;
    }
  }
} }, Factorial2: { description: "Double Factorial Function", complexity: 9e3, threadable: true, signature: "integer -> integer", sgn: ([e12]) => e12.isNonNegative ? "positive" : e12.isNegative || e12.isReal === false ? "unsigned" : void 0, evaluate: (e12) => {
  let n = e12[0], i = G(n);
  if (i === null) return;
  let t = n.engine;
  return oe(t) ? t.number(hu(t, t.bignum(i))) : t.number(Ya(i));
} }, Floor: { wikidata: "Q56860783", complexity: 1250, threadable: true, signature: "number -> integer", sgn: ([e12]) => {
  if (e12.isNegative) return "negative";
  if (e12.isGreaterEqual(1)) return "positive";
  if (e12.isNonNegative && e12.isLess(1)) return "zero";
  if (e12.isNonNegative) return "non-negative";
  if (e12.isReal == false && e12.isNumberLiteral) return e12.im < 0 || e12.im >= 1 ? "unsigned" : So(e12.re);
}, evaluate: ([e12]) => Q(e12, Math.floor, (n) => n.floor(), (n) => n.floor(0)) }, Gamma: { wikidata: "Q190573", complexity: 8e3, threadable: true, signature: "number -> number", sgn: ([e12]) => e12.isPositive ? "positive" : e12.is(0) ? "zero" : void 0, evaluate: ([e12], { numericApproximation: n, engine: i }) => n ? Q(e12, (t) => ci(t), (t) => Ys(i, t), (t) => t) : void 0 }, GammaLn: { complexity: 8e3, threadable: true, signature: "number -> number", evaluate: (e12, { numericApproximation: n, engine: i }) => n ? Q(e12[0], (t) => Mt(t), (t) => Js(i, t), (t) => t) : void 0 }, Ln: { description: "Natural Logarithm", wikidata: "Q204037", complexity: 4e3, threadable: true, signature: "(number, base: number?) -> number", sgn: ([e12]) => it(e12), evaluate: ([e12], { numericApproximation: n, engine: i }) => n ? Q(e12, (t) => t === 0 ? -1 / 0 : t >= 0 ? Math.log(t) : i.complex(t).log(), (t) => t.isZero() ? -1 / 0 : t.isNeg() ? i.complex(t.toNumber()).log() : t.ln(), (t) => t.isZero() ? NaN : t.log()) : e12.ln() }, Log: { description: "Log(z, b = 10) = Logarithm of base b", wikidata: "Q11197", complexity: 4100, threadable: true, signature: "(number, base: number?) -> number", sgn: ([e12, n]) => {
  if (!n) return it(e12);
  if (n.is(1) || n.isReal == false) return "unsigned";
  if (n.isGreater(1)) return it(e12);
  if (n.isLess(1)) return _o(it(e12));
}, evaluate: (e12, { numericApproximation: n, engine: i }) => {
  var _a2, _b, _c2;
  if (!n) return (_c2 = (_b = e12[0]) == null ? void 0 : _b.ln((_a2 = e12[1]) != null ? _a2 : 10)) != null ? _c2 : void 0;
  let t = i;
  return e12[1] === void 0 ? Q(e12[0], (r) => r === 0 ? -1 / 0 : r >= 0 ? Math.log10(r) : t.complex(r).log().div(Math.LN10), (r) => r.isZero() ? -1 / 0 : r.isNeg() ? t.complex(r.toNumber()).log().div(Math.LN10) : M.log10(r), (r) => r.isZero() ? NaN : r.log().div(Math.LN10)) : gn(e12[0], e12[1], (r, s) => Math.log(r) / Math.log(s), (r, s) => r.log(s), (r, s) => r.log().div(typeof s == "number" ? Math.log(s) : s.log()));
} }, Lb: { description: "Base-2 Logarithm", wikidata: "Q581168", complexity: 4100, threadable: true, signature: "(number, base: number?) -> number", sgn: ([e12]) => it(e12), canonical: ([e12], { engine: n }) => n._fn("Log", [e12, n.number(2)]) }, Lg: { description: "Base-10 Logarithm", wikidata: "Q966582", complexity: 4100, threadable: true, signature: "number -> number", sgn: ([e12]) => it(e12), canonical: ([e12], { engine: n }) => n._fn("Log", [e12]) }, Mod: { description: "Modulo", wikidata: "Q1799665", complexity: 2500, threadable: true, signature: "(number, number) -> number", sgn: (e12) => {
  var _a2, _b;
  let n = e12[1];
  if (!(n === void 0 || n.isReal == false)) {
    if (n.is(0)) return "unsigned";
    if (e12[0].isNumberLiteral && n.isNumberLiteral) return (_b = (_a2 = gn(e12[0], n, (t, r) => (t % r + r) % r, (t, r) => t.modulo(r))) == null ? void 0 : _a2.sgn) != null ? _b : void 0;
  }
}, evaluate: ([e12, n]) => gn(e12, n, (i, t) => (i % t + t) % t, (i, t) => i.modulo(t)) }, Multiply: { wikidata: "Q40276", associative: true, commutative: true, idempotent: true, complexity: 2100, threadable: true, lazy: true, signature: "(number, ...number) -> number", type: (e12) => e12.length === 0 ? "finite_integer" : e12.length === 1 ? e12[0].type : e12.some((n) => n.isNaN) ? "number" : e12.some((n) => n.isFinite === false) ? "non_finite_number" : e12.every((n) => n.isInteger) ? "finite_integer" : e12.every((n) => n.isReal) ? "finite_real" : e12.every((n) => n.isRational) ? "finite_rational" : "finite_number", sgn: (e12) => {
  if (!e12.some((n) => n.sgn === void 0 || n.isReal === false)) {
    if (e12.some((n) => n.is(0))) return e12.every((n) => n.isFinite) ? "zero" : e12.some((n) => n.isFinite === false) ? "unsigned" : void 0;
    if (!(e12.some((n) => n.isFinite === false || n.isFinite === void 0) && e12.some((n) => n.is(0) === void 0))) {
      if (e12.every((n) => n.isPositive || n.isNegative)) {
        let n = 0;
        return e12.forEach((i) => {
          i.isNegative && n++;
        }), n % 2 === 0 ? "positive" : "negative";
      }
      if (e12.every((n) => n.isNonPositive || n.isNonNegative)) {
        let n = 0;
        return e12.forEach((i) => {
          i.isNonPositive && n++;
        }), n % 2 === 0 ? "non-positive" : "non-negative";
      }
      if (e12.every((n) => !n.is(0))) return "not-zero";
      if (e12.every((n) => n.isReal)) return "real";
    }
  }
}, evaluate: (e12, { numericApproximation: n }) => n ? ul(...e12) : ae(...e12.map((i) => i.evaluate())) }, Negate: { description: "Additive Inverse", wikidata: "Q715358", complexity: 2e3, threadable: true, signature: "number -> number", type: ([e12]) => e12.type, sgn: ([e12]) => _o(e12.sgn), canonical: (e12, { engine: n }) => (e12 = Me(n, e12), e12.length === 0 ? n.error("missing") : e12[0].neg()), evaluate: ([e12]) => e12.neg() }, PlusMinus: { description: "Plus or Minus", wikidata: "Q120812", complexity: 1200, signature: "(value, value) -> tuple", canonical: (e12, { engine: n }) => (e12 = Me(n, e12, 2), e12.length === 0 ? n.error("missing") : n._fn("PlusMinus", [e12[0], e12[1].abs()])), type: ([e12, n]) => k(`tuple<${e12.type}, ${n.type}>`), evaluate: ([e12, n], { engine: i }) => i.tuple(e12.add(n.neg()), e12.add(n)) }, Power: { wikidata: "Q33456", threadable: true, complexity: 3500, signature: "(number, number) -> number", type: ([e12, n]) => e12.isNaN || n.isNaN ? "number" : n.isFinite ? e12.isInteger && n.isInteger ? "finite_integer" : e12.isRational && n.isInteger ? "finite_rational" : e12.isReal && n.isReal ? "finite_real" : "finite_number" : "non_finite_number", canonical: (e12, { engine: n }) => {
  if (e12 = Me(n, e12, 2), e12.length !== 2) return n._fn("Power", e12);
  let [i, t] = e12;
  return zi(i, t);
}, sgn: ([e12, n]) => {
  let i = e12.sgn, t = n.sgn;
  if (!(e12.isReal === false || n.isReal === false || e12.isNaN || n.isNaN || i === void 0 || t === void 0)) {
    if (e12.is(0)) return n.isNonPositive ? "unsigned" : n.isPositive ? "zero" : void 0;
    if (e12.is(0) && n.is(0)) return "unsigned";
    if (e12.isNonNegative || n.numerator.isOdd && n.denominator.isOdd) return e12.sgn;
    if (n.numerator.isEven && n.denominator.isOdd) return e12.isReal ? e12.is(0) ? "non-negative" : "positive" : e12.type.is("imaginary") ? "negative" : e12.is(0) ? void 0 : "not-zero";
    if (n.isRational === false || n.numerator.isOdd && n.denominator.isEven && e12.isNonPositive) return "unsigned";
  }
}, evaluate: ([e12, n], { numericApproximation: i }) => me(e12, n, { numericApproximation: i != null ? i : false }) }, Rational: { complexity: 2400, signature: "(number, integer?) -> rational", sgn: ([e12]) => e12.sgn, canonical: (e12, { engine: n }) => {
  let i = n;
  return e12 = J(e12), e12.length === 0 ? i._fn("Rational", [i.error("missing")]) : e12.length === 1 ? i._fn("Rational", [In(i, e12[0], "real")]) : (e12 = Sr(i, e12, ["integer", "integer"]), e12.length !== 2 || !e12[0].isValid || !e12[1].isValid ? i._fn("Rational", e12) : e12[0].div(e12[1]));
}, evaluate: (e12, { numericApproximation: n, engine: i }) => {
  let t = i;
  if (e12.length === 1) {
    let o = e12[0].N();
    return o.numericValue === null || o.im !== 0 ? void 0 : t.number(ou(o.re));
  }
  if (n) return gn(e12[0], e12[1], (o, a) => o / a, (o, a) => o.div(a), (o, a) => o.div(a));
  let [r, s] = [G(e12[0]), G(e12[1])];
  if (r !== null && s !== null) return t.number([r, s]);
} }, Root: { complexity: 3200, threadable: true, signature: "(number, number) -> number", type: ([e12, n]) => e12.isNaN || n.isNaN ? "number" : e12.isFinite === false || n.isFinite === false ? "non_finite_number" : n.is(0) ? "finite_integer" : n.is(1) ? e12.type : e12.isReal && n.isReal && e12.isPositive === true ? "finite_real" : "finite_number", sgn: ([e12, n]) => {
  if (e12.isReal === false || n.isReal === false) return "unsigned";
  if (e12.is(0)) return n.is(0) ? "unsigned" : "zero";
  if (e12.isPositive === true) return "positive";
  if (n.isOdd === true) return "negative";
  if (n.isEven === true) return "unsigned";
}, canonical: (e12, { engine: n }) => {
  e12 = Me(n, e12, 2);
  let [i, t] = e12;
  return li(i, t);
}, evaluate: ([e12, n], { numericApproximation: i }) => Rr(e12, n, { numericApproximation: i }) }, Round: { complexity: 1250, threadable: true, signature: "number -> integer", type: ([e12]) => e12.isNaN ? "number" : e12.isFinite === false || e12.isReal === false ? "non_finite_number" : "finite_integer", sgn: ([e12]) => {
  if (e12.isNaN) return "unsigned";
  if (e12.isNumberLiteral) return e12.im >= 0.5 || e12.im <= -0.5 ? "unsigned" : So(Math.round(e12.re));
  if (e12.isGreaterEqual(0.5)) return "positive";
  if (e12.isLessEqual(-0.5)) return "negative";
  if (e12.isLess(0.5) && e12.isGreater(-0.5)) return "zero";
  if (e12.isNonNegative) return "non-negative";
  if (e12.isNonPositive) return "non-positive";
  if (e12.isReal) return "real";
}, evaluate: ([e12]) => Q(e12, Math.round, (n) => n.round(), (n) => n.round(0)) }, Sign: { complexity: 1200, threadable: true, signature: "number -> integer", sgn: ([e12]) => e12.sgn, evaluate: ([e12], { engine: n }) => {
  if (e12.is(0)) return n.Zero;
  if (e12.isPositive) return n.One;
  if (e12.isNegative) return n.NegativeOne;
} }, Sqrt: { description: "Square Root", wikidata: "Q134237", complexity: 3e3, threadable: true, signature: "number -> number", type: ([e12]) => e12.isNaN ? "number" : e12.isFinite === false ? "non_finite_number" : e12.isReal ? "finite_real" : "finite_number", sgn: ([e12]) => {
  if (e12.isPositive) return "positive";
  if (e12.isNegative) return "unsigned";
  if (e12.isNonNegative) return "non-negative";
  if (!e12.is(0)) return "not-zero";
}, evaluate: ([e12], { numericApproximation: n, engine: i }) => {
  if (!n) return e12.sqrt();
  let [t, r] = e12.toNumericValue();
  return r.is(1) ? i.number(t.sqrt().N()) : i.number(t.sqrt().N()).mul(r);
} }, Square: { wikidata: "Q3075175", complexity: 3100, threadable: true, signature: "number -> number", sgn: ([e12]) => {
  if (e12.is(0)) return "zero";
  if (e12.isReal) return e12.is(0) ? "non-negative" : "positive";
  if (e12.type.matches("complex")) return "negative";
  if (e12.isReal === false || e12.isNaN) return "unsigned";
}, canonical: (e12, { engine: n }) => {
  let i = n;
  return e12 = J(e12), e12.length !== 1 ? i._fn("Square", e12) : i._fn("Power", [e12[0], i.number(2)]).canonical;
} }, Subtract: { wikidata: "Q40754", complexity: 1350, threadable: true, signature: "(number, ...number) -> number", canonical: (e12, { engine: n }) => {
  if (e12 = Me(n, e12), e12.length === 0) return n.error("missing");
  let i = e12[0], t = e12.slice(1);
  return Ve(n, [i, ...t.map((r) => r.neg())]);
} } }, { ImaginaryUnit: { type: "imaginary", constant: true, holdUntil: "never", wikidata: "Q193796", value: (e12) => e12.I }, i: { type: "imaginary", constant: true, holdUntil: "never", value: (e12) => e12.I }, ExponentialE: { type: "finite_real", wikidata: "Q82435", constant: true, holdUntil: "N", value: (e12) => e12.number(oe(e12) ? e12._BIGNUM_ONE.exp() : Math.exp(1)) }, e: { type: "finite_real", constant: true, holdUntil: "never", value: "ExponentialE" }, ComplexInfinity: { type: "complex", constant: true, holdUntil: "never", value: (e12) => e12.ComplexInfinity }, PositiveInfinity: { type: "non_finite_number", constant: true, holdUntil: "never", value: 1 / 0 }, NegativeInfinity: { type: "non_finite_number", constant: true, holdUntil: "never", value: -1 / 0 }, NaN: { type: "number", constant: true, holdUntil: "never", value: (e12) => e12.NaN }, MachineEpsilon: { type: "finite_real", holdUntil: "N", constant: true, value: { num: Number.EPSILON.toString() } }, Half: { type: "finite_rational", constant: true, holdUntil: "never", value: ["Rational", 1, 2] }, GoldenRatio: { type: "finite_real", wikidata: "Q41690", constant: true, holdUntil: "N", value: ["Divide", ["Add", 1, ["Sqrt", 5]], 2] }, CatalanConstant: { type: "finite_real", wikidata: "Q855282", constant: true, holdUntil: "N", value: { num: `0.91596559417721901505460351493238411077414937428167
                  21342664981196217630197762547694793565129261151062
                  48574422619196199579035898803325859059431594737481
                  15840699533202877331946051903872747816408786590902
                  47064841521630002287276409423882599577415088163974
                  70252482011560707644883807873370489900864775113225
                  99713434074854075532307685653357680958352602193823
                  23950800720680355761048235733942319149829836189977
                  06903640418086217941101917532743149978233976105512
                  24779530324875371878665828082360570225594194818097
                  53509711315712615804242723636439850017382875977976
                  53068370092980873887495610893659771940968726844441
                  66804621624339864838916280448281506273022742073884
                  31172218272190472255870531908685735423498539498309
                  91911596738846450861515249962423704374517773723517
                  75440708538464401321748392999947572446199754961975
                  87064007474870701490937678873045869979860644874974
                  64387206238513712392736304998503539223928787979063
                  36440323547845358519277777872709060830319943013323
                  16712476158709792455479119092126201854803963934243
                  ` } }, EulerGamma: { type: "finite_real", wikidata: "Q273023", holdUntil: "N", constant: true, value: { num: `0.57721566490153286060651209008240243104215933593992359880576723488486772677766
          467093694706329174674951463144724980708248096050401448654283622417399764492353
          625350033374293733773767394279259525824709491600873520394816567085323315177661
          152862119950150798479374508570574002992135478614669402960432542151905877553526
          733139925401296742051375413954911168510280798423487758720503843109399736137255
          306088933126760017247953783675927135157722610273492913940798430103417771778088
          154957066107501016191663340152278935867965497252036212879226555953669628176388
          792726801324310104765059637039473949576389065729679296010090151251959509222435
          014093498712282479497471956469763185066761290638110518241974448678363808617494
          551698927923018773910729457815543160050021828440960537724342032854783670151773
          943987003023703395183286900015581939880427074115422278197165230110735658339673` } } }, { PreIncrement: { signature: "number -> number" }, PreDecrement: { signature: "number -> number" } }, { IsPrime: { description: "`IsPrime(n)` returns `True` if `n` is a prime number", wikidata: "Q49008", complexity: 1200, threadable: true, signature: "(number) -> boolean", evaluate: ([e12], { engine: n }) => {
  let i = zr(e12);
  if (i !== void 0) return n.symbol(i ? "True" : "False");
} }, IsComposite: { description: "`IsComposite(n)` returns `True` if `n` is not a prime number", complexity: 1200, threadable: true, signature: "(number) -> boolean", canonical: (e12, { engine: n }) => n.box(["Not", ["IsPrime", ...e12]]) }, IsOdd: { description: "`IsOdd(n)` returns `True` if `n` is an odd number", complexity: 1200, threadable: true, signature: "(number) -> boolean", evaluate: (e12, { engine: n }) => {
  let i = false, t = e12.every((r) => {
    if (r.im !== 0) return false;
    let s = Dt(r);
    if (s !== null) return s % BigInt(2) !== BigInt(0);
    let o = r.re;
    return Number.isInteger(o) ? o % 2 !== 0 : (i = true, false);
  });
  if (!i) return n.symbol(t ? "False" : "True");
} }, isEven: { description: "Odd Number", complexity: 1200, threadable: true, signature: "(number) -> boolean", canonical: (e12, { engine: n }) => n.box(["Not", ["IsOdd", ...e12]]) } }, { GCD: { description: "Greatest Common Divisor", complexity: 1200, threadable: false, signature: "(...any) -> integer", sgn: () => "positive", evaluate: (e12) => _l(e12, "GCD") }, LCM: { description: "Least Common Multiple", complexity: 1200, threadable: false, signature: "(...any) -> integer", sgn: () => "positive", evaluate: (e12) => _l(e12, "LCM") }, Numerator: { description: "Numerator of an expression", complexity: 1200, threadable: true, lazy: true, signature: "(number) -> number | nothing", canonical: (e12, { engine: n }) => {
  if (e12.length === 0) return n.Nothing;
  let i = e12[0];
  return i.operator === "Rational" || i.operator === "Divide" ? i.op1 : n._fn("Numerator", Fe(n, e12));
}, sgn: ([e12]) => e12.sgn, evaluate: (e12, { engine: n }) => {
  let i = n;
  if (e12.length === 0) return i.Nothing;
  let t = e12[0];
  return t.operator === "Rational" || t.operator === "Divide" ? t.op1.evaluate() : t.numerator;
} }, Denominator: { description: "Denominator of an expression", complexity: 1200, threadable: true, lazy: true, signature: "(number) -> number | nothing", canonical: (e12, { engine: n }) => {
  if (e12.length === 0) return n.Nothing;
  let i = e12[0];
  if (i.operator === "Rational" || i.operator === "Divide") return i.op2;
  let t = je(i);
  return t !== void 0 ? n.number(t[1]) : n._fn("Denominator", Fe(n, e12));
}, sgn: () => "positive", evaluate: (e12, { engine: n }) => {
  let i = n;
  if (e12.length === 0) return i.Nothing;
  let t = e12[0];
  return t.operator === "Rational" || t.operator === "Divide" ? t.op2.evaluate() : t.denominator;
} }, NumeratorDenominator: { description: "Sequence of Numerator and Denominator of an expression", complexity: 1200, threadable: true, lazy: true, signature: "(number) -> tuple<number, number> | nothing", canonical: (e12, { engine: n }) => {
  if (e12.length === 0) return n.Nothing;
  let i = e12[0];
  if (i.operator === "Rational" || i.operator === "Divide") return n.tuple(...i.ops);
  let t = je(i.evaluate());
  return t !== void 0 ? n.tuple(n.number(t[0]), n.number(t[1])) : n._fn("NumeratorDenominator", e12.map((r) => r.evaluate()));
}, evaluate: (e12, { engine: n }) => {
  let i = n;
  if (e12.length === 0) return i.Nothing;
  let t = e12[0];
  return t.operator === "Rational" || t.operator === "Divide" ? i.tuple(...t.ops) : i.tuple(...t.numeratorDenominator);
} } }, { Max: { description: "Maximum of two or more numbers", complexity: 1200, threadable: false, signature: "(...value) -> number | list", sgn: (e12) => {
  if (e12.some((n) => n.isReal == false || n.isNaN)) return "unsigned";
  if (!e12.some((n) => n.isReal == false || n.isNaN !== false)) {
    if (e12.some((n) => n.isPositive)) return "positive";
    if (e12.every((n) => n.isNonPositive)) return e12.some((n) => n.is(0)) ? "zero" : "non-positive";
    if (e12.some((n) => n.isNonNegative)) return "non-negative";
    if (e12.every((n) => n.isNegative)) return "negative";
    if (e12.some((n) => !n.is(0))) return "not-zero";
  }
}, evaluate: (e12, { engine: n }) => Vr(n, e12, "Max") }, Min: { description: "Minimum of two or more numbers", complexity: 1200, threadable: false, signature: "(...value) -> number | list", sgn: (e12) => {
  if (e12.some((n) => n.isReal == false || n.isNaN)) return "unsigned";
  if (!e12.some((n) => n.isReal == false || n.isNaN !== false)) {
    if (e12.some((n) => n.isNegative)) return "negative";
    if (e12.every((n) => n.isNonNegative)) return e12.some((n) => n.is(0)) ? "zero" : "non-negative";
    if (e12.some((n) => n.isNonPositive)) return "non-positive";
    if (e12.every((n) => n.isPositive)) return "positive";
  }
}, evaluate: (e12, { engine: n }) => Vr(n, e12, "Min") }, Supremum: { description: "Like Max, but defined for open sets", complexity: 1200, threadable: false, signature: "(...value) -> number | list", evaluate: (e12, { engine: n }) => Vr(n, e12, "Supremum") }, Infimum: { description: "Like Min, but defined for open sets", complexity: 1200, threadable: false, signature: "(...value) -> number | list", evaluate: (e12, { engine: n }) => Vr(n, e12, "Infimum") }, Product: { description: "`Product(f, a, b)` computes the product of `f` from `a` to `b`", wikidata: "Q901718", complexity: 1e3, threadable: false, lazy: true, signature: "(collection|function, ...(tuple<symbol>|tuple<symbol, integer>|tuple<symbol, integer, integer>)) -> number", canonical: ([e12, ...n]) => To("Product", e12, n), evaluate: (e12, n) => {
  let i = (r, s) => (s = s.evaluate(n), s.isNumberLiteral ? r.mul(s.numericValue) : null), t = Ri(Gt(e12[0], e12.slice(1), i, n.engine._numericValue(1)), n.engine._timeRemaining);
  return n.engine.number(t != null ? t : NaN);
}, evaluateAsync: async (e12, n) => {
  let i = (r, s) => (s = s.evaluate(n), s.isNumberLiteral ? r.mul(s.numericValue) : null), t = await Ai(Gt(e12[0], e12.slice(1), i, n.engine._numericValue(1)), n.engine._timeRemaining, n.signal);
  return n.engine.number(t != null ? t : NaN);
} }, Sum: { description: "`Sum(f, a, b)` computes the sum of `f` from `a` to `b`", wikidata: "Q218005", complexity: 1e3, threadable: false, lazy: true, signature: "(collection|function, ...(tuple<symbol>|tuple<symbol, integer>|tuple<symbol, integer, integer>)) -> number", canonical: ([e12, ...n]) => To("Sum", e12, n), evaluate: (e12, { engine: n }) => n.number(Ri(Gt(e12[0], e12.slice(1), (i, t) => (t = t.evaluate(), t.isNumberLiteral ? i.add(t.numericValue) : null), n._numericValue(0)), n._timeRemaining)), evaluateAsync: async (e12, { engine: n, signal: i }) => n.number(await Ai(Gt(e12[0], e12.slice(1), (t, r) => (r = r.evaluate(), r.isNumberLiteral ? t.add(r.numericValue) : null), n._numericValue(0)), n._timeRemaining, i)) } }, { BaseForm: { description: "`BaseForm(expr, base=10)`", complexity: 9e3, signature: "(number, (string|integer)?) -> string | nothing", type: ([e12]) => e12 === void 0 ? "nothing" : e12.type, evaluate: ([e12]) => e12 }, FromDigits: { description: "`FromDigits(s, base=10)`       return an integer representation of the string `s` in base `base`.", signature: "(string, (string|integer)?) -> integer", evaluate: (e12, { engine: n }) => {
  var _a2, _b, _c2, _d2, _e2;
  let i = (_a2 = e12[0]) == null ? void 0 : _a2.string, t = n;
  if (!i) return t.typeError("string", (_b = e12[0]) == null ? void 0 : _b.type, e12[0]);
  if (i = i.trim(), i.startsWith("0x")) return t.number(parseInt(i.slice(2), 16));
  if (i.startsWith("0b")) return t.number(parseInt(i.slice(2), 2));
  let r = (_c2 = e12[1]) != null ? _c2 : t.Nothing;
  if (r.symbol === "Nothing") return t.number(Number.parseInt(i, 10));
  let s = r.re;
  if (!r.isInteger || !Number.isFinite(s) || s < 2 || s > 36) return t.error(["unexpected-base", s.toString()], r.toString());
  let [o, a] = Vi(i, (_e2 = (_d2 = r.string) != null ? _d2 : r.symbol) != null ? _e2 : 10);
  return a ? t.error(["unexpected-digit", a[0]], a) : t.number(o);
} }, IntegerString: { description: "`IntegerString(n, base=10)`       return a string representation of the integer `n` in base `base`.", threadable: true, signature: "(integer, integer?) -> string", evaluate: (e12, { engine: n }) => {
  var _a2;
  let i = n, t = e12[0];
  if (!t.isInteger) return i.typeError("integer", t.type, t);
  let r = t.re;
  if (!Number.isFinite(r)) return i.typeError("integer", t.type, t);
  let s = (_a2 = e12[1]) != null ? _a2 : i.Nothing;
  if (s.symbol === "Nothing") return t.bignumRe !== void 0 ? i.string(t.bignumRe.abs().toString()) : i.string(Math.abs(r).toString());
  let o = G(s);
  return o === null ? i.typeError("integer", s.type, s) : o < 2 || o > 36 ? i.error(["out-of-range", "2", "36", o.toString()], s.toString()) : i.string(Math.abs(r).toString(o));
} } }];
function bd(e12) {
  let n = e12.engine, i = e12.numericValue;
  if (i !== null) return typeof i == "number" ? n.number(Math.abs(i)) : n.number(i.abs());
  if (e12.isNonNegative) return e12;
  if (e12.isNegative) return e12.neg();
}
function Bl(e12, n) {
  let i = e12.engine, t = n === "Max" || n === "Supremum";
  if (e12.operator === "Interval") {
    let r = t ? e12.op2 : e12.op1;
    return !r.isNumber || r.numericValue === null ? [void 0, [e12]] : [r, []];
  }
  if (e12.operator === "Range") {
    let r = Je(e12), s = El(r);
    return [i.number(Math.max(r[0], s)), []];
  }
  if (e12.operator === "Linspace") return e12.nops === 1 ? e12 = t ? e12.op1 : i.One : t ? e12 = e12.op2 : e12 = e12.op1, [e12, []];
  if (e12.isCollection) {
    let r, s = [];
    for (let o of ee(e12)) {
      let [a, u] = Bl(o, n);
      a && (r ? (t && a.isGreater(r) || !t && a.isLess(r)) && (r = a) : r = a), s.push(...u);
    }
    return [r, s];
  }
  return !e12.isNumber || e12.numericValue === null ? [void 0, [e12]] : [e12, []];
}
function Vr(e12, n, i) {
  let t = i === "Max" || i === "Supremum";
  if (n.length === 0) return t ? e12.NegativeInfinity : e12.PositiveInfinity;
  let r, s = [];
  for (let o of n) {
    let [a, u] = Bl(o, i);
    a && (r ? (t && a.isGreater(r) || !t && a.isLess(r)) && (r = a) : r = a), s.push(...u);
  }
  return s.length > 0 ? e12.box(r ? [i, r, ...s] : [i, ...s]) : r != null ? r : t ? e12.NegativeInfinity : e12.PositiveInfinity;
}
function _l(e12, n) {
  let i = e12[0].engine, t = n === "LCM" ? ki : rn, r = n === "LCM" ? mu : Hs, s = [];
  if (oe(i)) {
    let a = null;
    for (let u of e12) if (a === null) a = Gs(u), (a === null || !a.isInteger()) && s.push(u);
    else {
      let l = Gs(u);
      l && l.isInteger() ? a = r(a, l) : s.push(u);
    }
    return s.length === 0 ? a === null ? i.One : i.number(a) : a === null ? i._fn(n, s) : i._fn(n, [i.number(a), ...s]);
  }
  let o = null;
  for (let a of e12) o === null ? a.isInteger && s.push(a) : a.isInteger ? o = t(o, a.re) : s.push(a);
  return s.length === 0 ? o === null ? i.One : i.number(o) : o === null ? i._fn(n, s) : i._fn(n, [i.number(o), ...s]);
}
function zr(e12) {
  if (!e12.isInteger || e12.isNegative || e12.numericValue === null) return;
  let i = G(e12);
  if (i !== null) return ks(i);
  let t = Dt(e12);
  if (t !== null) return Ha(t);
}
var Al = { boolean: (e12) => e12.type.matches("boolean"), string: (e12) => e12.string !== null, number: (e12) => e12.isNumberLiteral, symbol: (e12) => e12.symbol !== null, expression: (e12) => true, numeric: (e12) => {
  let [n, i] = e12.toNumericValue();
  return i.is(1);
}, integer: (e12) => e12.isInteger, rational: (e12) => e12.isRational, irrational: (e12) => e12.isRational === false, real: (e12) => e12.isReal, notreal: (e12) => !e12.isReal, complex: (e12) => e12.type.matches("complex"), imaginary: (e12) => e12.type.matches("imaginary"), positive: (e12) => e12.isPositive, negative: (e12) => e12.isNegative, nonnegative: (e12) => e12.isNonNegative, nonpositive: (e12) => e12.isNonPositive, even: (e12) => e12.isEven, odd: (e12) => e12.isOdd, prime: (e12) => zr(e12) === true, composite: (e12) => zr(e12) === false, notzero: (e12) => e12.is(0) === false, notone: (e12) => e12.is(1) === false, finite: (e12) => e12.isFinite, infinite: (e12) => e12.isFinite === false, constant: (e12) => {
  var _a2, _b;
  return (_b = (_a2 = e12.symbolDefinition) == null ? void 0 : _a2.isConstant) != null ? _b : false;
}, variable: (e12) => {
  var _a2, _b;
  return !((_b = (_a2 = e12.symbolDefinition) == null ? void 0 : _a2.isConstant) != null ? _b : true);
}, function: (e12) => {
  var _a2, _b;
  return (_b = (_a2 = e12.symbolDefinition) == null ? void 0 : _a2.isFunction) != null ? _b : false;
}, relation: (e12) => we(e12.operator), equation: (e12) => e12.operator === "Equal", inequality: (e12) => zn(e12), collection: (e12) => e12.isCollection, list: (e12) => e12.operator === "List", set: (e12) => e12.operator === "Set", tuple: (e12) => e12.operator === "Tuple" || e12.operator === "Single" || e12.operator === "Pair" || e12.operator === "Triple", single: (e12) => e12.operator === "Single", pair: (e12) => e12.operator === "Pair", triple: (e12) => e12.operator === "Triple", scalar: (e12) => e12.rank === 0, tensor: (e12) => e12.rank > 0, vector: (e12) => e12.rank === 1, matrix: (e12) => e12.rank === 2, unit: (e12) => e12.operator === "Unit", dimension: (e12) => e12.operator === "Dimension", angle: (e12) => e12.operator === "Angle", polynomial: (e12) => e12.unknowns.length === 1 };
function Rl(e12, n) {
  for (let i of n) if (Al[i](e12) !== true) return false;
  return true;
}
function Ed(e12) {
  let n = /\\[a-zA-Z]+|[{}]|[\d]+|[+\-*/^_=()><,.;]|[a-zA-Z]/g, i = e12.match(n);
  return i ? i.filter((t) => !/^[ \f\n\r\t\v\xA0\u2028\u2029]+$/.test(t)) : [];
}
function Nd(e12) {
  let n = e12.peek, i = null;
  if (n === "\\mathrm") e12.nextToken(), i = e12.parseStringGroup();
  else if (/^[a-z]$/.test(n)) for (i = e12.nextToken(); /^[a-z]$/.test(e12.peek); ) i += e12.nextToken();
  else {
    let t = { ">0": "positive", "\\gt0": "positive", "<0": "negative", "\\lt0": "negative", ">=0": "nonnegative", "\\geq0": "nonnegative", "<=0": "nonpositive", "\\leq0": "nonpositive", "!=0": "notzero", "\\neq0": "notzero", "\\neq1": "notone", "!=1": "notone", "\\in\\R": "real", "\\in\\mathbb{R}": "real", "\\in\\C": "complex", "\\in\\mathbb{C}": "complex", "\\in\\Q": "rational", "\\in\\mathbb{Q}": "rational", "\\in\\Z^+": "integer,positive", "\\in\\Z^-": "intger,negative", "\\in\\Z^*": "nonzero", "\\in\\R^+": "positive", "\\in\\R^-": "negative", "\\in\\R^*": "real,nonzero", "\\in\\Z": "integer", "\\in\\mathbb{Z}": "integer", "\\in\\N": "integer,nonnegative", "\\in\\mathbb{N}": "integer,nonnegative", "\\in\\N^*": "integer,positive", "\\in\\N_0": "integer,nonnegative", "\\in\\R\\backslash\\Q": "irrational" };
    for (let r in t) if (e12.matchAll(Ed(r))) {
      i = t[r];
      break;
    }
  }
  if (!i) return null;
  if (!Object.keys(Al).includes(i)) throw new Error(`Unexpected condition "${i}" in a rule`);
  return i;
}
function kl(e12) {
  let n = [];
  do {
    let i = Nd(e12);
    if (!i) break;
    n.push(i);
  } while (e12.match(","));
  return n.join(",");
}
function Io(e12) {
  let n = null;
  if (e12.match(":")) n = kl(e12);
  else if (e12.matchAll(["_", "<{>"]) && (n = kl(e12), !e12.match("<}>"))) return null;
  return n;
}
function wl(e12, n, i) {
  var _a2, _b;
  if (!(n === void 0 || typeof n == "function")) {
    if (typeof n == "string") {
      let t = e12.parse(n, { canonical: (_a2 = i == null ? void 0 : i.canonical) != null ? _a2 : false });
      return t = t.map((r) => r.symbol && r.symbol.length === 1 ? e12.symbol("_" + r.symbol) : r, { canonical: false }), t;
    }
    return e12.box(n, { canonical: (_b = i == null ? void 0 : i.canonical) != null ? _b : false });
  }
}
function vd(e12, n, i) {
  var _a2;
  let t = (p) => ({ kind: "symbol", latexTrigger: p, parse: (m, y) => {
    s[p] || (s[p] = `_${p}`);
    let x = Io(m);
    return x !== null && (o[p] ? o[p] += "," + x : o[p] = x), s[p];
  } }), r = e12.latexDictionary, s = {}, o = {};
  e12.latexDictionary = [...r, { kind: "prefix", precedence: 100, latexTrigger: "...", parse: (p, m) => {
    let y = p.nextToken();
    if (!"abcfghjklmnopqrstuvwxyz".includes(y)) return null;
    let x = "__";
    if (p.match("?") && (x = "___"), s[y] && s[y] !== `${x}${y}`) throw new Error(`Duplicate wildcard "${y}"`);
    s[y] || (s[y] = `${x}${y}`);
    let E = Io(p);
    return E === null ? null : (o[y] ? o[y] += "," + E : o[y] = E, `${x}${y}`);
  } }, ..."abcfghjklmnopqrstuvwxyz".split("").map(t), { kind: "infix", precedence: 100, latexTrigger: "->", parse: (p, m, y) => {
    let x = p.parseExpression({ ...y, minPrec: 20 });
    if (x === null) return null;
    let E = null;
    if (p.match(";")) {
      let I = false, q = p.index;
      do {
        p.skipSpace();
        let be = p.nextToken();
        if (s[be]) {
          let Ee = Io(p);
          if (Ee === null || !Ee) {
            I = true, p.index = q;
            break;
          }
          o[be] ? o[be] += "," + Ee : o[be] = Ee;
        }
      } while (!I && !p.atEnd);
      E = p.parseExpression(y);
    }
    let _ = [];
    for (let I in o) {
      let q = o[I].split(",");
      q.length !== 0 && (q.length === 1 ? _.push(["Condition", s[I], q[0]]) : _.push(["Condition", s[I], ["And", ...q]]));
    }
    let R;
    return E && _.length > 0 ? R = ["And", E, ..._] : E ? R = E : _.length === 1 ? R = _[0] : _.length > 1 && (R = ["And", ..._]), R ? ["Rule", m, x, R] : ["Rule", m, x];
  } }];
  let a = e12.parse(n, { canonical: (_a2 = i == null ? void 0 : i.canonical) != null ? _a2 : false });
  if (e12.latexDictionary = r, !a.isValid || a.operator !== "Rule") throw new Error(`Invalid rule "${n}"
|   ${Gr(a).toString()}
|   A rule should be of the form:
|   <match> -> <replace>; <condition>`);
  let [u, l, f] = a.ops;
  if (!Dl(l, u)) throw new Error(`Invalid rule "${n}"
|   The replace expression contains wildcards not present in the match expression`);
  if (u.isSame(l)) throw new Error(`Invalid rule "${n}"
|   The match and replace expressions are the same.
|   This may be because the rule is not necessary due to canonical simplification`);
  let c;
  if (f !== void 0) {
    if (!Dl(f, u)) throw new Error(`Invalid rule "${n}"
|   The condition expression contains wildcards not present in the match expression`);
    c = (p) => {
      var _a3;
      return ((_a3 = f.subs(p).evaluate()) == null ? void 0 : _a3.symbol) === "True";
    };
  }
  return Ml(e12, { match: u, replace: l, condition: c, id: n }, i);
}
function Ml(e12, n, i) {
  var _a2;
  if (n == null) throw new Error("Expected a rule, not " + n);
  if (Sd(n)) return n;
  if (typeof n == "string") return vd(e12, n, i);
  if (typeof n == "function") return { _tag: "boxed-rule", match: void 0, replace: n, condition: void 0, id: n.toString().replace(/\n/g, " ") };
  let { match: t, replace: r, condition: s, id: o } = n;
  if (r === void 0) throw new Error(`Invalid rule "${o != null ? o : JSON.stringify(n)}"
|   A rule must include at least a replace property`);
  let a;
  if (typeof s == "string") {
    let f = Vn(s);
    if (f) {
      let c = e12.parse(f, { canonical: (_a2 = i == null ? void 0 : i.canonical) != null ? _a2 : false });
      a = (p, m) => {
        var _a3;
        return ((_a3 = c.subs(p).evaluate()) == null ? void 0 : _a3.symbol) === "True";
      };
    }
  } else {
    if (s !== void 0 && typeof s != "function") throw new Error(`Invalid rule ${o != null ? o : JSON.stringify(n)}
|   condition is not a valid function`);
    a = s;
  }
  if (typeof t == "function") throw new Error(`Invalid rule ${o != null ? o : JSON.stringify(n)}
|   match is not a valid expression.
|   Use a replace function instead to validate and replace the expression`);
  let u = wl(e12, t, i), l = wl(e12, r, i);
  if (o || (typeof t == "string" ? o = t : o = JSON.stringify(t), r && (o += " -> ", typeof r == "string" ? o += r : typeof r == "function" ? o += r == null ? void 0 : r.toString().replace(/\n/g, " ") : o = JSON.stringify(r)), typeof s == "string" ? o += `; ${s}` : typeof s == "function" && (o += `; ${s.toString().replace(/\n/g, " ")}`)), u && !u.isValid) throw new Error(`Invalid rule ${o}
|   the match expression is not valid: ${u.toString()}`);
  if (l && !l.isValid) throw new Error(`Invalid rule ${o != null ? o : JSON.stringify(n)}
|   The replace expression is not valid: ${l == null ? void 0 : l.toString()}`);
  if (!l && typeof r != "function") throw new Error(`Invalid rule ${o != null ? o : JSON.stringify(n)}
|   The replace expression could not be parsed`);
  return { _tag: "boxed-rule", match: u, replace: l != null ? l : r, condition: a, useVariations: n.useVariations, id: o };
}
function jt(e12, n, i) {
  if (!n) return { rules: [] };
  if (typeof n == "object" && "rules" in n) return n;
  Array.isArray(n) || (n = [n]);
  let t = [];
  for (let r of n) try {
    t.push(Ml(e12, r, i));
  } catch (s) {
    throw new Error(`
${s.message}
|   Skipping rule ${JSON.stringify(r)}

`);
  }
  return { rules: t };
}
function Bo(e12, n, i, t) {
  var _a2, _b, _c2;
  let r = (_a2 = t == null ? void 0 : t.canonical) != null ? _a2 : n.isCanonical || n.isStructural, s = false;
  if (n.ops && (t == null ? void 0 : t.recursive)) {
    let y = n.ops.map((x) => {
      let E = Bo(e12, x, {}, t);
      return E ? (s = true, E.value) : x;
    });
    s && (n = n.engine.function(n.operator, y, { canonical: r }));
  }
  let { match: o, replace: a, condition: u, id: l } = e12, f = l != null ? l : "";
  if (r && o) {
    let y = Ut(o), x = o;
    o = o.canonical;
    let E = Ut(o);
    if (!y.every((_) => E.includes(_))) throw new Error(`
|   Invalid rule "${e12.id}"
|   The canonical form of ${Gr(x).toString()} is "${Gr(o).toString()}" and it does not contain all the wildcards of the original match.
|   This could indicate that the match expression in canonical form is already simplified and this rule may not be necessary`);
  }
  let c = (_c2 = (_b = e12.useVariations) != null ? _b : t == null ? void 0 : t.useVariations) != null ? _c2 : false, p = o ? n.match(o, { substitution: i, ...t, useVariations: c }) : {};
  if (p === null) return s ? { value: n, because: f } : null;
  if (typeof u == "function") {
    let y = { ...Object.fromEntries(Object.entries(p).map(([x, E]) => [x.slice(1), E])), ...p };
    try {
      if (!u(y, n.engine)) return s ? { value: n, because: f } : null;
    } catch (x) {
      return console.error(`
|   Rule "${e12.id}"
|   Error while checking condition
|    ${x.message}`), null;
    }
  }
  let m = typeof a == "function" ? a(n, p) : a.subs(p, { canonical: r });
  return m ? Td(m) ? r ? { ...m, value: m.value.canonical } : m : { value: r ? m.canonical : m, because: f } : null;
}
function Mn(e12, n, i) {
  var _a2, _b;
  if (!n) throw new Error("replace(): Expected one or more rules");
  let t = (_a2 = i == null ? void 0 : i.iterationLimit) != null ? _a2 : 1, r = 0, s = (_b = i == null ? void 0 : i.once) != null ? _b : false, o;
  typeof n == "object" && "rules" in n ? o = n.rules : o = e12.engine.rules(Array.isArray(n) ? n : [n]).rules;
  let a = false, u = [];
  for (; !a && r < t; ) {
    a = true;
    for (let l of o) try {
      let f = Bo(l, e12, {}, i);
      if (f !== null && f.value !== e12 && !f.value.isSame(e12)) {
        if (s) return [f];
        if (u.some((c) => c.value.isSame(f.value))) return u;
        u.push(f), a = false, e12 = f.value;
      }
    } catch (f) {
      return console.error(`
${e12.toString()}
${l.id}
${f.message}`), u;
    }
    r += 1;
  }
  return u;
}
function Zt(e12, n, i, t) {
  let r = [];
  for (let s of n.rules) {
    let o = Bo(s, e12, i, t);
    o !== null && !r.some((a) => a.isSame(o.value)) && r.push(o.value);
  }
  return r;
}
function Gr(e12) {
  let n = e12.symbol;
  if (n && n.startsWith("_")) return e12.engine.symbol(n.slice(1));
  if (e12.ops) {
    let i = e12.ops.map((t) => Gr(t));
    return e12.engine.function(e12.operator, i, { canonical: false });
  }
  return e12;
}
function Ut(e12) {
  let n = [];
  return e12.symbol && e12.symbol.startsWith("_") && n.push(e12.symbol), e12.ops && e12.ops.forEach((i) => n.push(...Ut(i))), n;
}
function Dl(e12, n) {
  let i = Ut(e12), t = Ut(n);
  return i.every((r) => t.includes(r));
}
function Td(e12) {
  return e12 && typeof e12 == "object" && "because" in e12 && "value" in e12;
}
function Sd(e12) {
  return e12 && typeof e12 == "object" && e12._tag === "boxed-rule";
}
var Pl = [{ match: ["Multiply", "_x", "__a"], replace: 0, id: "ax", condition: ({ __a: e12 }) => !e12.has("_x") }, { match: ["Add", ["Divide", "_a", "_x"], "__b"], replace: 1 / 0, useVariations: true, condition: ({ _a: e12, __b: n }) => !e12.has("_x") && !n.has("_x") }, { match: ["Add", ["Multiply", "_x", "__a"], "__b"], replace: ["Divide", ["Negate", "__b"], "__a"], useVariations: true, condition: ({ __a: e12, __b: n }) => !e12.has("_x") && !n.has("_x") }, { match: ["Add", ["Multiply", "_a", ["Power", "_x", "_n"]], "__b"], replace: ["Power", ["Divide", ["Negate", "__b"], "_a"], ["Divide", 1, "_n"]], useVariations: true, condition: ({ _a: e12, __b: n, _n: i }) => !e12.has("_x") && !n.has("_x") && !i.is(0) }, { match: ["Add", ["Multiply", "_a", ["Power", "_x", "_n"]], "__b"], replace: ["Negate", ["Power", ["Divide", ["Negate", "__b"], "_a"], ["Divide", 1, "_n"]]], useVariations: true, condition: ({ _a: e12, __b: n, _n: i }) => {
  var _a2;
  return !e12.has("_x") && !n.has("_x") && !i.is(0) && ((_a2 = i.isEven) != null ? _a2 : false);
} }, { match: ["Add", ["Multiply", "__a", ["Power", "_x", 2]], ["Multiply", "__b", "_x"], "__c"], replace: ["Divide", ["Add", ["Negate", "__b"], ["Sqrt", ["Subtract", ["Square", "__b"], ["Multiply", 4, "__a", "__c"]]]], ["Multiply", 2, "__a"]], useVariations: true, condition: ({ __a: e12, __b: n, __c: i }) => !e12.has("_x") && !n.has("_x") && !i.has("_x") }, { match: ["Add", ["Multiply", "__a", ["Power", "_x", 2]], ["Multiply", "__b", "_x"], "__c"], replace: ["Divide", ["Subtract", ["Negate", "__b"], ["Sqrt", ["Subtract", ["Square", "__b"], ["Multiply", 4, "__a", "__c"]]]], ["Multiply", 2, "__a"]], useVariations: true, condition: ({ __a: e12, __b: n, __c: i }) => !e12.has("_x") && !n.has("_x") && !i.has("_x") }, { match: ["Add", ["Multiply", "__a", ["Exp", ["Multiply", "__b", "_x"]]], "__c"], replace: ["Divide", ["Ln", ["Negate", ["Divide", "__c", "__a"]]], "__b"], useVariations: true, condition: ({ __a: e12, __c: n }) => {
  var _a2;
  return ((_a2 = !e12.is(0) && n.div(e12).isNegative) != null ? _a2 : false) && !e12.has("_x") && !n.has("_x");
} }, { match: ["Add", ["Multiply", "__a", ["Exp", "_x"]], "__c"], replace: ["Ln", ["Negate", ["Divide", "__c", "__a"]]], useVariations: true, condition: ({ __a: e12, __c: n }) => {
  var _a2;
  return ((_a2 = !e12.is(0) && n.div(e12).isNegative) != null ? _a2 : false) && !e12.has("_x") && !n.has("_x");
} }, { match: ["Add", ["Exp", "_x"], "__c"], replace: ["Ln", ["Negate", "__c"]], useVariations: true, condition: ({ __c: e12 }) => {
  var _a2;
  return (_a2 = e12.isNegative) != null ? _a2 : false;
} }, { match: ["Add", ["Exp", ["Multiply", "__b", "_x"]], "__c"], replace: ["Divide", ["Ln", ["Negate", "__c"]], "__b"], useVariations: true, condition: ({ __c: e12 }) => {
  var _a2;
  return (_a2 = e12.isNegative) != null ? _a2 : false;
} }, { match: ["Add", ["Multiply", "__a", ["Log", "_x", "__b"]], "__c"], replace: ["Power", "__b", ["Negate", ["Divide", "__c", "__a"]]], useVariations: true, condition: ({ __a: e12, __b: n }) => {
  var _a2;
  return (_a2 = !e12.is(0) && n.isPositive) != null ? _a2 : false;
} }, { match: ["Multiply", "__a", ["Log", "_x", "__b"]], replace: ["Power", "__b", ["Negate", ["Divide", "__c", "__a"]]], useVariations: true, condition: ({ __a: e12, __b: n }) => {
  var _a2;
  return (_a2 = !e12.is(0) && n.isPositive) != null ? _a2 : false;
} }, { match: ["Add", ["Abs", ["Add", ["Multiply", "__a", "_x"], "__b"]], "__c"], replace: ["Divide", ["Subtract", "__b", "__c"], "__a"] }, { match: ["Add", ["Abs", ["Add", ["Multiply", "__a", "_x"], "__b"]], "__c"], replace: ["Divide", ["Negate", ["Add", "__b", "__c"], "__a"]] }, { match: "ax + \\mathrm{__b} \\sqrt{cx + \\mathrm{__d}} + \\mathrm{__g}", replace: "\\frac{-(2 a g - \\mathrm{__b}^2 c) + \\sqrt{(2 a \\mathrm{__g} - \\mathrm{__b}^2 c)^2 - 4 a^2(g^2 - b^2 \\mathrm{__d})}}{2 a^2}", useVariations: true, condition: ({ a: e12, __b: n, c: i, d: t, __g: r }) => !e12.has("_x") && !n.has("_x") && !i.has("_x") && !t.has("_x") && !r.has("_x") }, { match: "ax + \\mathrm{__b} \\sqrt{cx + \\mathrm{__d}} + \\mathrm{__g}", replace: "\\frac{-(2 a g - \\mathrm{__b}^2 c) - \\sqrt{(2 a \\mathrm{__g} - \\mathrm{__b}^2 c)^2 - 4 a^2(g^2 - b^2 \\mathrm{__d})}}{2 a^2}", useVariations: true, condition: ({ a: e12, __b: n, c: i, d: t, __g: r }) => !e12.has("_x") && !n.has("_x") && !i.has("_x") && !t.has("_x") && !r.has("_x") }];
function Ur(e12, n) {
  let i = e12.engine;
  e12.operator === "Equal" ? e12 = e12.op1.expand().sub(e12.op2.expand()).simplify() : e12 = e12.expand().simplify();
  let t = i.getRuleSet("solve-univariate"), r = [e12.subs({ [n]: "_x" }, { canonical: false })], s = r.flatMap((o) => Zt(o, t, { _x: i.symbol("_x") }, { useVariations: true, canonical: true }));
  return s.length === 0 && (r = r.flatMap((o) => Cl(o)), s = r.flatMap((o) => Zt(o, t, { _x: i.symbol(n) }, { useVariations: true, canonical: true }))), s.length === 0 && (r = r.flatMap((o) => Pe(o.canonical)).filter((o) => o !== null), r = r.flatMap((o) => Cl(o)), s = r.flatMap((o) => Zt(o, t, { _x: i.symbol(n) }, { useVariations: true, canonical: true }))), _d(e12, n, s.map((o) => o.evaluate().simplify()));
}
var Ol = [{ match: ["Add", ["Abs", ["Add", ["Multiply", "__a", "_x"], "__b"]], "__c"], replace: ["Add", ["Multiply", "__a", "_x"], "__b", "__c"] }, { match: ["Add", ["Abs", ["Add", ["Multiply", "__a", "_x"], "__b"]], "__c"], replace: ["Add", ["Negate", ["Multiply", "__a", "_x"]], ["Negate", "__b"], "__c"] }, { match: ["Multiply", "__a", ["Power", "_b", "_n"]], replace: "_b", condition: ({ __a: e12, _b: n, _n: i }) => !e12.has("_x") && n.has("_x") && !i.is(0) && !i.has("_x") }, { match: ["Multiply", "__a", ["Sqrt", "_b"]], replace: ["Multiply", ["Square", "_a"], "__b"], condition: ({ _b: e12 }) => e12.has("_x") }, { match: ["Divide", "_a", "_b"], replace: "_a", condition: ({ _a: e12, _b: n }) => e12.has("_x") && !n.is(0) }, { match: ["Multiply", "__a", "_b"], replace: "_b", condition: ({ __a: e12, _b: n }) => !e12.has("_x") && n.has("_x") }, { match: ["Add", ["Ln", "_a"], ["Ln", "_b"], "__c"], replace: ["Add", ["Ln", ["Multiply", "_a", "_b"]], "__c"] }, { match: ["Multiply", ["Exp", "__a"], ["Exp", "__b"], "__c"], replace: ["Multiply", ["Exp", ["Add", "_a", "_b"]], "__c"] }, { match: ["Ln", "_a"], replace: ["Subtract", "_a", 1], condition: ({ _a: e12 }) => e12.has("_x") }, { match: ["Sin", "_a"], replace: "_a", condition: ({ _a: e12 }) => e12.has("_x") }, { match: ["Cos", "_a"], replace: ["Subtract", "_a", ["Divide", "Pi", 2]], condition: ({ _a: e12 }) => e12.has("_x") }, { match: ["Tan", "_a"], replace: "_a", condition: ({ _a: e12 }) => e12.has("_x") }, { match: ["Add", ["Sin", "_a"], ["Cos", "_a"]], replace: 1, condition: ({ _a: e12 }) => e12.has("_x") }, { match: ["Subtract", ["Square", ["Sin", "_a"]], ["Square", ["Cos", "_a"]]], replace: ["PlusMinus", ["Sin", "_a"], ["Divide", ["Sqrt", 2], 2]], condition: ({ _a: e12 }) => e12.has("_x") }];
function Cl(e12) {
  let n = e12.engine, i = n.getRuleSet("harmonization");
  return Zt(e12, i, { _x: n.symbol("_x") });
}
function _d(e12, n, i) {
  return i.filter((t) => {
    let r = e12.subs({ [n]: t }).N();
    return r === null || !r.isValid || r.isNaN || r.has(n) ? false : r.isEqual(0);
  });
}
function Ll(e12) {
  if (e12.operator === "Element") return kd(e12);
  if (e12.operator === "Equal") return Id(e12);
  if (zn(e12)) return Bd(e12);
  throw new Error("Unsupported assumption. Use `Element`, `Equal` or an inequality");
}
function Id(e12) {
  e12.operator;
  let n = e12.unknowns;
  if (n.length === 0) {
    let r = e12.evaluate();
    return r.symbol === "True" ? "tautology" : r.symbol === "False" ? "contradiction" : (e12.canonical.evaluate(), "not-a-predicate");
  }
  let i = e12.engine, t = e12.op1.symbol;
  if (t && !Dd(i, t) && !e12.op2.has(t)) {
    let r = e12.op2.evaluate();
    if (!r.isValid) return "not-a-predicate";
    let s = i.lookupSymbol(t);
    return s ? s.type && !r.type.matches(s.type) && !s.inferredType ? "contradiction" : (s.value = r, s.inferredType && (s.type = r.type), "ok") : (i.defineSymbol(t, { value: r }), "ok");
  }
  if (n.length === 1) {
    let r = n[0], s = Ur(e12, r);
    s.length === 0 && i.assumptions.set(i.function("Equal", [e12.op1.sub(e12.op2), 0]), true);
    let o = s.length === 1 ? s[0] : i.function("List", s), a = i.lookupSymbol(r);
    return a ? a.type && !s.every((u) => !u.type || o.type.matches(u.type)) ? "contradiction" : (a.value = o, "ok") : (i.defineSymbol(r, { value: o }), "ok");
  }
  return i.assumptions.set(e12, true), "ok";
}
function Bd(e12) {
  let n = e12.engine;
  if (e12.op1.symbol && !ko(n, e12.op1.symbol)) return e12.op2.is(0) ? e12.operator === "Less" ? n.defineSymbol(e12.op1.symbol, { type: "real", flags: { sgn: "negative" } }) : e12.operator === "LessEqual" ? n.defineSymbol(e12.op1.symbol, { type: "real", flags: { sgn: "non-positive" } }) : e12.operator === "Greater" ? n.defineSymbol(e12.op1.symbol, { type: "real", flags: { sgn: "positive" } }) : e12.operator === "GreaterEqual" && n.defineSymbol(e12.op1.symbol, { type: "real", flags: { sgn: "non-negative" } }) : (n.defineSymbol(e12.op1.symbol, { type: "real" }), n.assumptions.set(e12, true)), "ok";
  let i = "", t, r;
  if (e12.operator === "Less" ? (t = e12.op1, r = e12.op2, i = "<") : e12.operator === "LessEqual" ? (t = e12.op1, r = e12.op2, i = "<=") : e12.operator === "Greater" ? (t = e12.op2, r = e12.op1, i = "<") : e12.operator === "GreaterEqual" && (t = e12.op2, r = e12.op1, i = "<="), !i) return "internal-error";
  let s = t.sub(r), o = n.box([i === "<" ? "Less" : "LessEqual", s, 0]).evaluate();
  if (o.symbol === "True") return "tautology";
  if (o.symbol === "False") return "contradiction";
  let a = o.unknowns;
  return a.length === 0 ? "not-a-predicate" : (a.length === 1 && (n.lookupSymbol(a[0]) || n.defineSymbol(a[0], { type: "real" })), o.operator === "Less" || o.operator, n.assumptions.set(o, true), "ok");
}
function kd(e12) {
  var _a2, _b;
  e12.operator;
  let n = e12.engine, i = wd(e12.op1);
  if (i.length === 1) {
    let r = e12.op2.evaluate();
    if (!r.isValid) return "not-a-predicate";
    let s = vr(r);
    if (s === "unknown") throw new Error(`Invalid domain "${r.toString()}"`);
    return n.declare(i[0], s), "ok";
  }
  if (e12.op1.symbol && ko(n, e12.op1.symbol)) {
    let r = e12.op2.evaluate();
    if (!r.isValid) return "not-a-predicate";
    let s = vr(r);
    ((_b = (_a2 = n.context) == null ? void 0 : _a2.ids) == null ? void 0 : _b.has(e12.op1.symbol)) || n.declare(e12.op1.symbol, vr(r));
    let o = n.lookupSymbol(e12.op1.symbol);
    if (o) return o.type && !v(s, o.type.type) ? "contradiction" : (o.type = new C(s), "ok");
    let a = n.lookupFunction(e12.op1.symbol);
    return a ? v(s, Kn(a.signature.type)) ? "ok" : "contradiction" : "not-a-predicate";
  }
  if (i.length > 0) return n.assumptions.set(e12, true), "ok";
  let t = e12.evaluate();
  return t.symbol === "True" ? "tautology" : t.symbol === "False" ? "contradiction" : "not-a-predicate";
}
function ko(e12, n) {
  var _a2;
  return ((_a2 = e12.lookupSymbol(n)) != null ? _a2 : e12.lookupFunction(n)) !== void 0;
}
function wd(e12) {
  return e12.symbols.filter((n) => !ko(e12.engine, n));
}
function Dd(e12, n) {
  var _a2;
  return e12.lookupFunction(n) ? false : ((_a2 = e12.lookupSymbol(n)) == null ? void 0 : _a2.value) !== void 0;
}
function Fl(e12, n, i, t, r) {
  if (n.numericValue !== null && n.isNegative) {
    let s = n.numericValue;
    if (typeof s == "number") return L(e12, "Subtract", [i, e12.number(-s)], t, r);
    if (n.type.matches("rational")) return L(e12, "Subtract", [i, e12.number(s.neg())], t, r);
  }
  return n.operator === "Negate" && i.operator !== "Negate" ? L(e12, "Subtract", [i, n.op1], t, r) : null;
}
function Ad(e12, n, i, t, r) {
  var _a2, _b, _c2, _d2, _e2;
  let s = t.exclude;
  if (n === "Add" && i.length === 2 && !s.includes("Subtract")) {
    let o = (_a2 = Fl(e12, i[0], i[1], t, r)) != null ? _a2 : Fl(e12, i[1], i[0], t, r);
    if (o) return o;
  }
  if (n === "Divide" && i.length === 2 && s.includes("Divide")) return L(e12, "Multiply", [i[0], e12._fn("Power", [i[1], e12.NegativeOne])], t, r);
  if (n === "Multiply" && !s.includes("Negate") && i[0].im === 0 && i[0].re === -1) return i.length === 2 ? L(e12, "Negate", [i[1]], t) : L(e12, "Negate", [e12._fn("Multiply", [...i.slice(1)].sort(fe))], t, r);
  if (n === "Multiply" && !s.includes("Divide")) {
    let o = new Be(e12, i, { canonical: false }).asRationalExpression();
    if (o.operator === "Divide") return L(e12, o.operator, o.ops, t, r);
  }
  if (n === "Power") {
    if (!s.includes("Exp") && ((_b = i[0]) == null ? void 0 : _b.symbol) === "ExponentialE") return L(e12, "Exp", [i[1]], t, r);
    if (((_c2 = i[1]) == null ? void 0 : _c2.numericValue) !== null) {
      let o = G(i[1]);
      if (o === 2 && !s.includes("Square")) return L(e12, "Square", [i[0]], t, r);
      if (o !== null && o < 0 && !s.includes("Divide")) return L(e12, "Divide", [e12.One, o === -1 ? i[0] : i[0].pow(-o)], t, r);
      let a = i[1].re;
      if (!s.includes("Sqrt") && a === 0.5) return L(e12, "Sqrt", [i[0]], t, r);
      if (!s.includes("Sqrt") && a === -0.5) return L(e12, "Divide", [e12.One, e12._fn("Sqrt", [i[0]])], t, r);
      if (Bn(a)) {
        let u = Os(a), l = Ls(a);
        if (u === 1) {
          if (!s.includes("Sqrt") && l === 2) return L(e12, "Sqrt", [i[0]], t, r);
          if (!s.includes("Root")) return L(e12, "Root", [i[0], e12.number(a[1])], t, r);
        }
        if (u === -1) {
          if (!s.includes("Sqrt") && l === 2) return L(e12, "Divide", [e12.One, e12._fn("Sqrt", [i[0]])], t, r);
          if (!s.includes("Root")) return L(e12, "Divide", [e12.One, e12._fn("Root", [i[0], e12.number(a[1])])], t, r);
        }
      }
    }
  }
  if (n === "Add" && i.length === 2 && !s.includes("Subtract")) {
    if (((_d2 = i[1]) == null ? void 0 : _d2.numericValue) !== null) {
      let o = G(i[1]);
      if (o !== null && o < 0) return L(e12, "Subtract", [i[0], e12.number(-o)], t, r);
    }
    if (((_e2 = i[1]) == null ? void 0 : _e2.operator) === "Negate") return L(e12, "Subtract", [i[0], i[1].op1], t, r);
  }
  if (n === "Tuple") {
    if (i.length === 1 && !s.includes("Single")) return L(e12, "Single", i, t, r);
    if (i.length === 2 && !s.includes("Pair")) return L(e12, "Pair", i, t, r);
    if (i.length === 3 && !s.includes("Triple")) return L(e12, "Triple", i, t, r);
  }
  return L(e12, n, i, t, r);
}
function L(e12, n, i, t, r) {
  var _a2, _b, _c2, _d2, _e2, _f2;
  let s = t.exclude;
  if (n === "Negate" && i.length === 1) {
    let l = (_a2 = i[0]) == null ? void 0 : _a2.numericValue;
    if (l !== null) {
      if (typeof l == "number") return Ye(e12, -l, t);
      if (l instanceof M || l instanceof $) return Ye(e12, l.neg(), t);
      if (Bn(l)) return Ye(e12, ui(l), t);
    }
  }
  if (typeof n == "string" && s.includes(n)) {
    if (n === "Rational" && i.length === 2) return L(e12, "Divide", i, t, r);
    if (n === "Complex" && i.length === 2) return L(e12, "Add", [i[0], e12._fn("Multiply", [(_b = i[1]) != null ? _b : e12.symbol("Undefined"), e12.I])], t, r);
    if (n === "Sqrt" && i.length === 1) return L(e12, "Power", [i[0], s.includes("Half") ? e12.number([1, 2]) : e12.Half], t, r);
    if (n === "Root" && i.length === 2 && ((_c2 = i[1]) == null ? void 0 : _c2.numericValue) !== null) {
      let l = G(i[1]);
      if (l === 2) return L(e12, "Sqrt", [i[0]], t);
      if (l !== null) return l < 0 ? L(e12, "Divide", [e12.One, e12._fn("Power", [(_d2 = i[0]) != null ? _d2 : e12.symbol("Undefined"), e12.number([1, -l])])], t, r) : L(e12, "Power", [i[0], e12.number([1, -l])], t, r);
    }
    if (n === "Square" && i.length === 1) return L(e12, "Power", [i[0], e12.number(2)], t, r);
    if (n === "Exp" && i.length === 1) return L(e12, "Power", [e12.E, i[0]], t, r);
    if (n === "Pair" || n == "Single" || n === "Triple") return L(e12, "Tuple", i, t, r);
    if (n === "Subtract" && i.length === 2) return L(e12, "Add", [i[0], e12._fn("Negate", [(_e2 = i[1]) != null ? _e2 : e12.symbol("Undefined")])], t, r);
    if (n === "Subtract" && i.length === 1) return L(e12, "Negate", i, t, r);
  }
  let a = [n, ...i.map((l) => l ? wo(e12, l, t) : "Undefined")], u = { ...r != null ? r : {} };
  return t.metadata.includes("latex") ? u.latex = (_f2 = u.latex) != null ? _f2 : e12.box({ fn: a }).latex : u.latex = "", t.metadata.includes("wikidata") || (u.wikidata = ""), !u.latex && !u.wikidata && t.shorthands.includes("function") ? a : u.latex && u.wikidata ? { fn: a, latex: u.latex, wikidata: u.wikidata } : u.latex ? { fn: a, latex: u.latex } : u.wikidata ? { fn: a, wikidata: u.wikidata } : { fn: a };
}
function Rd(e12, n) {
  return e12 = e12, n.shorthands.includes("string") ? `'${e12}'` : { str: e12 };
}
function Wn(e12, n, i, t) {
  var _a2, _b;
  if (n === "Half" && i.exclude.includes("Half")) return Ye(e12, [1, 2], i, t);
  if (t = { ...t }, i.metadata.includes("latex") ? (t.latex = (_a2 = t.latex) != null ? _a2 : e12.box({ sym: n }).latex, t.latex !== void 0 && (t.latex = t.latex)) : t.latex = void 0, i.metadata.includes("wikidata")) {
    if (t.wikidata === void 0) {
      let r = (_b = e12.lookupSymbol(n)) == null ? void 0 : _b.wikidata;
      r !== void 0 && (t.wikidata = r);
    }
  } else t.wikidata = void 0;
  return n = n, t.latex === void 0 && t.wikidata === void 0 && i.shorthands.includes("symbol") ? n : t.latex !== void 0 && t.wikidata !== void 0 ? { sym: n, latex: t.latex, wikidata: t.wikidata } : t.latex !== void 0 ? { sym: n, latex: t.latex } : t.wikidata !== void 0 ? { sym: n, wikidata: t.wikidata } : { sym: n };
}
function ql(e12, n) {
  var _a2;
  if (!n.repeatingDecimal) return e12;
  let [i, t, r, s] = (_a2 = e12.match(/^(.*)\.([0-9]+)([e|E][-+]?[0-9]+)?$/)) != null ? _a2 : [];
  if (!r) return e12.toLowerCase();
  let o = r[r.length - 1];
  r = r.slice(0, -1);
  let a = 16, u = "";
  for (let l = 0; l < r.length - a; l++) {
    u = r.substring(0, l);
    for (let f = 0; f <= a; f++) {
      let c = r.substring(l, l + f + 1), p = Math.floor((r.length - u.length) / c.length);
      if (p < 3) break;
      if ((u + c.repeat(p + 1)).startsWith(r)) return c === "0" ? o === "0" ? t + "." + u + (s != null ? s : "") : e12 : t + "." + u + "(" + c + ")" + (s != null ? s : "");
    }
  }
  for (r += o; r.endsWith("0"); ) r = r.slice(0, -1);
  return typeof n.fractionalDigits == "number" && (r = r.slice(0, n.fractionalDigits)), s ? `${t}.${r}${s.toLowerCase()}` : `${t}.${r}`;
}
function Ye(e12, n, i, t) {
  var _a2, _b, _c2, _d2, _e2, _f2;
  t = { ...t }, i.metadata.includes("latex") || (t.latex = void 0);
  let r = t.latex === void 0 && t.wikidata === void 0 && !i.metadata.includes("latex") && i.shorthands.includes("number"), s = i.exclude;
  if (n instanceof z) {
    if (n.isNaN) return Wn(e12, "NaN", i, t);
    if (n.isPositiveInfinity) return Wn(e12, "PositiveInfinity", i, t);
    if (n.isNegativeInfinity) return Wn(e12, "NegativeInfinity", i, t);
    if (n.isComplexInfinity) return Wn(e12, "ComplexInfinity", i, t);
    if (r) {
      if (n.isZero) return 0;
      if (n.isOne) return 1;
      if (n.isNegativeOne) return -1;
    }
    if (n instanceof Z) {
      n.im;
      let u = (l) => oi(l) ? Ye(e12, n.rational[0], i) : ["Rational", Ye(e12, n.rational[0], i), Ye(e12, n.rational[1], i)];
      return n.radical === 1 ? u(n.rational) : ve(n.rational) ? ["Sqrt", n.radical] : Bt(n.rational) ? ["Negate", ["Sqrt", n.radical]] : n.rational[0] == 1 ? ["Divide", ["Sqrt", n.radical], Ye(e12, n.rational[1], i)] : n.rational[0] == -1 ? ["Negate", ["Divide", ["Sqrt", n.radical], Ye(e12, n.rational[1], i)]] : ["Multiply", u(n.rational), ["Sqrt", n.radical]];
    }
    if (n.im === 0) {
      let u = (_a2 = n.bignumRe) != null ? _a2 : n.re;
      return Ye(e12, u, i, t);
    }
    return Number.isFinite(n.im) ? L(e12, "Complex", [e12.number((_b = n.bignumRe) != null ? _b : n.re), e12.number(n.im)], i, { ...t, wikidata: "Q11567" }) : Wn(e12, "ComplexInfinity", i, t);
  }
  let o = "";
  if (n instanceof M) {
    let u;
    if (n.isNaN()) u = "NaN";
    else if (!n.isFinite()) u = n.isPositive() ? "PositiveInfinity" : "NegativeInfinity";
    else {
      if (r && fi(n)) return n.toNumber();
      if (n.isInteger() && n.e < n.precision() + 4) o = n.toFixed(0);
      else {
        let l = i.fractionalDigits, f;
        if (l === "max" ? f = n.toString() : l === "auto" ? f = n.toPrecision(e12.precision) : f = n.toDecimalPlaces(l).toString(), o = ql(f, i), r) {
          let c = n.toNumber();
          if (c.toString() === o) return c;
        }
      }
    }
    return i.metadata.includes("latex") && (t.latex = (_c2 = t.latex) != null ? _c2 : e12.box(u != null ? u : { num: o }).latex), u ? t.latex !== void 0 ? { sym: u, latex: t.latex } : r ? u : { sym: u } : t.latex !== void 0 ? { num: o, latex: t.latex } : r ? o : { num: o };
  }
  if (n instanceof $) return n.isInfinite() ? Wn(e12, "ComplexInfinity", i, t) : n.isNaN() ? (o = "NaN", i.metadata.includes("latex") && (t.latex = (_d2 = t.latex) != null ? _d2 : e12.box({ num: o }).latex), t.latex !== void 0 ? { num: o, latex: t.latex } : { num: o }) : L(e12, "Complex", [e12.number(n.re), e12.number(n.im)], i, { ...t, wikidata: "Q11567" });
  if (Bn(n)) {
    let u = !s.includes("Rational");
    return r && i.shorthands.includes("function") && te(n) ? n[0] === 1 && n[1] === 2 && !s.includes("Half") ? Wn(e12, "Half", i, t) : [u ? "Rational" : "Divide", n[0], n[1]] : L(e12, u ? "Rational" : "Divide", [e12.number(n[0]), e12.number(n[1])], i, { ...t });
  }
  if (typeof n == "bigint") if (n >= Number.MIN_SAFE_INTEGER && n <= Number.MAX_SAFE_INTEGER) n = Number(n);
  else return i.metadata.includes("latex") && (t.latex = (_e2 = t.latex) != null ? _e2 : e12.box({ num: n.toString() }).latex), t.latex !== void 0 ? { num: n.toString(), latex: t.latex } : r ? Ie(n, i.fractionalDigits) : { num: ge(n, i.fractionalDigits) };
  let a;
  return Number.isNaN(n) ? a = "NaN" : Number.isFinite(n) ? o = ql(n.toString(), i) : a = n > 0 ? "PositiveInfinity" : "NegativeInfinity", i.metadata.includes("latex") && (t.latex = (_f2 = t.latex) != null ? _f2 : e12.box({ num: o }).latex), a ? t.latex !== void 0 ? { sym: a, latex: t.latex } : r ? a : { sym: a } : t.latex !== void 0 ? { num: o, latex: t.latex } : r && o === n.toString() ? n : { num: o };
}
function wo(e12, n, i) {
  let t = n.scope ? n.wikidata : void 0;
  return n.numericValue !== null ? Ye(e12, n.numericValue, i, { latex: n.verbatimLatex }) : n.rank > 0 ? n.json : n.string !== null ? Rd(n.string, i) : n.symbol !== null ? Wn(e12, n.symbol, i, { latex: n.verbatimLatex, wikidata: t }) : n.ops ? n.isValid && (n.isCanonical || n.isStructural) && i.prettify ? Ad(e12, n.operator, n.structural.ops, i, { latex: n.verbatimLatex, wikidata: t }) : L(e12, n.operator, n.structural.ops, i, { latex: n.verbatimLatex, wikidata: t }) : n.json;
}
function jr(e12, n, i, t = 1e5) {
  let r = 0;
  if (n === -1 / 0 && i === 1 / 0) for (let s = 0; s < t; s++) {
    let o = Math.random(), a = Math.tan(Math.PI * (o - 0.5)), u = Math.PI * (1 + a * a);
    r += e12(a) / u;
  }
  else if (n === -1 / 0) for (let s = 0; s < t; s++) {
    let o = Math.random(), a = i - Math.log(1 - o), u = 1 / (1 - o);
    r += e12(a) / u;
  }
  else if (i === 1 / 0) for (let s = 0; s < t; s++) {
    let o = Math.random(), a = n + Math.log(o), u = 1 / o;
    r += e12(a) / u;
  }
  else for (let s = 0; s < t; s++) r += e12(n + Math.random() * (i - n));
  return r / t * (i - n);
}
function Zr(e12) {
  let n = 0, i = 0;
  for (let t of e12) n += t, i++;
  return i === 0 ? NaN : n / i;
}
function $l(e12, n) {
  let i = e12(0), t = 0;
  for (let r of n) i = i.add(r), t++;
  return t === 0 ? e12(NaN) : i.div(t);
}
function Cn(e12) {
  let n = [...e12].sort((t, r) => t - r), i = Math.floor(n.length / 2);
  return n.length % 2 === 0 ? (n[i - 1] + n[i]) / 2 : n[i];
}
function hi(e12) {
  let n = [...e12].sort((t, r) => t.cmp(r)), i = Math.floor(n.length / 2);
  return n.length % 2 === 0 ? n[i - 1].add(n[i]).div(2) : n[i];
}
function tt(e12) {
  let n = 0, i = 0, t = 0;
  for (let r of e12) n += r, i += r * r, t++;
  return t === 0 ? NaN : (i - n * n / t) / (t - 1);
}
function Do(e12, n) {
  let i = e12(0), t = e12(0), r = 0;
  for (let s of n) i = i.add(s), t = t.add(s.mul(s)), r++;
  return r === 0 ? e12(NaN) : t.sub(i.mul(i).div(r)).div(r - 1);
}
function rt(e12) {
  let n = 0, i = 0, t = 0;
  for (let r of e12) n += r, i += r * r, t++;
  return t === 0 ? NaN : (i - n * n / t) / t;
}
function Ao(e12, n) {
  let i = e12(0), t = e12(0), r = 0;
  for (let s of n) i = i.add(s), t = t.add(s.mul(s)), r++;
  return r === 0 ? e12(NaN) : t.sub(i.mul(i).div(r)).div(r);
}
function Vl(e12) {
  return Math.sqrt(tt(e12));
}
function zl(e12) {
  return Math.sqrt(rt(e12));
}
function Hr(e12) {
  let n = 0, i = 0, t = 0, r = 0;
  for (let o of e12) {
    let a = o;
    if (!Number.isFinite(a)) return NaN;
    n += a, i += a * a, t += a * a * a * a, r++;
  }
  if (r === 0) return NaN;
  let s = (i - n * n / r) / (r - 1);
  return (t - 4 * n * i / r + 6 * n * n * n / r / r - 3 * n * n * n * n / r / r / r) / (s * s);
}
function Gl(e12, n) {
  let i = e12(0), t = e12(0), r = e12(0), s = 0;
  for (let a of n) {
    let u = a;
    if (!u.isFinite()) return e12(NaN);
    i = i.add(u), t = t.add(u.mul(u)), r = r.add(u.mul(u).mul(u).mul(u)), s++;
  }
  if (s === 0) return e12(NaN);
  let o = t.sub(i.mul(i).div(s)).div(s - 1);
  return r.sub(i.mul(t).mul(4).div(s)).add(i.mul(i).mul(i).mul(6).div(s).div(s)).sub(i.mul(i).mul(i).mul(i).div(s).div(s).div(s)).div(o.mul(o));
}
function Wr(e12) {
  let n = 0, i = 0, t = 0, r = 0;
  for (let a of e12) {
    let u = a;
    if (!Number.isFinite(u)) return NaN;
    n += u, i += u * u, t += u * u * u, r++;
  }
  if (r === 0) return NaN;
  let s = (i - n * n / r) / (r - 1);
  return (t - i * n / r) / (r - 1) / Math.pow(s, 3 / 2) * Math.sqrt(r * 1);
}
function Ul(e12, n) {
  let i = e12(0), t = e12(0), r = e12(0), s = 0;
  for (let u of n) {
    let l = u;
    if (!l.isFinite()) return e12(NaN);
    i = i.add(l), t = t.add(l.mul(l)), r = r.add(l.mul(l).mul(l)), s++;
  }
  if (s === 0) return e12(NaN);
  let o = t.sub(i.mul(i).div(s)).div(s - 1);
  return r.sub(t.mul(i).div(s)).div(s - 1).div(o.pow(3 / 2)).mul(s).sqrt();
}
function Jr(e12) {
  var _a2;
  let n = {};
  for (let r of e12) n[r] = ((_a2 = n[r]) != null ? _a2 : 0) + 1;
  let i = 0, t = NaN;
  for (let r in n) {
    let s = n[r];
    s > i && (i = s, t = +r);
  }
  return t;
}
function jl(e12, n) {
  var _a2;
  let i = {};
  for (let s of n) i[s.toString()] = ((_a2 = i[s.toString()]) != null ? _a2 : 0) + 1;
  let t = 0, r = e12(NaN);
  for (let s in i) {
    let o = i[s];
    o > t && (t = o, r = e12(s));
  }
  return r;
}
function Yr(e12) {
  let n = [...e12].sort((o, a) => o - a), i = Math.floor(n.length / 2), t = Cn(n.slice(0, i)), r = Cn(n), s = Cn(n.slice(i));
  return [t, r, s];
}
function Zl(e12) {
  let n = [...e12].sort((o, a) => o.cmp(a)), i = Math.floor(n.length / 2), t = hi(n.slice(0, i)), r = hi(n), s = hi(n.slice(i));
  return [t, r, s];
}
function Qr(e12) {
  let n = [...e12].sort((s, o) => s - o), i = Math.floor(n.length / 2), t = n.slice(0, i), r = n.slice(i + 1);
  return Cn(r) - Cn(t);
}
function Hl(e12) {
  let n = [...e12].sort((s, o) => s.cmp(o)), i = Math.floor(n.length / 2), t = n.slice(0, i), r = n.slice(i + 1);
  return hi(r).sub(hi(t));
}
var Md = { Add: ["+", 11], Negate: ["-", 14], Subtract: ["-", 11], Multiply: ["*", 12], Divide: ["/", 13], Equal: ["===", 8], NotEqual: ["!==", 8], LessEqual: ["<=", 9], GreaterEqual: [">=", 9], Less: ["<", 9], Greater: [">", 9], And: ["&&", 4], Or: ["||", 3], Not: ["!", 14] };
var Cd = { Abs: "Math.abs", Add: (e12, n) => e12.length === 1 ? n(e12[0]) : `(${e12.map((i) => n(i)).join(" + ")})`, Arccos: "Math.acos", Arccosh: "Math.acosh", Arccot: ([e12], n) => {
  if (e12 === null) throw new Error("Arccot: no argument");
  return `Math.atan(1 / (${n(e12)}))`;
}, Arccoth: ([e12], n) => {
  if (e12 === null) throw new Error("Arccoth: no argument");
  return `Math.atanh(1 / (${n(e12)}))`;
}, Arccsc: ([e12], n) => {
  if (e12 === null) throw new Error("Arccsc: no argument");
  return `Math.asin(1 / (${n(e12)}))`;
}, Arccsch: ([e12], n) => {
  if (e12 === null) throw new Error("Arccsch: no argument");
  return `Math.asinh(1 / (${n(e12)}))`;
}, Arcsec: ([e12], n) => {
  if (e12 === null) throw new Error("Arcsec: no argument");
  return `Math.acos(1 / (${n(e12)}))`;
}, Arcsech: ([e12], n) => {
  if (e12 === null) throw new Error("Arcsech: no argument");
  return `Math.acosh(1 / (${n(e12)}))`;
}, Arcsin: "Math.asin", Arcsinh: "Math.asinh", Arctan: "Math.atan", Arctanh: "Math.atanh", Ceiling: "Math.ceil", Chop: "_SYS.chop", Cos: "Math.cos", Cosh: "Math.cosh", Cot: ([e12], n) => {
  if (e12 === null) throw new Error("Cot: no argument");
  return Wl("Math.cos(${x}) / Math.sin(${x})", n(e12));
}, Coth: ([e12], n) => {
  if (e12 === null) throw new Error("Coth: no argument");
  return Wl("(Math.cosh(${x}) / Math.sinh(${x}))", n(e12));
}, Csc: ([e12], n) => {
  if (e12 === null) throw new Error("Csc: no argument");
  return `1 / Math.sin(${n(e12)})`;
}, Csch: ([e12], n) => {
  if (e12 === null) throw new Error("Csch: no argument");
  return `1 / Math.sinh(${n(e12)})`;
}, Exp: "Math.exp", Floor: "Math.floor", Gamma: "_SYS.gamma", GCD: "_SYS.gcd", Integrate: (e12, n, i) => Ld(e12, n, i), LCM: "_SYS.lcm", Limit: (e12, n) => `_SYS.limit(${n(e12[0])}, ${n(e12[1])})`, Ln: "Math.log", List: (e12, n) => `[${e12.map((i) => n(i)).join(", ")}]`, Log: (e12, n) => e12.length === 1 ? `Math.log10(${n(e12[0])})` : `(Math.log(${n(e12[0])}) / Math.log(${n(e12[1])}))`, LogGamma: "_SYS.lngamma", Lb: "Math.log2", Max: "Math.max", Mean: (e12, n) => e12.length === 0 ? "NaN" : e12.length === 1 ? `_SYS.mean(${n(e12[0])})` : `_SYS.mean([${e12.map((i) => n(i)).join(", ")}])`, Median: (e12, n) => e12.length === 0 ? "NaN" : e12.length === 1 ? `_SYS.median(${n(e12[0])})` : `_SYS.median([${e12.map((i) => n(i)).join(", ")}])`, Variance: (e12, n) => e12.length === 0 ? "NaN" : e12.length === 1 ? `_SYS.variance(${n(e12[0])})` : `_SYS.variance([${e12.map((i) => n(i)).join(", ")}])`, PopulationVariance: (e12, n) => e12.length === 0 ? "NaN" : e12.length === 1 ? `_SYS.populationVariance(${n(e12[0])})` : `_SYS.populationVariance([${e12.map((i) => n(i)).join(", ")}])`, StandardDeviation: (e12, n) => e12.length === 0 ? "NaN" : e12.length === 1 ? `_SYS.standardDeviation(${n(e12[0])})` : `_SYS.standardDeviation([${e12.map((i) => n(i)).join(", ")}])`, PopulationStandardDeviation: (e12, n) => e12.length === 0 ? "NaN" : e12.length === 1 ? `_SYS.populationStandardDeviation(${n(e12[0])})` : `_SYS.populationStandardDeviation([${e12.map((i) => n(i)).join(", ")}])`, Kurtosis: (e12, n) => e12.length === 0 ? "NaN" : e12.length === 1 ? `_SYS.kurtosis(${n(e12[0])})` : `_SYS.kurtosis([${e12.map((i) => n(i)).join(", ")}])`, Skewness: (e12, n) => e12.length === 0 ? "NaN" : e12.length === 1 ? `_SYS.skewness(${n(e12[0])})` : `_SYS.skewness([${e12.map((i) => n(i)).join(", ")}])`, Mode: (e12, n) => e12.length === 0 ? "NaN" : e12.length === 1 ? `_SYS.mode(${n(e12[0])})` : `_SYS.mode([${e12.map((i) => n(i)).join(", ")}])`, Quartiles: (e12, n) => e12.length === 0 ? "NaN" : e12.length === 1 ? `_SYS.quartiles(${n(e12[0])})` : `_SYS.quartiles([${e12.map((i) => n(i)).join(", ")}])`, InterquartileRange: (e12, n) => e12.length === 0 ? "NaN" : e12.length === 1 ? `_SYS.interquartileRange(${n(e12[0])})` : `_SYS.interquartileRange([${e12.map((i) => n(i)).join(", ")}])`, Min: "Math.min", Power: (e12, n) => {
  let i = e12[0];
  if (i === null) throw new Error("Power: no argument");
  let t = e12[1].re;
  return t === 0.5 ? `Math.sqrt(${n(i)})` : t === 1 / 3 ? `Math.cbrt(${n(i)})` : t === 1 ? n(i) : t === -1 ? `(1 / (${n(i)}))` : t === -0.5 ? `(1 / Math.sqrt(${n(i)}))` : `Math.pow(${n(i)}, ${n(e12[1])})`;
}, Range: (e12, n) => {
  if (e12.length === 0) return "[]";
  if (e12.length === 1) return `Array.from({length: ${n(e12[0])}}, (_, i) => i)`;
  let i = n(e12[0]), t = n(e12[1]), r = e12[2] ? n(e12[2]) : "1";
  if (i === null) throw new Error("Range: no start");
  if (t === null && (t = i, i = "1"), r === "0") throw new Error("Range: step cannot be zero");
  if (parseFloat(r) === 1) {
    let s = parseFloat(t), o = parseFloat(i);
    return s !== null && o !== null ? s - o < 50 ? `[${Array.from({ length: s - o + 1 }, (a, u) => o + u).join(", ")}]` : `Array.from({length: ${s - o + 1} 
        }, (_, i) => ${i} + i)` : `Array.from({length: ${t} - ${i} + 1
      }, (_, i) => ${i} + i)`;
  }
  return `Array.from({length: Math.floor((${t} - ${i}) / ${r}) + 1}, (_, i) => ${i} + i * ${r})`;
}, Root: ([e12, n], i) => {
  if (e12 === null) throw new Error("Root: no argument");
  return n === null ? `Math.sqrt(${i(e12)})` : (n == null ? void 0 : n.re) === 2 ? `Math.sqrt(${i(e12)})` : (n == null ? void 0 : n.re) === 3 ? `Math.cbrt(${i(e12)})` : isNaN(n == null ? void 0 : n.re) ? `Math.pow(${i(e12)}, 1 / (${i(n)}))` : `Math.pow(${i(e12)},  ${1 / n.re})`;
}, Random: "Math.random", Round: "Math.round", Square: (e12, n) => {
  let i = e12[0];
  if (i === null) throw new Error("Square: no argument");
  return `Math.pow(${n(i)}, 2)`;
}, Sec: (e12, n) => {
  let i = e12[0];
  if (i === null) throw new Error("Sec: no argument");
  return `1 / Math.cos(${n(i)})`;
}, Sech: (e12, n) => {
  let i = e12[0];
  if (i === null) throw new Error("Sech: no argument");
  return `1 / Math.cosh(${n(i)})`;
}, Sgn: "Math.sign", Sin: "Math.sin", Sinh: "Math.sinh", Sqrt: "Math.sqrt", Tan: "Math.tan", Tanh: "Math.tanh" };
var Ro = class extends Function {
  constructor(i, t = "") {
    super("_SYS", "_", `${t};return ${i}`);
    this.sys = { chop: Qa, factorial: Ja, gamma: ci, gcd: rn, integrate: (i2, t2, r) => jr(i2, t2, r, 1e7), lcm: ki, lngamma: Mt, limit: ii, mean: Zr, median: Cn, variance: tt, populationVariance: rt, standardDeviation: Vl, populationStandardDeviation: zl, kurtosis: Hr, skewness: Wr, mode: Jr, quartiles: Yr, interquartileRange: Qr };
    return new Proxy(this, { apply: (r, s, o) => super.apply(s, [this.sys, ...o]), get: (r, s) => s === "toString" ? () => i : r[s] });
  }
};
function Pd(e12, n) {
  let i = ye(e12, n);
  return new Ro(i, n.preamble);
}
function Jl(e12, n, i, t = [], r) {
  let s = e12.unknowns, o = t.map((u) => {
    if (typeof u == "function") return u.toString();
    throw new Error(`Unsupported import \`${u}\``);
  }).join(`
`), a = n ? Object.fromEntries(Object.entries(n).filter((u, l) => typeof l != "string")) : {};
  if (n) for (let [u, l] of Object.entries(n)) typeof l == "function" && (Fd(l) ? (o += `${l.toString()};
`, a[u] = l.name) : (o += `const ${u} = ${l.toString()};
`, a[u] = u));
  return Pd(e12, { operators: (u) => Md[u], functions: (u) => (a == null ? void 0 : a[u]) ? a[u] : Cd[u], var: (u) => {
    if (i && u in i) return JSON.stringify(i[u]);
    let l = { Pi: "Math.PI", ExponentialE: "Math.E", NaN: "Number.NaN", ImaginaryUnit: "Number.NaN", Half: "0.5", MachineEpsilon: "Number.EPSILON", GoldenRatio: "((1 + Math.sqrt(5)) / 2)", CatalanConstant: "0.91596559417721901", EulerGamma: "0.57721566490153286" }[u];
    if (l !== void 0) return l;
    if (s.includes(u)) return `_.${u}`;
  }, string: (u) => JSON.stringify(u), number: (u) => u.toString(), indent: 0, ws: (u) => u != null ? u : "", preamble: (r != null ? r : "") + o });
}
function Yl(e12, n, i, t, r) {
  var _a2, _b, _c2;
  if (n === "Error") throw new Error("Error");
  if (n === "Sequence") return i.length === 0 ? "" : `(${i.map((o) => ye(o, r, t)).join(", ")})`;
  if (n === "Sum" || n === "Product") return Od(n, i, r);
  if (i.every((o) => !o.isCollection)) {
    let o = (_a2 = r.operators) == null ? void 0 : _a2.call(r, n);
    if (we(n) && i.length > 2 && o) {
      let a = [];
      for (let u = 0; u < i.length - 1; u++) a.push(Yl(e12, n, [i[u], i[u + 1]], o[1], r));
      return `(${a.join(") && (")})`;
    }
    if (o !== void 0) {
      if (i === null) return "";
      let a;
      return i.length === 1 ? a = `${o[0]}${ye(i[0], r, o[1])}` : a = i.map((u) => ye(u, r, o[1])).join(` ${o[0]} `), o[1] < t ? `(${a})` : a;
    }
  }
  if (n === "Function") {
    let o = i.slice(1).map((a) => a.symbol);
    return `((${o.join(", ")}) => ${ye(i[0].canonical, { ...r, var: (a) => o.includes(a) ? a : r.var(a) })})`;
  }
  if (n === "Declare") return `let ${i[0].symbol}`;
  if (n === "Assign") return `${i[0].symbol} = ${ye(i[1], r)}`;
  if (n === "Return") return `return ${ye(i[0], r)}`;
  if (n === "If") {
    if (i.length !== 3) throw new Error("If: wrong number of arguments");
    return `((${ye(i[0], r)}) ? (${ye(i[1], r)}) : (${ye(i[2], r)}))`;
  }
  if (n === "Block") {
    let o = [];
    for (let u of i) u.operator === "Declare" && o.push(u.ops[0].symbol);
    if (i.length === 1 && o.length === 0) return ye(i[0], r);
    let a = i.map((u) => ye(u, { ...r, var: (l) => o.includes(l) ? l : r.var(l) }));
    return a[a.length - 1] = `return ${a[a.length - 1]}`, `(() => {${r.ws(`
`)}${a.join(`;${r.ws(`
`)}`)}${r.ws(`
`)}})()`;
  }
  let s = (_b = r.functions) == null ? void 0 : _b.call(r, n);
  if (!s) throw new Error(`Unknown function \`${n}\``);
  if (typeof s == "function") {
    if (((_c2 = e12.lookupFunction(n)) == null ? void 0 : _c2.threadable) && i.length === 1 && ie(i[0])) {
      let a = Ht();
      return `(${ye(i[0], r)}).map((${a}) => ${s([i[0].engine.box(a)], (u) => ye(u, r), r)})`;
    }
    return s(i, (a) => ye(a, r), r);
  }
  return i === null ? `${s}()` : `${s}(${i.map((o) => ye(o, r)).join(", ")})`;
}
function ye(e12, n, i = 0) {
  var _a2, _b;
  if (e12 === void 0) return "";
  if (!e12.isValid) throw new Error(`Cannot compile invalid expression: "${e12.toString()}"`);
  let t = e12.symbol;
  if (t !== null) return (_b = (_a2 = n.var) == null ? void 0 : _a2.call(n, t)) != null ? _b : t;
  if (e12.isNumberLiteral) {
    if (e12.im !== 0) throw new Error("Complex numbers are not supported");
    return n.number(e12.re);
  }
  return e12.string !== null ? n.string(t) : Yl(e12.engine, e12.operator, e12.ops, i, n);
}
function Od(e12, n, i) {
  if (n === null) throw new Error("Sum/Product: no arguments");
  if (!n[0]) throw new Error("Sum/Product: no body");
  let { index: t, lower: r, upper: s, isFinite: o } = nt(n[1]), a = e12 === "Sum" ? "+" : "*";
  if (!t) {
    let f = Ht(), c = Ht();
    return `${ye(n[0], i)}.reduce((${c}, ${f}) => ${c} ${a} ${f}, ${a === "+" ? "0" : "1"})`;
  }
  let u = ye(n[0], { ...i, var: (f) => f === t ? t : i.var(f) }), l = Ht();
  return `(() => {
  let ${l} = ${a === "+" ? "0" : "1"};
  let ${t} = ${r};
  while (${t} <= ${s}) {
    ${l} ${a}= ${u};
    ${t}++;
  }
  return ${l};
})()`;
}
function Wl(e12, n) {
  if (/^[\p{L}_][\p{L}\p{N}_]*$/u.test(n) || /^[0-9]+$/.test(n)) return new Function("x", `return \`${e12}\`;`)(n);
  {
    let t = Ht();
    return new Function("x", `return \`(() => { const ${t} = \${x}; return ${e12.replace(/\\\${x}/g, t)}; })()\`;`)(n);
  }
}
function Ht() {
  return `_${Math.random().toString(36).substring(4)}`;
}
function Ld(e12, n, i) {
  let { index: t, lower: r, upper: s } = nt(e12[1]), o = ye(e12[0], { ...i, var: (a) => a === t ? a : i.var(a) });
  return `_SYS.integrate((${t}) => (${o}), ${r}, ${s})`;
}
function Fd(e12) {
  let n = e12.toString();
  return n.includes("=>") ? false : n.startsWith("function ") && n.includes(e12.name);
}
function Xl(e12, n, i) {
  var _a2;
  if (i.repeatingDecimal && i.repeatingDecimal !== "none") {
    let s = e12.slice(0, -1);
    for (let o = 0; o < e12.length - 16; o++) {
      let a = s.substring(0, o);
      for (let u = 0; u < 17; u++) {
        let l = s.substring(o, o + u + 1), f = Math.floor((s.length - a.length) / l.length);
        if (f <= 3) break;
        if ((a + l.repeat(f + 1)).startsWith(s)) {
          if (l === "0") return Mo(a, i);
          let c = (_a2 = { vinculum: "\\overline{#}", parentheses: "(#)", dots: "\\overset{\\cdots}{#1}#2\\overset{\\cdots}{#3}", arc: "\\wideparen{#}" }[i.repeatingDecimal]) != null ? _a2 : "\\overline{#}";
          return c = c.replace(/#1/g, l[0]).replace(/#2/g, l.slice(1)).replace(/#3/g, l.slice(-1)).replace(/#/, l), Mo(a, i) + c;
        }
      }
    }
  }
  let t = typeof i.fractionalDigits == "number" ? i.fractionalDigits : 1 / 0;
  t < 0 && (t = t - n), t < 0 && (t = 0);
  let r = e12.length > t;
  return r && (e12 = e12.substring(0, t)), e12 = Mo(e12, i), r && (e12 += i.truncationMarker), e12;
}
function Kl(e12, n) {
  var _a2;
  return !e12 || e12 === "0" ? "" : n.beginExponentMarker ? n.beginExponentMarker + e12 + ((_a2 = n.endExponentMarker) != null ? _a2 : "") : `10^{${e12}}`;
}
function ef(e12, n) {
  var _a2;
  if (e12 === null) return "";
  let i;
  if (typeof e12 == "number" || typeof e12 == "string") i = e12;
  else if (typeof e12 == "object" && "num" in e12) i = e12.num;
  else return "";
  if (typeof i == "number") {
    if (i === 1 / 0) return n.positiveInfinity;
    if (i === -1 / 0) return n.negativeInfinity;
    if (Number.isNaN(i)) return n.notANumber;
    let s;
    return n.notation === "engineering" ? s = Xr(i.toExponential(), n, 3) : n.notation === "scientific" && (s = Xr(i.toExponential(), n)), s != null ? s : Co(i.toString(), n);
  }
  if (i = i.toLowerCase().replace(/[\u0009-\u000d\u0020\u00a0]/g, ""), i === "infinity" || i === "+infinity") return n.positiveInfinity;
  if (i === "-infinity") return n.negativeInfinity;
  if (i === "nan") return n.notANumber;
  if (!/^[-+\.]?[0-9]/.test(i)) return "";
  if (i = i.replace(/[nd]$/, ""), /\([0-9]+\)/.test(i)) {
    let [s, o, a, u] = (_a2 = i.match(/(.+)\(([0-9]+)\)(.*)$/)) != null ? _a2 : [];
    i = o + a.repeat(6) + u;
  }
  let t = "";
  for (i[0] === "-" ? (t = "-", i = i.substring(1)) : i[0] === "+" && (i = i.substring(1)); i[0] === "0"; ) i = i.substring(1);
  i.length === 0 ? i = "0" : i[0] === "." && (i = "0" + i);
  let r;
  return n.notation === "engineering" ? r = Xr(i, n, 3) : n.notation === "scientific" && (r = Xr(i, n)), t + (r != null ? r : Co(i, n));
}
function Xr(e12, n, i = 1) {
  var _a2;
  let t = e12.match(/^(.*)[e|E]([-+]?[0-9]+)$/);
  if (!t) {
    let f = "";
    if (e12[0] === "-" ? (f = "-", e12 = e12.substring(1)) : e12[0] === "+" && (e12 = e12.substring(1)), e12.indexOf(".") < 0) e12.length === 1 ? e12 = f + e12 + "e+0" : e12 = f + e12[0] + "." + e12.slice(1) + "e+" + (e12.length - 1).toString();
    else {
      let [c, p, m] = e12.match(/^(.*)\.(.*)$/);
      for (m || (m = ""); p.startsWith("0"); ) p = p.substring(1);
      p ? e12 = f + p[0] + "." + p.slice(1) + m + "e+" + (p.length - 1).toString() : e12 = f + "0." + m + "e+0";
    }
    t = e12.match(/^(.*)[e|E]([-+]?[0-9]+)$/);
  }
  if (!t) return Co(e12, n);
  let r = parseInt(t[2]), s = t[1];
  if (Math.abs(r) % i !== 0) {
    let f = r > 0 ? r % i : -((i + r) % i);
    r = r >= 0 ? r - f : r + f;
    let [c, p, m] = (_a2 = s.match(/^(.*)\.(.*)$/)) != null ? _a2 : ["", s, ""];
    s = p + (m + "00000000000000000").slice(0, Math.abs(f)) + "." + m.slice(Math.abs(f));
  }
  let o = n.avoidExponentsInRange;
  if (o && r >= o[0] && r <= o[1]) return;
  let a = "", u = s;
  t = u.match(/^(.*)\.(.*)$/), t && (u = t[1], a = t[2]);
  let l = Kl(Number(r).toString(), n);
  if (a = Xl(a, u.length, n), u = tf(u, n), a && (a = n.decimalSeparator + a), !l) return u + a;
  if (!a) {
    if (u === "1") return l;
    if (u === "-1") return "-" + l;
  }
  return u + a + n.exponentProduct + l;
}
function Co(e12, n) {
  var _a2;
  let i = e12.match(/^(.*)[e|E]([-+]?[0-9]+)$/i), t = 0;
  (i == null ? void 0 : i[1]) && i[2] && (t = parseInt(i[2]), e12 = i[1]);
  let r = (_a2 = i == null ? void 0 : i[1]) != null ? _a2 : e12, s = "";
  i = e12.match(/^(.*)\.(.*)$/), (i == null ? void 0 : i[1]) && i[2] && (r = i[1], s = i[2]), t !== 0 && s && (r += s, t -= s.length, s = "");
  let o = n.avoidExponentsInRange;
  t !== 0 && o && t >= o[0] && t <= o[1] && ([r, s] = Vd(r, s, t), t = 0);
  let a = Kl(t.toString(), n);
  if (s && (s = n.decimalSeparator + Xl(s, r.length, n)), r = tf(r, n), !a) return r + s;
  if (!s) {
    if (r === "1") return a;
    if (r === "-1") return "-" + a;
  }
  return r + s + n.exponentProduct + a;
}
function Ql(e12, n, i) {
  let t = new RegExp(`(\\d{${n}})(?=\\d)`, "g");
  return e12.replace(t, `$1${i}`);
}
function qd(e12, n, i) {
  let t = new RegExp(`(\\d{${n}})(?=\\d)`, "g"), r = i.split("").reverse().join("");
  return e12.split("").reverse().join("").replace(t, `$1${r}`).split("").reverse().join("");
}
function $d(e12, n) {
  let i = e12.split("").reverse().join(""), t = n.split("").reverse().join(""), r = i.replace(/(\d{3})(?=\d)/, `$1${t}`);
  return r = r.replace(/(\d{2})(?=(\d{2})+,)/g, `$1${t}`), r.split("").reverse().join("");
}
function nf(e12, n, i) {
  let t = n.digitGroup;
  typeof t != "string" && Array.isArray(t) && (t = t[i]);
  let r = typeof n.digitGroupSeparator == "string" ? n.digitGroupSeparator : n.digitGroupSeparator[i];
  return r ? t === "lakh" ? i === 0 ? $d(e12, r) : Ql(e12, 3, r) : t === false || t <= 0 ? e12 : i === 1 ? Ql(e12, t, r) : qd(e12, t, r) : e12;
}
function Mo(e12, n) {
  return nf(e12, n, 1);
}
function tf(e12, n) {
  return nf(e12, n, 0);
}
function Vd(e12, n, i) {
  let t = e12 + n, s = e12.length + i, o, a;
  return s > 0 ? s >= t.length ? (t = t + "0".repeat(s - t.length), o = t, a = "") : (o = t.slice(0, s), a = t.slice(s)) : (o = "0", a = "0".repeat(-s) + t), [o, a];
}
var Oo = { deg: (e12) => `${e12}\\degree`, prime: (e12) => `${e12}^{\\prime}`, dprime: (e12) => `${e12}^{\\doubleprime}`, ring: (e12) => `\\mathring{${e12}}`, hat: (e12) => `\\hat{${e12}}`, tilde: (e12) => `\\tilde{${e12}}`, vec: (e12) => `\\vec{${e12}}`, bar: (e12) => `\\overline{${e12}}`, underbar: (e12) => `\\underline{${e12}}`, dot: (e12) => `\\dot{${e12}}`, ddot: (e12) => `\\ddot{${e12}}`, tdot: (e12) => `\\dddot{${e12}}`, qdot: (e12) => `\\ddddot{${e12}}`, acute: (e12) => `\\acute{${e12}}`, grave: (e12) => `\\grave{${e12}}`, breve: (e12) => `\\breve{${e12}}`, check: (e12) => `\\check{${e12}}` };
var Lo = { upright: (e12) => `\\mathrm{${e12}}`, italic: (e12) => `\\mathit{${e12}}`, bold: (e12) => `\\mathbf{${e12}}`, script: (e12) => `\\mathscr{${e12}}`, fraktur: (e12) => `\\mathfrak{${e12}}`, doublestruck: (e12) => `\\mathbb{${e12}}`, blackboard: (e12) => `\\mathbb{${e12}}`, calligraphic: (e12) => `\\mathcal{${e12}}`, gothic: (e12) => `\\mathfrak{${e12}}`, sansserif: (e12) => `\\mathsf{${e12}}`, monospace: (e12) => `\\mathtt{${e12}}` };
var Fo = class {
  constructor(n, i) {
    this.level = -1;
    this.dictionary = n, this.options = i;
  }
  wrap(n, i) {
    if (n == null) return "";
    if (i === void 0) return this.wrapString(this.serialize(n), this.options.groupStyle(n, this.level + 1));
    if (typeof n == "number" || Fi(n)) {
      let r = D(n);
      return r !== null && r < 0 && i > 275 ? this.wrap(n) : this.serialize(n);
    }
    let t = h(n);
    if (t && t !== "Delimiter" && t !== "Subscript") {
      let r = this.dictionary.ids.get(t);
      if (r && (r.kind === "symbol" || r.kind === "expression" || r.kind === "prefix" || r.kind === "infix" || r.kind === "postfix") && r.precedence < i) return this.wrapString(this.serialize(n), this.options.applyFunctionStyle(n, this.level));
    }
    return this.serialize(n);
  }
  wrapShort(n) {
    if (n == null) return "";
    let i = this.serialize(n);
    if (A(n) !== null || kn(n) && !/^(-|\.)/.test(i)) return i;
    let r = h(n);
    return r === "Delimiter" && Y(n) === 1 || r !== "Add" && r !== "Negate" && r !== "Subtract" && r !== "PlusMinus" && r !== "Multiply" ? i : this.wrapString(i, this.options.groupStyle(n, this.level + 1));
  }
  wrapString(n, i, t) {
    var _a2, _b, _c2, _d2;
    if (i === "none") return n;
    t != null ? t : t = "()";
    let r = (_a2 = t == null ? void 0 : t[0]) != null ? _a2 : ".", s = (_b = t == null ? void 0 : t[1]) != null ? _b : ".";
    return r === '"' ? r = "``" : r === "|" ? r = "\\lvert" : r = (_c2 = ji[r]) != null ? _c2 : r, s === '"' ? s = "''" : s === "|" ? s = "\\rvert" : s = (_d2 = ji[s]) != null ? _d2 : s, r === "." && s === "." ? n : ((r === "." || s === ".") && i === "normal" && (i = "scaled"), i === "scaled" ? `\\left${r}${n}\\right${s}}` : i === "big" ? `${`\\Bigl${r}`}${n}${`\\Bigr${s}`})` : r + n + s);
  }
  wrapArguments(n) {
    return this.wrapString(N(n).map((i) => this.serialize(i)).join(", "), this.options.applyFunctionStyle(n, this.level));
  }
  serializeSymbol(n, i) {
    var _a2, _b, _c2, _d2, _e2;
    return typeof n == "string" || kr(n), (i == null ? void 0 : i.kind) === "function" ? (_b = Po((_a2 = A(n)) != null ? _a2 : "")) != null ? _b : "" : (_e2 = (_d2 = (_c2 = i == null ? void 0 : i.serialize) == null ? void 0 : _c2.call(i, this, n)) != null ? _d2 : Po(A(n))) != null ? _e2 : "";
  }
  serializeFunction(n, i) {
    if (i == null ? void 0 : i.serialize) return i.serialize(this, n);
    let t = h(n);
    return Po(t, "auto") + this.wrapArguments(n);
  }
  serialize(n) {
    if (n == null) return "";
    this.level += 1;
    try {
      let i = (() => {
        let t = ef(n, this.options);
        if (t) return t;
        let r = V(n);
        if (r !== null) return `\\text{${r}}`;
        let s = A(n);
        if (s !== null) return this.serializeSymbol(n, this.dictionary.ids.get(s));
        let o = h(n);
        if (o) {
          let a = this.dictionary.ids.get(o);
          return this.serializeFunction(n, a);
        }
        throw Error(`Syntax error ${n ? JSON.stringify(n) : ""}`);
      })();
      return this.level -= 1, i != null ? i : "";
    } catch (e12) {
    }
    return this.level -= 1, "";
  }
  applyFunctionStyle(n, i) {
    return this.options.applyFunctionStyle(n, i);
  }
  groupStyle(n, i) {
    return this.options.groupStyle(n, i);
  }
  rootStyle(n, i) {
    return this.options.rootStyle(n, i);
  }
  fractionStyle(n, i) {
    return this.options.fractionStyle(n, i);
  }
  logicStyle(n, i) {
    return this.options.logicStyle(n, i);
  }
  powerStyle(n, i) {
    return this.options.powerStyle(n, i);
  }
  numericSetStyle(n, i) {
    return this.options.numericSetStyle(n, i);
  }
};
function zd(e12) {
  var _a2, _b;
  let n = (_b = (_a2 = e12.match(/^([^_]+)/)) == null ? void 0 : _a2[1]) != null ? _b : "", i = sn.findIndex((o) => n === o[0]);
  if (i >= 0) return [sn[i][1], e12.substring(sn[i][0].length)];
  let t = { zero: "0", one: "1", two: "2", three: "3", four: "4", five: "5", six: "6", seven: "7", eight: "8", nine: "9", ten: "10" };
  if (i = Object.keys(t).findIndex((o) => e12.startsWith(o)), i >= 0) {
    let o = Object.keys(t)[i];
    return [t[o], e12.substring(o.length)];
  }
  let r = e12.codePointAt(0);
  if (i = sn.findIndex((o) => o[2] === r), i >= 0) return [sn[i][1], e12.substring(1)];
  let s = { plus: "+", minus: "-", pm: "\\pm", ast: "\\ast", dag: "\\dag", ddag: "\\ddag", hash: "\\#", bottom: "\\bot", top: "\\top", bullet: "\\bullet", circle: "\\circ", diamond: "\\diamond", times: "\\times", square: "\\square", star: "\\star" };
  if (i = Object.keys(s).findIndex((o) => n === o), i >= 0) {
    let o = Object.keys(s)[i];
    return [s[o], e12.substring(o.length)];
  }
  return [n, e12.substring(n.length)];
}
function Gd(e12) {
  let [n, i] = zd(e12), t = [];
  for (; i.length > 0; ) {
    let s = i.match(/^_([a-zA-Z]+)(.*)/);
    if (!s || !Oo[s[1]]) break;
    t.push(s[1]), i = s[2];
  }
  let r = [];
  for (; i.length > 0; ) {
    let s = i.match(/^_([a-zA-Z]+)(.*)/);
    if (!s || !Lo[s[1]]) break;
    r.push(s[1]), i = s[2];
  }
  return [n, t, r, i];
}
function Kr(e12, n = true, i = "auto") {
  let [t, r, s, o] = Gd(e12);
  for (let a of r) Oo[a] && (t = Oo[a](t));
  if (n) {
    let a = [], u = [], l = t.match(/^([^\d].*?)(\d+)$/);
    for (l && (u.push(l[2]), t = l[1]); o.length > 0; ) if (o.startsWith("__")) {
      let [f, c] = Kr(o.substring(2), false, "none");
      a.push(f), o = c;
    } else if (o.startsWith("_")) {
      let [f, c] = Kr(o.substring(1), false, "none");
      u.push(f), o = c;
    } else break;
    a.length > 0 && (t = Ii("^", t, a.join(","))), u.length > 0 && (t = Ii("_", t, u.join(",")));
  }
  for (let a of s) Lo[a] && (t = Lo[a](t));
  if (s.length === 0 && i !== "none") switch (i) {
    case "auto":
      yr(t) > 1 && (t = `\\mathrm{${t}}`);
      break;
    case "operator":
      t = `\\operatorname{${t}}`;
      break;
    case "italic":
      t = `\\mathit{${t}}`;
      break;
    case "upright":
      t = `\\mathrm{${t}}`;
      break;
  }
  return [t, o];
}
function Po(e12, n = "auto") {
  if (e12 === null) return null;
  if (Gi.test(e12)) return e12;
  let i = e12.match(/^(_+)(.*)/);
  if (i) {
    let [s, o] = Kr(i[2], true, "none");
    return `\\operatorname{${"\\_".repeat(i[1].length) + s + o}}`;
  }
  let [t, r] = Kr(e12, true, n);
  return r.length > 0 ? `\\operatorname{${e12}}` : t;
}
function rf(e12, n, i) {
  return new Fo(n, i).serialize(e12);
}
var sf = { PositiveInfinity: "+oo", NegativeInfinity: "-oo", ComplexInfinity: "~oo", NaN: "NaN", Pi: "pi", ExponentialE: "e", ImaginaryUnit: "i", alpha: "alpha", beta: "beta", gamma: "gamma", delta: "delta", epsilon: "epsilon", epsilonSymbol: "varepsilon", zeta: "zeta", eta: "eta", theta: "theta", thetaSymbol: "vartheta", iota: "iota", kappa: "kappa", lambda: "lambda", mu: "mu", nu: "nu", xi: "xi", omicron: "omicron", pi: "pi", rho: "rho", sigma: "sigma", tau: "tau", upsilon: "upsilon", phi: "phi", phiSymbol: "varphi", chi: "chi", psi: "psi", omega: "omega", Gamma: "Gamma", Delta: "Delta", Theta: "Theta", Lambda: "Lambda", Xi: "Xi", Sigma: "Sigma", Upsilon: "Upsilon", Phi: "Phi", Psi: "Psi", Omega: "Omega" };
var of = { Add: [(e12, n) => {
  var _a2, _b;
  return (_b = (_a2 = e12.ops) == null ? void 0 : _a2.reduce((i, t) => {
    if (t.operator === "Negate") {
      let r = n(t.op1, 10);
      return i === "" ? `-${r}` : r.startsWith("+") ? `${i} - ${r.substring(1)}` : r.startsWith("-") ? `${i} + ${r.substring(1)}` : `${i} - ${r}`;
    }
    return af(i, n(t, 10));
  }, "")) != null ? _b : "";
}, 11], Negate: [(e12, n) => {
  let i = n(e12.op1, 14);
  return i === "Power" ? `-(${i})` : `-${i}`;
}, 14], Subtract: [(e12, n) => {
  var _a2, _b;
  return (_b = (_a2 = e12.ops) == null ? void 0 : _a2.reduce((i, t) => {
    let r = n(t, 10);
    return i === "" ? r : r.startsWith("-") ? `${i} - (${r})` : `${i} - ${r}`;
  }, "")) != null ? _b : "";
}, 11], Multiply: [(e12, n) => {
  if (!e12.ops) return "";
  if (e12.nops === 2) {
    let i = e12.op1.numericValue;
    if (i !== null) {
      typeof i != "number" && i.im !== 0 && $o(n(e12.op2, 12), af(i.re.toString(), `${i.im}i`));
      let t = e12.op2;
      if ((t.symbol || t.operator === "Power" || t.operator === "Square" || typeof Vo[t.operator] == "string") && Bn(i) && i[0] === 1) {
        let r = i[1];
        return `${n(t, 12)}/${r}`;
      }
      return $o(n(e12.op1, 12), n(e12.op2, 12));
    }
  }
  return e12.ops.reduce((i, t) => $o(i, n(t, 12)), "");
}, 12], Divide: ["/", 13], Power: [(e12, n) => {
  let i = n(e12.op2, 14);
  if (i === "1") return n(e12.op1);
  if (i === "(1/2)" || i === "1/2" || i === "0.5") return `sqrt(${n(e12.op1)})`;
  if (i === "-0.5") return `(1/sqrt(${n(e12.op1)}))`;
  let t = n(e12.op1, 14);
  return t.startsWith("-") && (t = `(${t})`), i.length === 1 ? `${t}^${i}` : `${t}^${gi(i)}`;
}, 15], Equal: ["===", 8], NotEqual: ["!==", 8], LessEqual: ["<=", 9], GreaterEqual: [">=", 9], Less: ["<", 9], Greater: [">", 9], And: ["&&", 4], Or: ["||", 3], Not: ["!", 14] };
var Vo = { Abs: (e12, n) => `|${n(e12.op1)}|`, Sin: "sin", Cos: "cos", Tan: "tan", Sec: "sec", Csc: "csc", Arcsin: "arcsin", Arccos: "arccos", Arctan: "arctan", Sinh: "sinh", Cosh: "cosh", Tanh: "tanh", Sech: "sech", Csch: "csch", Coth: "coth", Ceil: "ceil", Exp: "exp", Factorial: (e12, n) => `${n(e12.op1, 12)}!`, Floor: "floor", Log: "log", Ln: "ln", Log10: "log10", Sqrt: "sqrt", Root: (e12, n) => {
  let i = e12.op1, t = e12.op2;
  return t.is(2) ? `sqrt${gi(n(i))}` : `root${gi(n(t))}${gi(n(i))}`;
}, Square: (e12, n) => `${n(e12.op1, 12)}^2`, Det: "det", Dim: "dim", Mod: "mod", GCD: "gcd", LCM: "lcm", Lub: "lub", Glb: "glb", Max: "max", Min: "min", Sum: (e12, n) => qo(e12, "sum", n), Product: (e12, n) => qo(e12, "prod", n), Integrate: (e12, n) => qo(e12, "int", n), Delimiter: (e12, n) => {
  var _a2;
  return Ud(e12.ops[0], (_a2 = e12.ops[1]) == null ? void 0 : _a2.string, n);
}, Sequence: (e12, n) => e12.nops === 0 ? "" : e12.ops.map((i) => n(i)).join(" "), List: (e12, n) => {
  var _a2, _b;
  return `[${(_b = (_a2 = e12.ops) == null ? void 0 : _a2.map((i) => n(i))) != null ? _b : ""}]`;
}, Single: (e12, n) => `(${e12.ops.map((i) => n(i)).join(", ")})`, Pair: (e12, n) => `(${e12.ops.map((i) => n(i)).join(", ")})`, Triple: (e12, n) => `(${e12.ops.map((i) => n(i)).join(", ")})`, Tuple: (e12, n) => `(${e12.ops.map((i) => n(i)).join(", ")})`, Function: (e12, n) => `(${e12.ops.slice(1).map((i) => n(i)).join(", ")}) |-> {${n(e12.op1)}}`, Domain: (e12) => JSON.stringify(e12.json), Error: (e12, n) => e12.nops === 1 ? `Error(${n(e12.op1)})` : e12.nops === 2 ? e12.op1.string ? `Error("${e12.op1.string}", ${n(e12.op2)})` : `Error(${n(e12.op1)}, ${n(e12.op2)})` : `Error(${e12.ops.map((i) => n(i)).join(", ")})`, LatexString: (e12) => {
  var _a2;
  return `"${(_a2 = e12.op1.string) != null ? _a2 : ""}"`;
} };
function qo(e12, n, i) {
  let t = e12.op2, r = t == null ? void 0 : t.op1, s = t == null ? void 0 : t.op2, o = t == null ? void 0 : t.op3;
  r.symbol === "Nothing" && (r = null), s.symbol === "Nothing" && (s = null), o.symbol === "Nothing" && (o = null);
  let a = n;
  return r && s && (a += `_(${i(r)}=${i(s)})`), o && (a += `^${gi(i(o))}`), a + gi(i(e12.op1));
}
function Ud(e12, n, i) {
  n || (n = "(,)");
  let t = "", r = "", s = "";
  if (n.length === 1 && (t = n), n.length === 2 && (r = n[0], s = n[1]), n.length === 3 && (r = n[0], t = n[1], s = n[2]), !e12) return `${r}${s}`;
  let o = [e12];
  return e12.operator === "Sequence" && (o = e12.ops), `${r}${o.map((a) => i(a)).join(t)}${s}`;
}
function gi(e12, n = 0, i = -1) {
  return n > i && !/^\(.+\)$/.test(e12) ? `(${e12})` : e12;
}
function es(e12, n = {}) {
  var _a2;
  return ((_a2 = n.symbols) == null ? void 0 : _a2[e12]) ? n.symbols[e12] : sf[e12] ? sf[e12] : e12.length === 1 ? e12 : `"${e12}"`;
}
function ns(e12, n = {}, i = 0) {
  var _a2, _b, _c2, _d2, _e2, _f2, _g;
  if (e12.symbol) return es(e12.symbol, n);
  let t = (s, o = 0) => ns(s, n, o);
  if (e12.string) return e12.string;
  let r = e12.numericValue;
  if (r !== null) return e12.isNaN ? es("NaN", n) : e12.isFinite === false ? e12.isNegative !== true && e12.isPositive !== true ? es("ComplexInfinity", n) : es(e12.isNegative ? "NegativeInfinity" : "PositiveInfinity", n) : r.toString();
  if (e12.operator) {
    let s = n.operators ? { ...of, ...n.operators } : of, [o, a] = (_a2 = s[e12.operator]) != null ? _a2 : [];
    if (o) {
      let f = "";
      if (typeof o == "function") f = o(e12, t);
      else {
        if (e12.nops === 1) return `${o}${t(e12.op1, a + 1)}`;
        f = (_c2 = (_b = e12.ops) == null ? void 0 : _b.map((c) => t(c, a + 1)).join(` ${o} `)) != null ? _c2 : "";
      }
      return gi(f, i, a);
    }
    let l = (n.functions ? { ...Vo, ...n.functions } : Vo)[e12.operator];
    return typeof l == "function" ? l(e12, t) : typeof l == "string" ? `${l}(${(_e2 = (_d2 = e12.ops) == null ? void 0 : _d2.map((f) => t(f)).join(", ")) != null ? _e2 : ""})` : `${e12.operator}(${(_g = (_f2 = e12.ops) == null ? void 0 : _f2.map((f) => t(f)).join(", ")) != null ? _g : ""})`;
  }
  return JSON.stringify(e12.json);
}
function $o(e12, n) {
  return e12 ? n ? (n.startsWith("-") && (n = `(${n})`), e12 === "-1" ? `-${n}` : n === "-1" ? `-${e12}` : e12.match(/^[-+]?\d+$/) && n.match(/^[a-zA-Z\(]/) ? e12 + n : `${e12} * ${n}`) : e12 : n;
}
function af(e12, n) {
  return e12 ? n ? e12 === "0" ? n : n === "0" ? e12 : n.startsWith("-") ? `${e12} - ${n.substring(1)}` : `${e12} + ${n}` : e12 : n;
}
var X = class {
  get head() {
    return this.operator;
  }
  constructor(n, i) {
    this.engine = n, (i == null ? void 0 : i.latex) !== void 0 && (this.verbatimLatex = i.latex);
  }
  isSame(n) {
    return Ji(this, n);
  }
  isEqual(n) {
    return qr(this, n);
  }
  isLess(n) {
    let i = Yi(this, n);
    if (i !== void 0) return i === "<";
  }
  isLessEqual(n) {
    let i = Yi(this, n);
    if (i !== void 0) return i === "<=" || i === "<" || i === "=";
  }
  isGreater(n) {
    let i = Yi(this, n);
    if (i !== void 0) return i === ">";
  }
  isGreaterEqual(n) {
    let i = Yi(this, n);
    if (i !== void 0) return i === ">=" || i === ">" || i === "=";
  }
  valueOf() {
    return this.symbol === "True" ? true : this.symbol === "False" ? false : this.symbol === "NaN" ? NaN : this.symbol === "PositiveInfinity" ? 1 / 0 : this.symbol === "NegativeInfinity" ? -1 / 0 : this.isInfinity ? this.isPositive ? 1 / 0 : this.isNegative ? -1 / 0 : NaN : typeof this.string == "string" ? this.string : typeof this.symbol == "string" ? this.symbol : this.im === 0 ? this.re : this.toString();
  }
  toAsciiMath(n = {}) {
    return ns(this, n);
  }
  toString() {
    return ns(this);
  }
  print() {
    let n = console.info;
    n == null ? void 0 : n(this.toString());
  }
  [Symbol.toPrimitive](n) {
    if (n === "number") {
      let i = this.valueOf();
      return typeof i == "number" ? i : null;
    }
    return this.toString();
  }
  toJSON() {
    return this.json;
  }
  toMathJson(n) {
    var _a2, _b;
    let i = { exclude: [], shorthands: ["function", "symbol", "string", "number"], metadata: [], fractionalDigits: "max", repeatingDecimal: true, prettify: true };
    n && ((typeof n.shorthands == "string" && n.shorthands === "all" || ((_a2 = n.shorthands) == null ? void 0 : _a2.includes("all"))) && (i.shorthands = ["function", "symbol", "string", "number"]), Array.isArray(n.shorthands) && (i.shorthands = n.shorthands), (typeof n.metadata == "string" && n.metadata === "all" || ((_b = n.metadata) == null ? void 0 : _b.includes("all"))) && (i.metadata = ["latex", "wikidata"]), n.fractionalDigits === "auto" && (i.fractionalDigits = -this.engine.precision), typeof n.fractionalDigits == "number" && (i.fractionalDigits = n.fractionalDigits));
    let t = { ...i, ...n, fractionalDigits: i.fractionalDigits, shorthands: i.shorthands, metadata: i.metadata };
    return wo(this.engine, this, t);
  }
  toLatex(n) {
    var _a2;
    let i = this.toMathJson(), t = { imaginaryUnit: "\\imaginaryI", positiveInfinity: "\\infty", negativeInfinity: "-\\infty", notANumber: "\\operatorname{NaN}", decimalSeparator: this.engine.decimalSeparator, digitGroupSeparator: "\\,", exponentProduct: "\\cdot", beginExponentMarker: "10^{", endExponentMarker: "}", digitGroup: 3, truncationMarker: "\\ldots", repeatingDecimal: "vinculum", fractionalDigits: "max", notation: "auto", avoidExponentsInRange: [-7, 20], prettify: true, invisibleMultiply: "", invisiblePlus: "", multiply: "\\times", missingSymbol: "\\blacksquare", applyFunctionStyle: Su, groupStyle: _u, rootStyle: Iu, fractionStyle: Bu, logicStyle: ku, powerStyle: wu, numericSetStyle: Du };
    return (n == null ? void 0 : n.fractionalDigits) === "auto" ? t.fractionalDigits = -this.engine.precision : t.fractionalDigits = (_a2 = n == null ? void 0 : n.fractionalDigits) != null ? _a2 : "max", typeof t.fractionalDigits == "number" && t.fractionalDigits > this.engine.precision && (t.fractionalDigits = this.engine.precision), t = { ...t, ...n != null ? n : {}, fractionalDigits: t.fractionalDigits }, !t.prettify && this.verbatimLatex ? this.verbatimLatex : rf(i, this.engine.indexedLatexDictionary, t);
  }
  toNumericValue() {
    return [this.engine._numericValue(1), this];
  }
  get scope() {
    return null;
  }
  is(n) {
    return typeof n == "number" || typeof n == "bigint" ? false : typeof n == "boolean" ? this.symbol === "True" && n === true || this.symbol === "False" && n === false : n == null ? false : Ji(this, this.engine.box(n));
  }
  get canonical() {
    return this;
  }
  get structural() {
    return this;
  }
  get isStructural() {
    return true;
  }
  get latex() {
    return this.toLatex();
  }
  set latex(n) {
    this.verbatimLatex = n;
  }
  get symbol() {
    return null;
  }
  get tensor() {
    return null;
  }
  get string() {
    return null;
  }
  getSubexpressions(n) {
    return cf(this, n);
  }
  get subexpressions() {
    return this.getSubexpressions("");
  }
  get symbols() {
    let n = /* @__PURE__ */ new Set();
    return lf(this, n), Array.from(n).sort();
  }
  get unknowns() {
    let n = /* @__PURE__ */ new Set();
    return ff(this, n), Array.from(n).sort();
  }
  get freeVariables() {
    let n = /* @__PURE__ */ new Set();
    return uf(this, n), Array.from(n).sort();
  }
  get errors() {
    return this.getSubexpressions("Error");
  }
  get ops() {
    return null;
  }
  get nops() {
    return 0;
  }
  get op1() {
    return this.engine.Nothing;
  }
  get op2() {
    return this.engine.Nothing;
  }
  get op3() {
    return this.engine.Nothing;
  }
  get isValid() {
    return true;
  }
  get isPure() {
    return false;
  }
  get isConstant() {
    return true;
  }
  get isNaN() {
  }
  get isInfinity() {
  }
  get isFinite() {
  }
  get isEven() {
  }
  get isOdd() {
  }
  get numericValue() {
    return null;
  }
  get isNumberLiteral() {
    return false;
  }
  get isFunctionExpression() {
    return false;
  }
  get re() {
    return NaN;
  }
  get im() {
    return NaN;
  }
  get bignumRe() {
  }
  get bignumIm() {
  }
  get numerator() {
    return this;
  }
  get denominator() {
    return this.engine.One;
  }
  get numeratorDenominator() {
    return [this, this.engine.One];
  }
  neg() {
    return this.engine.NaN;
  }
  inv() {
    return this.engine.NaN;
  }
  abs() {
    return this.engine.NaN;
  }
  add(n) {
    return this.engine.NaN;
  }
  sub(n) {
    return this.add(n.neg());
  }
  mul(n) {
    return this.engine.NaN;
  }
  div(n) {
    return this.engine.NaN;
  }
  pow(n) {
    return this.engine.NaN;
  }
  root(n) {
    return this.engine.NaN;
  }
  sqrt() {
    return this.engine.NaN;
  }
  ln(n) {
    return this.engine.NaN;
  }
  get sgn() {
  }
  get shape() {
    return [];
  }
  get rank() {
    return 0;
  }
  subs(n, i) {
    return (i == null ? void 0 : i.canonical) === true ? this.canonical : this;
  }
  map(n, i) {
    var _a2, _b;
    if (!this.ops) return n(this);
    let t = (_a2 = i == null ? void 0 : i.canonical) != null ? _a2 : this.isCanonical, r = (_b = i == null ? void 0 : i.recursive) != null ? _b : true, s = this.ops.map((o) => r ? o.map(n, i) : n(o));
    return n(this.engine.function(this.operator, s, { canonical: t }));
  }
  solve(n) {
    return null;
  }
  replace(n) {
    return null;
  }
  has(n) {
    return false;
  }
  get isPositive() {
  }
  get isNonNegative() {
  }
  get isNegative() {
  }
  get isNonPositive() {
  }
  get description() {
    if (this.baseDefinition && this.baseDefinition.description) return typeof this.baseDefinition.description == "string" ? [this.baseDefinition.description] : this.baseDefinition.description;
  }
  get url() {
    var _a2, _b;
    return (_b = (_a2 = this.baseDefinition) == null ? void 0 : _a2.url) != null ? _b : void 0;
  }
  get wikidata() {
    var _a2, _b;
    return (_b = (_a2 = this.baseDefinition) == null ? void 0 : _a2.wikidata) != null ? _b : void 0;
  }
  get complexity() {
  }
  get baseDefinition() {
  }
  get symbolDefinition() {
  }
  get functionDefinition() {
  }
  infer(n) {
    return false;
  }
  bind() {
  }
  reset() {
  }
  get value() {
    return this.N().valueOf();
  }
  set value(n) {
    throw new Error(`Can't change the value of \\(${this.latex}\\)`);
  }
  get type() {
    return C.unknown;
  }
  set type(n) {
    throw new Error(`Can't change the type of \\(${this.latex}\\)`);
  }
  get isNumber() {
  }
  get isInteger() {
  }
  get isRational() {
  }
  get isReal() {
  }
  simplify(n) {
    return this;
  }
  expand() {
    var _a2;
    return (_a2 = Pe(this)) != null ? _a2 : this;
  }
  evaluate(n) {
    return this.simplify();
  }
  evaluateAsync(n) {
    return Promise.resolve(this.evaluate());
  }
  N() {
    return this.evaluate({ numericApproximation: true });
  }
  compile(n) {
    if ((n == null ? void 0 : n.to) && n.to !== "javascript") throw new Error("Unknown target");
    return n != null ? n : n = {}, Jl(this, n == null ? void 0 : n.functions, n == null ? void 0 : n.vars, n == null ? void 0 : n.imports, n == null ? void 0 : n.preamble);
  }
  get isCollection() {
    return false;
  }
  contains(n) {
    return false;
  }
  subsetOf(n, i) {
    return false;
  }
  get size() {
    return 0;
  }
  each(n, i) {
    return { next() {
      return { done: true, value: void 0 };
    } };
  }
  at(n) {
  }
  get(n) {
  }
  indexOf(n) {
    return -1;
  }
};
function uf(e12, n) {
  if (e12.operator, e12.symbol) {
    let i = e12.engine.lookupSymbol(e12.symbol);
    if (i && i.value !== void 0) return;
    let t = e12.engine.lookupFunction(e12.symbol);
    if (t && t.evaluate) return;
    n.add(e12.symbol);
    return;
  }
  if (e12.ops) for (let i of e12.ops) uf(i, n);
}
function lf(e12, n) {
  if (e12.symbol) {
    n.add(e12.symbol);
    return;
  }
  if (e12.ops) for (let i of e12.ops) lf(i, n);
}
function ff(e12, n) {
  if (e12.symbol) {
    let i = e12.symbol;
    if (i === "Unknown" || i === "Undefined" || i === "Nothing") return;
    let t = e12.engine.lookupSymbol(i);
    if (t && t.value !== void 0) return;
    let r = e12.engine.lookupFunction(i);
    if (r && r.evaluate) return;
    n.add(i);
    return;
  }
  if (e12.ops) for (let i of e12.ops) ff(i, n);
}
function cf(e12, n) {
  let i = !n || e12.operator === n ? [e12] : [];
  if (e12.ops) for (let t of e12.ops) i.push(...cf(t, n));
  return i;
}
function zo(e12) {
  let n = [], i = (t, r = []) => {
    if (t.length === 0) n.push(r);
    else for (let s = 0; s < t.length; s++) {
      let o = t.slice(), a = o.splice(s, 1);
      i(o.slice(), r.concat(a));
    }
  };
  return i(e12), n;
}
function pf(e12) {
  for (let n in e12) n.startsWith("_") && e12.hasOwnProperty(n) && Object.defineProperty(e12, n, { enumerable: false, configurable: true, writable: true, value: e12[n] });
}
function is(e12, n) {
  if (!e12.ops) return [];
  let i = e12.ops, t = e12.functionDefinition;
  if (!t || i.length === 0) return i;
  let r = (t == null ? void 0 : t.associative) ? t.name : "";
  if (i = Gn(i, r), t.lazy) return i;
  let s = [];
  for (let o of i) {
    let a = o.operator;
    if (a === "Hold") s.push(o);
    else {
      let u = a === "ReleaseHold" ? o.op1 : o;
      if (u) {
        let l = n(u);
        l !== null && s.push(l);
      }
    }
  }
  return Gn(s, r);
}
async function df(e12, n) {
  if (!e12.ops) return [];
  let i = e12.ops, t = e12.functionDefinition;
  if (!t || i.length === 0) return i;
  let r = (t == null ? void 0 : t.associative) ? t.name : "";
  if (i = Gn(i, r), t.lazy) return i;
  let s = [];
  for (let o of i) {
    let a = o.operator;
    if (a === "Hold") s.push(o);
    else {
      let u = a === "ReleaseHold" ? o.op1 : o;
      if (u) {
        let l = await n(u);
        l !== null && s.push(l);
      }
    }
  }
  return Gn(s, r);
}
function Jn(e12, n, i) {
  if (((o) => i && i.some((a) => a.value.isSame(o)))(e12) || (i || (i = [{ value: e12, because: "initial" }]), !e12.isValid)) return i;
  if (!(e12.isCanonical || e12.isStructural)) {
    let o = e12.canonical;
    return o.isCanonical || o.isStructural ? Jn(o, n, i) : i;
  }
  let r = e12.engine, s = (n == null ? void 0 : n.rules) ? r.rules(n.rules, { canonical: true }) : r.getRuleSet("standard-simplification");
  n = { ...n, rules: s };
  do {
    let o = Zd(e12, s, n, i);
    if (o.length <= i.length) break;
    e12 = o.at(-1).value, i = o;
  } while (!i.slice(0, -1).some((o) => o.value.isSame(e12)));
  return i;
}
function jd(e12, n, i) {
  if (n == null || e12 === n || e12.isSame(n)) return false;
  let t = e12.engine;
  return i != null ? i : i = (r) => t.costFunction(r), i(n) <= 1.2 * i(e12);
}
function mf(e12, n) {
  return e12.ops ? e12.engine.function(e12.operator, is(e12, (i) => Jn(i, n).at(-1).value)) : e12;
}
function Zd(e12, n, i, t) {
  if (e12.isNumberLiteral || e12.string) return t;
  if (e12.symbol) {
    let o = Mn(e12, n, { recursive: false, canonical: true, useVariations: false });
    return o.length > 0 ? [...t, ...o] : t;
  }
  let r = mf(e12, i);
  r.isSame(e12) || (t = [...t, { value: r, because: "simplified operands" }], e12 = r);
  let s = Hd(e12, n, i, t);
  return s.length > t.length ? s : t;
}
function Hd(e12, n, i, t) {
  var _a2;
  let r = Mn(e12, n, { recursive: false, canonical: true, useVariations: (_a2 = i.useVariations) != null ? _a2 : false });
  if (r.length === 0) return t;
  let s = r.at(-1).value;
  return s.isSame(e12) || (s = mf(s), !jd(e12, s, i == null ? void 0 : i.costFunction)) ? t : (r.at(-1).value = s, [...t, ...r]);
}
function xi(e12) {
  var _a2, _b;
  return (_b = (_a2 = e12.symbol) == null ? void 0 : _a2.startsWith("_")) != null ? _b : e12.operator === "Wildcard" || e12.operator === "WildcardSequence" || e12.operator === "WildcardOptionalSequence";
}
function yi(e12) {
  var _a2;
  if ((_a2 = e12.symbol) == null ? void 0 : _a2.startsWith("_")) return e12.symbol;
  if (e12.nops === 1) {
    let n = e12.op1;
    if (e12.operator === "Wildcard") return `_${n}`;
    if (e12.operator === "WildcardSequence") return `__${n}`;
    if (e12.operator === "WildcardOptionalSequence") return `___${n}`;
  }
  return e12.operator === "Wildcard" ? "_" : e12.operator === "WildcardSequence" ? "__" : e12.operator === "WildcardOptionalSequence" ? "___" : null;
}
function Uo(e12) {
  return typeof e12 == "string" ? e12.startsWith("_") : xi(e12) ? true : e12.ops ? Uo(e12.operator) || e12.ops.some(Uo) : false;
}
function ts(e12, n, i) {
  return e12.startsWith("_"), e12 === "_" || e12 === "__" || e12 === "___" ? i : e12 in i ? n.isSame(i[e12]) ? i : null : Uo(n) ? null : { ...i, [e12]: n };
}
function bi(e12, n, i, t) {
  var _a2, _b, _c2, _d2;
  if (xi(n)) return ts(yi(n), e12, i);
  let r = (_a2 = t.acceptVariants) != null ? _a2 : true;
  if (t = { ...t, acceptVariants: true }, n.numericValue !== null) return e12.numericValue === null ? null : n.isEqual(e12) ? i : r ? Go(e12, n, i, t) : null;
  let s = n.string;
  if (s !== null) return e12.string === s ? i : null;
  let o = n.symbol;
  if (o !== null) return o === e12.symbol ? i : r ? Go(e12, n, i, t) : null;
  if (n.ops) {
    let a = (_b = t.useVariations) != null ? _b : false, u = e12.engine, l = null, f = n.operator;
    if (f.startsWith("_") ? (l = ts(f, u.box(e12.operator), i), l !== null && (l = jo(e12, n.ops, l, t))) : f === e12.operator && (l = ((_c2 = u.lookupFunction(f)) == null ? void 0 : _c2.commutative) ? Jd(e12, n, i, t) : jo(e12, n.ops, i, t)), l === null && a) {
      if (!r) return null;
      l = Go(e12, n, i, t);
    }
    return l !== null && (i = l), t.recursive && e12.ops && (l = (_d2 = Wd(e12, n, i, { ...t, acceptVariants: r })) != null ? _d2 : l), l;
  }
  return null;
}
function Wd(e12, n, i, t) {
  e12.ops;
  let r = null;
  for (let s of e12.ops) {
    let o = bi(s, n, i, t);
    o !== null && (r = o, i = o);
  }
  return r;
}
function Go(e12, n, i, t) {
  if (!t.useVariations) return null;
  let r = e12.engine, s = { ...t, acceptVariants: false }, o = (u, l) => bi(r.function(u, l, { canonical: false }), n, i, s), a = n.operator;
  if (a === "Negate" && e12.is(0)) return bi(r.Zero, n.op1, i, s);
  if (a === "Add") {
    let u = o("Add", [0, e12]);
    if (u !== null || (e12.operator === "Subtract" && (u = o("Add", [e12.op1, ["Negate", e12.op2]])), u !== null)) return u;
  }
  if (a === "Subtract") {
    let u = o("Subtract", [e12, 0]);
    if (u !== null || (e12.operator === "Negate" && (u = o("Subtract", [0, e12.op1])), u !== null)) return u;
  }
  if (a === "Multiply") {
    let u = o("Multiply", [1, e12]);
    if (u !== null || e12.operator === "Negate" && (u = o("Multiply", [-1, e12.op1]), u !== null) || e12.operator === "Divide" && (u = o("Multiply", [e12.op1, ["Divide", 1, e12.op2]]), u !== null)) return u;
  }
  if (a === "Divide") {
    let u = o("Divide", [e12, 1]);
    if (u !== null) return u;
  }
  if (a === "Square") {
    let u = o("Power", [e12, 2]);
    if (u !== null) return u;
  }
  if (a === "Exp") {
    let u = o("Power", [r.E, e12]);
    if (u !== null) return u;
  }
  if (a === "Power") {
    if (n.op2.re === 2 && n.op2.im === 0) {
      let u = o("Square", [e12]);
      if (u !== null) return u;
    }
    if (n.op1.symbol === "ExponentialE") {
      let u = o("Exp", [e12]);
      if (u !== null) return u;
    }
    {
      let u = o("Power", [e12, 1]);
      if (u !== null) return u;
    }
  }
  return null;
}
function Jd(e12, n, i, t) {
  e12.operator, n.operator;
  let r = zo(n.ops);
  for (let s of r) {
    let o = jo(e12, s, i, t);
    if (o !== null) return o;
  }
  return null;
}
function jo(e12, n, i, t) {
  if (n.length === 0) return e12.ops && e12.ops.length === 0 ? i : null;
  let r = n[0].engine, s = { ...i }, o = [...e12.ops], a = 0;
  for (; a < n.length; ) {
    let u = n[a], l = yi(u);
    if (l !== null) if (l.startsWith("__")) {
      let f = 0;
      if (n[a + 1] === void 0) f = o.length + 1;
      else {
        let p = false;
        for (; !p && f < o.length; ) p = bi(o[f], n[a + 1], s, t) !== null, f += 1;
        if (!p && l.startsWith("___")) return null;
      }
      if (!l.startsWith("___") && f <= 1) return null;
      let c;
      if (f <= 1) e12.operator === "Add" ? c = r.Zero : e12.operator === "Multiply" ? c = r.One : c = r.Nothing;
      else if (f === 2) {
        if (o.length === 0) return null;
        c = o.shift();
      } else {
        let p = r.lookupFunction(e12.operator), m = o.splice(0, f - 1);
        (p == null ? void 0 : p.associative) ? c = r.function(e12.operator, m, { canonical: false }) : c = r.function("Sequence", m, { canonical: false });
      }
      s = ts(l, c, s);
    } else if (l.startsWith("_")) {
      if (o.length === 0) return null;
      s = ts(l, o.shift(), s);
    } else s = bi(o.shift(), u, s, t);
    else {
      let f = o.shift();
      if (!f) return null;
      s = bi(f, u, s, t);
    }
    if (s === null) return null;
    a += 1;
  }
  return o.length > 0 ? null : s;
}
function st(e12, n, i) {
  var _a2, _b, _c2;
  n = n.structural;
  let t = (_a2 = i == null ? void 0 : i.useVariations) != null ? _a2 : false, r = { recursive: (_b = i == null ? void 0 : i.recursive) != null ? _b : false, useVariations: t, acceptVariants: t }, s = (_c2 = i == null ? void 0 : i.substitution) != null ? _c2 : {};
  return bi(e12.structural, n.structural, s, r);
}
function Wt(e12) {
  let n = e12.engine, i = e12.operator;
  if (we(i)) return n.function(i, e12.ops.map(Wt));
  if (i === "Divide") return e12.ops[0].div(e12.ops[1]);
  if (i === "Negate") return Wt(e12.ops[0]).neg();
  if (i === "Add") {
    let [t, r] = e12.ops.reduce((s, o) => (o.operator === "Divide" ? (s[0].push(o.ops[0]), s[1].push(o.ops[1])) : s[0].push(o), s), [[], []]);
    return H(...t).div(H(...r));
  }
  return e12;
}
function Yn(e12) {
  let n = e12.operator;
  if (we(n)) {
    let i = Be.from(e12.op1), t = Be.from(e12.op2), [r, s] = yu(i, t), o = r.sgn() === -1;
    return r.isOne || (i.div(r), t.div(r)), s.is(1) || (s.isPositive ? (i.div(s), t.div(s)) : s.isNegative && (i.div(s.neg()), t.div(s.neg()), o = !o)), o && ([i, t] = [t, i]), e12.engine.function(n, [i.asExpression(), t.asExpression()]);
  }
  if (n === "Negate") return Yn(e12.ops[0]).neg();
  if (n === "Add") {
    let i = e12.engine, t, r = [];
    for (let o of e12.ops) {
      let [a, u] = o.toNumericValue();
      t = t ? t.gcd(a) : a, a.isZero || r.push({ coeff: a, term: u });
    }
    if (!t || t.isOne) return e12;
    let s = r.map(({ coeff: o, term: a }) => ae(a, i.box(o.div(t))));
    return ae(i.number(t), H(...s));
  }
  return Be.from(Wt(e12)).asExpression();
}
function hf(e12) {
  var _a2;
  let n = e12.engine;
  if (e12.operator === "Hold") return;
  let i;
  if (e12.ops) {
    let t = e12.functionDefinition;
    if (t == null ? void 0 : t.sgn) {
      let r = n.swapScope(e12.scope);
      i = t.sgn(e12.ops, { engine: n }), n.swapScope(r);
    }
    return i;
  }
  return e12.symbol ? (_a2 = e12.symbolDefinition) == null ? void 0 : _a2.sgn : e12.isNumberLiteral ? e12.sgn : "unsigned";
}
function ot(e12) {
  if (e12 !== void 0) {
    if (e12 === "positive") return true;
    if (["non-positive", "zero", "unsigned", "negative", "negative-infinity"].includes(e12)) return false;
  }
}
function at(e12) {
  if (e12 !== void 0) {
    if (e12 === "positive" || e12 === "positive-infinity" || e12 === "non-negative") return true;
    if (["negative", "negative-infinity", "zero", "unsigned"].includes(e12)) return false;
  }
}
function ut(e12) {
  if (e12 !== void 0) {
    if (e12 === "negative" || e12 === "negative-infinity") return true;
    if (["non-negative", "zero", "unsigned", "positive", "positive-infinity"].includes(e12)) return false;
  }
}
function lt(e12) {
  if (e12 !== void 0) {
    if (e12 === "negative" || e12 === "negative-infinity" || e12 === "non-positive") return true;
    if (["positive", "zero", "unsigned"].includes(e12)) return false;
  }
}
function rs(e12, n, i) {
  return e12.generation === void 0 || e12.generation === n ? (e12.value === null && (e12.value = i()), e12.value) : (e12.generation = n, e12.value = i(), e12.value);
}
async function gf(e12, n, i) {
  return e12.generation === void 0 || e12.generation === n ? (e12.value === null && (e12.value = await i()), e12.value) : (e12.generation = n, e12.value = await i(), e12.value);
}
var Ge = class extends X {
  constructor(i, t, r, s) {
    var _a2;
    super(i, s == null ? void 0 : s.metadata);
    this._value = { value: null, generation: -1 };
    this._valueN = { value: null, generation: -1 };
    this._sgn = { value: null, generation: -1 };
    this._type = { value: null, generation: -1 };
    this._name = t, this._ops = r, this._isStructural = (_a2 = s == null ? void 0 : s.structural) != null ? _a2 : false, (s == null ? void 0 : s.canonical) && (this._canonical = this), ((s == null ? void 0 : s.canonical) || this._isStructural) && this.bind(), i._register(this);
  }
  get hash() {
    if (this._hash !== void 0) return this._hash;
    let i = 0;
    for (let t of this._ops) i = i << 1 ^ t.hash | 0;
    return i = i ^ pn(this._name) | 0, this._hash = i, i;
  }
  infer(i) {
    let t = this.functionDefinition;
    return !t || !t.inferredSignature ? false : (t.signature.is("function") ? t.signature = new C({ kind: "signature", result: i }) : Xn(t.signature.type) && (t.signature = new C({ kind: "signature", result: wa(t.signature.type.result, i) })), this.engine.generation += 1, true);
  }
  bind() {
    this._def = void 0, this._scope = this.engine.context, this._def = this.engine.lookupFunction(this._name);
    for (let i of this._ops) i.bind();
  }
  reset() {
  }
  get isCanonical() {
    return this._canonical === this;
  }
  set isCanonical(i) {
    this._canonical = i ? this : void 0;
  }
  get isPure() {
    var _a2, _b;
    if (this._isPure !== void 0) return this._isPure;
    if (!this.isCanonical) return this._isPure = false, false;
    let i = (_b = (_a2 = this.functionDefinition) == null ? void 0 : _a2.pure) != null ? _b : false;
    return i && (i = this._ops.every((t) => t.isPure)), this._isPure = i, i;
  }
  get isConstant() {
    return this.isPure ? this._ops.every((i) => i.isConstant) : false;
  }
  get json() {
    return [this._name, ...this.structural.ops.map((i) => i.json)];
  }
  get scope() {
    return this._scope;
  }
  get operator() {
    return this._name;
  }
  get ops() {
    return this._ops;
  }
  get nops() {
    return this._ops.length;
  }
  get op1() {
    var _a2;
    return (_a2 = this._ops[0]) != null ? _a2 : this.engine.Nothing;
  }
  get op2() {
    var _a2;
    return (_a2 = this._ops[1]) != null ? _a2 : this.engine.Nothing;
  }
  get op3() {
    var _a2;
    return (_a2 = this._ops[2]) != null ? _a2 : this.engine.Nothing;
  }
  get isValid() {
    return this._name === "Error" ? false : this._ops.every((i) => i == null ? void 0 : i.isValid);
  }
  get canonical() {
    var _a2;
    return (_a2 = this._canonical) != null ? _a2 : this._canonical = this.isValid ? this.engine.function(this._name, this._ops) : this, this._canonical;
  }
  get structural() {
    if (this.isStructural) return this;
    let i = this.functionDefinition;
    if ((i == null ? void 0 : i.associative) || (i == null ? void 0 : i.commutative)) {
      let t = this.ops.map((s) => s.structural), r = [];
      if (!i.associative) r = t;
      else for (let s of t) s.operator === this.operator ? r.push(...s.ops) : r.push(s);
      return this.engine.function(this._name, this.isValid ? Rt(this._name, r) : r, { canonical: false, structural: true });
    }
    return this.engine.function(this._name, this.ops.map((t) => t.structural), { canonical: false, structural: true });
  }
  get isStructural() {
    return this._isStructural;
  }
  toNumericValue() {
    this.isCanonical || this.isStructural;
    let i = this.engine;
    if (this.operator === "Complex") return [i._numericValue({ re: this.op1.re, im: this.op2.re }), i.One];
    let t = this;
    if (t.operator === "Add" && (t = Yn(this), t.numericValue !== null)) {
      if (typeof t.numericValue == "number") {
        if (Number.isInteger(t.numericValue)) return [i._numericValue(t.numericValue), i.One];
      } else if (t.numericValue.isExact) return [t.numericValue, i.One];
    }
    if (t.operator === "Negate") {
      let [r, s] = t.op1.toNumericValue();
      return [r.neg(), s];
    }
    if (t.operator === "Multiply") {
      let r = [], s = i._numericValue(1);
      for (let o of t.ops) {
        let [a, u] = o.toNumericValue();
        s = s.mul(a), u.is(1) || r.push(u);
      }
      return r.length === 0 ? [s, i.One] : r.length === 1 ? [s, r[0]] : [s, pe(this.engine, r)];
    }
    if (t.operator === "Divide") {
      let [r, s] = t.op1.toNumericValue(), [o, a] = t.op2.toNumericValue(), u = r.div(o);
      return a.is(1) ? [u, s] : [u, i.function("Divide", [s, a])];
    }
    if (t.operator === "Power") {
      if (t.op2.numericValue === null) return [i._numericValue(1), this];
      let [r, s] = t.op1.toNumericValue();
      if (r.isOne) return [r, this];
      let o = G(t.op2);
      return o !== null ? [r.pow(o), i.function("Power", [s, t.op2])] : t.op2.is(0.5) ? [r.sqrt(), i.function("Sqrt", [s])] : [i._numericValue(1), this];
    }
    if (t.operator === "Sqrt") {
      let [r, s] = t.op1.toNumericValue();
      return s.is(1) || s.is(0) ? r.isOne || r.isZero ? [r, s] : [r.sqrt(), s] : [r.sqrt(), i.function("Sqrt", [s])];
    }
    if (t.operator === "Root") {
      let r = t.op2.re;
      if (isNaN(r) || t.op2.im !== 0) return [i._numericValue(1), this];
      let [s, o] = t.op1.toNumericValue();
      return r === 2 ? [s.sqrt(), i.function("Sqrt", [o])] : [s.root(r), i.function("Root", [o, t.op2])];
    }
    if (t.operator === "Abs") {
      let [r, s] = t.op1.toNumericValue();
      return [r.abs(), i.function("Abs", [s])];
    }
    if (t.operator, t.operator, t.operator === "Log" || t.operator === "Ln") {
      let r = t.op2.re;
      isNaN(r) && t.operator === "Log" && (r = 10);
      let [s, o] = t.op1.toNumericValue();
      return s.isOne ? [s, this] : i.box(s.ln(r)).add(i.function(t.operator, [o, t.op2])).toNumericValue();
    }
    return [i._numericValue(1), t];
  }
  subs(i, t) {
    let r = this._ops.map((s) => s.subs(i, t));
    return r.every((s) => s.isValid) ? this.engine.function(this._name, r, t) : this.engine.function(this._name, r, { canonical: false });
  }
  replace(i, t) {
    var _a2, _b;
    return (_b = (_a2 = Mn(this, i, t).at(-1)) == null ? void 0 : _a2.value) != null ? _b : null;
  }
  match(i, t) {
    return st(this, i, t);
  }
  has(i) {
    if (typeof i == "string") {
      if (this._name === i) return true;
    } else if (i.includes(this._name)) return true;
    return this._ops.some((t) => t.has(i));
  }
  get sgn() {
    let i = this.isPure && this._ops.every((t) => t.isConstant) ? void 0 : this.engine.generation;
    return rs(this._sgn, i, () => {
      if (!(!this.isValid || this.isNumber !== true)) return hf(this);
    });
  }
  get isNaN() {
    return this.sgn === "nan";
  }
  get isInfinity() {
    let i = this.sgn;
    return i === "positive-infinity" || i === "negative-infinity" || i === "complex-infinity";
  }
  get isFinite() {
    if (this.isNumber !== true || this.isNaN || this.isInfinity) return false;
    if (!(this.isNaN === void 0 || this.isInfinity === void 0)) return true;
  }
  get isOne() {
    if (this.isNonPositive === true || this.isReal === false) return false;
  }
  get isNegativeOne() {
    if (this.isNonNegative === true || this.isReal === false) return false;
  }
  get isPositive() {
    return ot(this.sgn);
  }
  get isNonNegative() {
    return at(this.sgn);
  }
  get isNegative() {
    return ut(this.sgn);
  }
  get isNonPositive() {
    return lt(this.sgn);
  }
  get numerator() {
    return this.numeratorDenominator[0];
  }
  get denominator() {
    return this.numeratorDenominator[1];
  }
  get numeratorDenominator() {
    if (!this.isCanonical) return this.canonical.numeratorDenominator;
    if (this.isNumber !== true) return [this.engine.Nothing, this.engine.Nothing];
    let i = this.operator;
    if (i === "Divide") return [this.op1, this.op2];
    if (i === "Negate") {
      let [t, r] = this.op1.numeratorDenominator;
      return [t.neg(), r];
    }
    if (i === "Power") {
      let [t, r] = this.op1.numeratorDenominator;
      return [t.pow(this.op2), r.pow(this.op2)];
    }
    if (i === "Root") {
      let [t, r] = this.op1.numeratorDenominator;
      return [t.root(this.op2), r.root(this.op2)];
    }
    if (i === "Sqrt") {
      let [t, r] = this.op1.numeratorDenominator;
      return [t.sqrt(), r.sqrt()];
    }
    if (i === "Abs") {
      let [t, r] = this.op1.numeratorDenominator;
      return [t.abs(), r.abs()];
    }
    return i === "Multiply" ? new Be(this.engine, this.ops).asNumeratorDenominator() : [this, this.engine.One];
  }
  neg() {
    return pi(this.canonical);
  }
  inv() {
    if (!this.isCanonical) return this.canonical.inv();
    if (this.isOne) return this;
    if (this.isNegativeOne) return this;
    if (this.operator === "Sqrt") return this.op1.inv().sqrt();
    if (this.operator === "Divide") return this.op2.div(this.op1);
    if (this.operator === "Power") {
      let i = this.op2.neg();
      return i.operator !== "Negate" ? this.op1.pow(i) : this.engine.function("Power", [this.op1, i]);
    }
    if (this.operator === "Root") {
      let i = this.op2.neg();
      return i.operator !== "Negate" ? this.op1.root(i) : this.engine.function("Root", [this.op1, i]);
    }
    return this.operator === "Exp" ? this.engine.E.pow(this.op1.neg()) : this.operator === "Rational" ? this.op2.div(this.op1) : this.operator === "Negate" ? this.op1.inv().neg() : this.engine._fn("Divide", [this.engine.One, this.canonical]);
  }
  abs() {
    return this.isCanonical ? this.operator === "Abs" || this.operator === "Negate" ? this : this.isNonNegative ? this : this.isNonPositive ? this.neg() : this.engine._fn("Abs", [this]) : this.canonical.abs();
  }
  add(i) {
    return i === 0 ? this : H(this.canonical, this.engine.box(i));
  }
  mul(i) {
    if (i === 0) return this.engine.Zero;
    if (i === 1) return this;
    if (i === -1) return this.neg();
    if (i instanceof z) {
      if (i.isZero) return this.engine.Zero;
      if (i.isOne) return this.canonical;
      if (i.isNegativeOne) return this.neg();
    }
    return ae(this.canonical, this.engine.box(i));
  }
  div(i) {
    return Hi(this, i);
  }
  pow(i) {
    return me(this, i, { numericApproximation: false });
  }
  root(i) {
    if (!this.isCanonical) return this.canonical.root(i);
    typeof i != "number" && (i = i.canonical);
    let t = typeof i == "number" ? i : i.im === 0 ? i.re : void 0;
    if (t === 0) return this.engine.NaN;
    if (t === 1) return this;
    if (t === -1) return this.inv();
    if (t === 2) return this.engine.function("Sqrt", [this]);
    if (this.operator === "Power" && t !== void 0) {
      let [r, s] = this.ops;
      return r.pow(s.div(t));
    }
    if (this.operator === "Divide") {
      let [r, s] = this.ops;
      return r.root(i).div(s.root(i));
    }
    if (this.operator === "Negate" && t !== void 0) return t % 2 === 0 ? this.op1.root(i) : this.op1.root(i).neg();
    if (this.operator === "Sqrt") {
      if (t !== void 0) return this.op1.root(t + 2);
      if (typeof i != "number") return this.op1.root(i.add(2));
    }
    if (this.operator === "Multiply") {
      let r = this.ops.map((s) => s.root(i));
      return ae(...r);
    }
    if (this.operator === "Root") {
      let [r, s] = this.ops;
      return r.root(s.mul(i));
    }
    if (this.isNumberLiteral) {
      let r = this.numericValue;
      if (typeof r == "number") {
        if (r < 0) return this.engine.NaN;
        if (r === 0) return this.engine.Zero;
        if (r === 1) return this.engine.One;
        if (t !== void 0) {
          let s = this.engine.number(Math.pow(r, 1 / t));
          if (!s.isFinite || s.isInteger) return s;
        }
      } else {
        if (r.isOne) return this.engine.One;
        if (r.isZero) return this.engine.Zero;
        if (t !== void 0) {
          let s = r.root(t);
          if (s.isExact) return this.engine.number(s);
        }
      }
    }
    return this.engine._fn("Root", [this, this.engine.box(i)]);
  }
  sqrt() {
    return this.root(2);
  }
  ln(i) {
    let t = i ? this.engine.box(i) : void 0;
    if (!this.isCanonical) return this.canonical.ln(t);
    if (this.is(0)) return this.engine.NegativeInfinity;
    if (this.operator === "Exp") return this.op1;
    if (t && this.isSame(t)) return this.engine.One;
    if (!t && this.isSame(this.engine.E)) return this.engine.One;
    if (this.operator === "Power") {
      let [r, s] = this.ops;
      return r.isSame(this.engine.E) ? s : s.mul(r.ln(t));
    }
    if (this.operator === "Root") {
      let [r, s] = this.ops;
      return s.div(r.ln(t));
    }
    return this.operator === "Sqrt" ? this.op1.ln(t).div(2) : this.operator === "Divide" ? this.op1.ln(t).sub(this.op2.ln(t)) : t && t.type.matches("finite_integer") ? t.re === 10 ? this.engine._fn("Log", [this]) : this.engine._fn("Log", [this, t]) : this.engine._fn("Ln", [this]);
  }
  get complexity() {
    var _a2, _b;
    if (this.isCanonical) return (_b = (_a2 = this.functionDefinition) == null ? void 0 : _a2.complexity) != null ? _b : Un;
  }
  get baseDefinition() {
    return this._def;
  }
  get functionDefinition() {
    return this._def;
  }
  get isNumber() {
    let i = this.type.type;
    if (i !== "unknown") return v(i, "number");
  }
  get isInteger() {
    let i = this.type.type;
    if (i !== "unknown") return v(i, "integer");
  }
  get isRational() {
    let i = this.type.type;
    if (i !== "unknown") return v(i, "rational");
  }
  get isReal() {
    let i = this.type.type;
    if (i !== "unknown") return v(i, "real");
  }
  get isFunctionExpression() {
    return true;
  }
  get type() {
    var _a2;
    let i = this.isPure && this._ops.every((t) => t.isConstant) ? void 0 : this.engine.generation;
    return (_a2 = rs(this._type, i, () => {
      let t = Yd(this);
      return t ? new C(t) : void 0;
    })) != null ? _a2 : C.unknown;
  }
  simplify(i) {
    var _a2, _b;
    return (_b = (_a2 = Jn(this, i).at(-1)) == null ? void 0 : _a2.value) != null ? _b : this;
  }
  evaluate(i) {
    return rs((i == null ? void 0 : i.numericApproximation) ? this._valueN : this._value, this.engine.generation, Qd(this.engine, this._computeValue(i)));
  }
  evaluateAsync(i) {
    return gf((i == null ? void 0 : i.numericApproximation) ? this._valueN : this._value, this.engine.generation, Xd(this.engine, this._computeValueAsync(i)));
  }
  N() {
    return this.evaluate({ numericApproximation: true });
  }
  solve(i) {
    let t = vt(i != null ? i : this.unknowns);
    return t.length !== 1 ? null : Ur(this, t[0]);
  }
  get isCollection() {
    var _a2, _b;
    let i = this.functionDefinition;
    return i ? ((_a2 = i.collection) == null ? void 0 : _a2.contains) !== void 0 || ((_b = i.collection) == null ? void 0 : _b.size) !== void 0 : false;
  }
  contains(i) {
    var _a2, _b, _c2, _d2;
    return (_d2 = (_c2 = (_b = (_a2 = this.functionDefinition) == null ? void 0 : _a2.collection) == null ? void 0 : _b.contains) == null ? void 0 : _c2.call(_b, this, i)) != null ? _d2 : false;
  }
  get size() {
    var _a2, _b, _c2, _d2;
    return (_d2 = (_c2 = (_b = (_a2 = this.functionDefinition) == null ? void 0 : _a2.collection) == null ? void 0 : _b.size) == null ? void 0 : _c2.call(_b, this)) != null ? _d2 : 0;
  }
  each(i, t) {
    var _a2, _b, _c2;
    let r = (_c2 = (_b = (_a2 = this.functionDefinition) == null ? void 0 : _a2.collection) == null ? void 0 : _b.iterator) == null ? void 0 : _c2.call(_b, this, i, t);
    return r || { next() {
      return { done: true, value: void 0 };
    } };
  }
  at(i) {
    var _a2, _b, _c2;
    return (_c2 = (_b = (_a2 = this.functionDefinition) == null ? void 0 : _a2.collection) == null ? void 0 : _b.at) == null ? void 0 : _c2.call(_b, this, i);
  }
  get(i) {
    var _a2, _b, _c2, _d2, _e2, _f2;
    if (typeof i == "string") return (_c2 = (_b = (_a2 = this.functionDefinition) == null ? void 0 : _a2.collection) == null ? void 0 : _b.at) == null ? void 0 : _c2.call(_b, this, i);
    if (i.string) return (_f2 = (_e2 = (_d2 = this.functionDefinition) == null ? void 0 : _d2.collection) == null ? void 0 : _e2.at) == null ? void 0 : _f2.call(_e2, this, i.string);
  }
  indexOf(i) {
    var _a2, _b, _c2, _d2;
    return (_d2 = (_c2 = (_b = (_a2 = this.functionDefinition) == null ? void 0 : _a2.collection) == null ? void 0 : _b.indexOf) == null ? void 0 : _c2.call(_b, this, i)) != null ? _d2 : -1;
  }
  subsetOf(i, t) {
    var _a2, _b, _c2, _d2;
    return (_d2 = (_c2 = (_b = (_a2 = this.functionDefinition) == null ? void 0 : _a2.collection) == null ? void 0 : _b.subsetOf) == null ? void 0 : _c2.call(_b, this, i, t)) != null ? _d2 : false;
  }
  _computeValue(i) {
    return () => {
      var _a2, _b;
      if (!this.isValid) return this;
      let t = (_a2 = i == null ? void 0 : i.numericApproximation) != null ? _a2 : false;
      if (t) {
        let o = this.operator;
        if (o === "Integrate" || o === "Limit") return this.engine.box(["N", this], { canonical: true }).evaluate(i);
      }
      if (!this.isCanonical) {
        this.engine.pushScope();
        let o = this.canonical;
        return this.engine.popScope(), !o.isCanonical || !o.isValid ? this : o.evaluate(i);
      }
      let r = this.functionDefinition;
      if ((r == null ? void 0 : r.threadable) && this.ops.some((o) => ie(o))) {
        let o = Ms(this._ops);
        if (!o) return this.engine.Nothing;
        let a = [];
        for (; ; ) {
          let { done: u, value: l } = o.next();
          if (u) break;
          a.push(this.engine._fn(this.operator, l).evaluate(i));
        }
        return a.length === 0 ? this.engine.Nothing : a.length === 1 ? a[0] : this.engine._fn("List", a);
      }
      let s = is(this, (o) => o.evaluate(i));
      if (r) {
        let o = this.engine, a = o.swapScope(this.scope), u = (_b = r.evaluate) == null ? void 0 : _b.call(r, s, { numericApproximation: t, engine: o });
        return o.swapScope(a), u != null ? u : this.engine.function(this._name, s);
      }
      return this.engine.function(this._name, s);
    };
  }
  _computeValueAsync(i) {
    return async () => {
      var _a2, _b, _c2, _d2;
      if (!this.isValid) return this;
      let t = (_a2 = i == null ? void 0 : i.numericApproximation) != null ? _a2 : false;
      if (t) {
        let o = this.operator;
        (o === "Integrate" || o === "Limit") && this.engine.box(["N", this], { canonical: true }).evaluateAsync(i);
      }
      if (!this.isCanonical) {
        this.engine.pushScope();
        let o = this.canonical;
        return this.engine.popScope(), !o.isCanonical || !o.isValid ? this : o.evaluateAsync(i);
      }
      let r = this.functionDefinition;
      if ((r == null ? void 0 : r.threadable) && this.ops.some((o) => ie(o))) {
        let o = Ms(this._ops);
        if (!o) return this.engine.Nothing;
        let a = [];
        for (; ; ) {
          let { done: u, value: l } = o.next();
          if (u) break;
          a.push(this.engine._fn(this.operator, l).evaluateAsync(i));
        }
        return a.length === 0 ? this.engine.Nothing : a.length === 1 ? a[0] : Promise.all(a).then((u) => this.engine._fn("List", u));
      }
      let s = await df(this, async (o) => await o.evaluateAsync(i));
      if (r) {
        let o = this.engine, a = o.swapScope(this.scope), u = { numericApproximation: t, engine: o, signal: i == null ? void 0 : i.signal }, l = (_d2 = (_b = r.evaluateAsync) == null ? void 0 : _b.call(r, s, u)) != null ? _d2 : (_c2 = r.evaluate) == null ? void 0 : _c2.call(r, s, u);
        return o.swapScope(a), Promise.resolve(l).then((f) => f != null ? f : this.engine.function(this._name, s));
      }
      return Promise.resolve(this.engine.function(this._name, s));
    };
  }
};
function Yd(e12) {
  var _a2, _b;
  if (!e12.isValid) return "error";
  if (e12.operator === "Function") {
    let t = e12.ops[0].type, r = e12.ops.slice(1);
    return k(`(${r.map((s) => "any").join(", ")}) -> ${t}`);
  }
  let n = e12.functionDefinition;
  if (n) {
    let i = n.signature instanceof C ? n.signature.type : typeof n.signature == "string" ? k(n.signature) : n.signature, t = (_a2 = Kn(i)) != null ? _a2 : "unknown";
    if (typeof n.type == "function") {
      let r = n.type(e12.ops, { engine: e12.engine });
      r && (r instanceof C ? t = r.type : t = (_b = k(r)) != null ? _b : t);
    }
    return t;
  }
  return "function";
}
function Qd(e12, n) {
  return () => {
    if (e12._deadline === void 0) {
      e12._deadline = Date.now() + e12.timeLimit;
      let i = n();
      return e12._deadline = void 0, i;
    }
    return n();
  };
}
function Xd(e12, n) {
  return async () => {
    if (e12._deadline === void 0) {
      e12._deadline = Date.now() + e12.timeLimit;
      let i = await n();
      return e12._deadline = void 0, i;
    }
    return n();
  };
}
var Nn = class e7 extends X {
  constructor(n, i, t) {
    super(n, t), this._string = i.normalize(), n._register(this);
  }
  get json() {
    return `'${this._string}'`;
  }
  get hash() {
    return pn("String" + this._string);
  }
  get operator() {
    return "String";
  }
  get isPure() {
    return true;
  }
  get isCanonical() {
    return true;
  }
  set isCanonical(n) {
  }
  get type() {
    return new C("string");
  }
  get complexity() {
    return 19;
  }
  get string() {
    return this._string;
  }
  match(n, i) {
    return _n(n) || (n = this.engine.box(n, { canonical: false })), xi(n) ? { [yi(n)]: this } : n instanceof e7 && this._string === n._string ? {} : null;
  }
  get isCollection() {
    return true;
  }
  contains(n) {
    return n.string ? this._string.includes(n.string) : false;
  }
  get size() {
    return this._string.length;
  }
  each(n, i) {
    let t = this.string, r = n != null ? n : 1;
    return i = Math.min(i != null ? i : t.length, t.length), i <= 0 ? { next: () => ({ value: void 0, done: true }) } : { next: () => i > 0 ? (i--, { value: this.engine.string(t[r++ - 1]), done: false }) : { value: void 0, done: true } };
  }
  at(n) {
    return this.engine.string(this._string[n - 1]);
  }
  get(n) {
  }
  indexOf(n) {
    return n.string ? this._string.indexOf(n.string) : -1;
  }
};
var Jt = class e8 extends X {
  constructor(i, t, r) {
    var _a2, _b;
    super(i, r == null ? void 0 : r.metadata);
    this.options = r;
    if (t instanceof Hn) this._tensor = t;
    else {
      let s = (_a2 = r == null ? void 0 : r.canonical) != null ? _a2 : true;
      this._operator = (_b = t.op) != null ? _b : "List", this._ops = s ? Fe(i, t.ops) : t.ops, this._expression = i._fn(this._operator, this._ops, { canonical: s });
    }
    i._register(this);
  }
  get structural() {
    var _a2;
    return (_a2 = this._expression) != null ? _a2 : this._expression = this._tensor.expression, this._expression;
  }
  get tensor() {
    if (this._tensor === void 0) {
      this._operator, this._ops;
      let i = xf(this._operator, this._ops);
      if (i === void 0) {
        let t = xf(this._operator, this._ops);
        throw new Error("Invalid tensor");
      }
      this._tensor = bn(this.engine, i);
    }
    return this._tensor;
  }
  get baseDefinition() {
    return this.structural.baseDefinition;
  }
  get functionDefinition() {
    return this.structural.functionDefinition;
  }
  bind() {
    this.structural.bind();
  }
  reset() {
  }
  get hash() {
    return pn("BoxedTensor");
  }
  get canonical() {
    return this.isCanonical ? this : new e8(this.engine, { op: this._operator, ops: this._ops }, { canonical: true });
  }
  get isCanonical() {
    return this._tensor ? true : this._expression.isCanonical;
  }
  set isCanonical(i) {
    this._tensor || (this.structural.isCanonical = i);
  }
  get isPure() {
    return this._tensor ? true : this.structural.isPure;
  }
  get isValid() {
    return this._tensor ? true : this.structural.isValid;
  }
  get complexity() {
    return 97;
  }
  get operator() {
    return this._tensor ? "List" : this._operator;
  }
  get nops() {
    return this._tensor ? this._tensor.shape[0] : this.structural.nops;
  }
  get ops() {
    return this.structural.ops;
  }
  get op1() {
    if (this._tensor) {
      let i = this._tensor.data;
      return i.length === 0 ? this.engine.Nothing : this.engine.box(i[0]);
    }
    return this.structural.op1;
  }
  get op2() {
    if (this._tensor) {
      let i = this._tensor.data;
      return i.length < 2 ? this.engine.Nothing : this.engine.box(i[1]);
    }
    return this.structural.op2;
  }
  get op3() {
    if (this._tensor) {
      let i = this._tensor.data;
      return i.length < 3 ? this.engine.Nothing : this.engine.box(i[2]);
    }
    return this.structural.op3;
  }
  neg() {
    return this.structural.neg();
  }
  inv() {
    return this.engine.One.div(this.structural);
  }
  abs() {
    return this.structural.abs();
  }
  add(i) {
    return this.structural.add(i);
  }
  sub(i) {
    return this.structural.sub(i);
  }
  mul(i) {
    return this.structural.mul(i);
  }
  div(i) {
    return this.structural.div(i);
  }
  pow(i) {
    return this.structural.pow(i);
  }
  root(i) {
    return this.structural.root(i);
  }
  sqrt() {
    return this.structural.sqrt();
  }
  get shape() {
    return this.tensor.shape;
  }
  get rank() {
    return this.tensor.rank;
  }
  get type() {
    return new C(this.isValid ? k("list<number>") : "error");
  }
  get json() {
    return this.structural.json;
  }
  isEqual(i) {
    return this === i ? true : i instanceof e8 ? this.tensor.equals(i.tensor) : this.structural.isEqual(i);
  }
  get isCollection() {
    return true;
  }
  contains(i) {
    let t = this.tensor.data, r = this.tensor.field.cast(i, this.tensor.dtype);
    if (typeof r == "number") return t.includes(r);
    let s = t.map((o) => {
      var _a2;
      return (_a2 = this.tensor.field.cast(o, "expression")) != null ? _a2 : i.engine.Nothing;
    });
    for (let o of s) if (i.isSame(o)) return true;
    return false;
  }
  get size() {
    return this.tensor.shape.reduce((i, t) => i * t, 1);
  }
  each(i, t) {
    let r = this.tensor.data, s = i != null ? i : 1;
    return t = Math.min(t != null ? t : r.length, r.length), t <= 0 ? { next: () => ({ value: void 0, done: true }) } : { next: () => t > 0 ? (t--, { value: this.engine.box(r[s++ - 1]), done: false }) : { value: void 0, done: true } };
  }
  at(i) {
  }
  indexOf(i) {
    return -1;
  }
  match(i, t) {
    return _n(i) || (i = this.engine.box(i, { canonical: false })), xi(i) ? { [yi(i)]: this } : this.structural.match(i, t);
  }
  evaluate(i) {
    return this._tensor ? this : this.structural.evaluate(i);
  }
  simplify(i) {
    return this._tensor ? this : this.structural.simplify(i);
  }
  N() {
    return this._tensor ? this : this.structural.N();
  }
};
function Oe(e12) {
  return e12 instanceof Jt;
}
function Zo(e12, n) {
  let i, t = [], r = true, s = (o, a = 0) => {
    var _a2;
    if (o.length !== 0) {
      o.length > 1 && t[a] !== void 0 ? r = r && t[a] === o.length : t[a] = Math.max((_a2 = t[a]) != null ? _a2 : 0, o.length);
      for (let u of o) if (u.operator === e12 ? s(u.ops, a + 1) : i = Lr(i, tl(u)), !r) return;
    }
  };
  return s(n), r ? { shape: t, dtype: i } : void 0;
}
function xf(e12, n) {
  var _a2;
  let { shape: i, dtype: t } = (_a2 = Zo(e12, n)) != null ? _a2 : { shape: [], dtype: void 0 };
  if (t === void 0) return;
  let r = true, s = [], o = Or(n[0].engine, "expression"), a = o.cast.bind(o), u = (l) => {
    for (let f of l) if (f.operator === e12) u(f.ops);
    else {
      let c = a(f, t);
      if (c === void 0) {
        r = false;
        return;
      }
      s.push(c);
    }
  };
  if (u(n), !!r) return { shape: i, rank: i.length, data: s, dtype: t };
}
function ss(e12, { engine: n }) {
  if (e12.length === 0) return null;
  let i = e12[0];
  if (e12.length === 1) return i.canonical;
  if (e12.length === 2) {
    let t = bf(i);
    if (!Number.isNaN(t)) {
      let s = e12[1];
      if (s.operator === "Divide" || s.operator === "Rational") {
        let [o, a] = [s.op1.canonical.re, s.op2.canonical.re];
        if (o > 0 && o <= 1e3 && a > 1 && a <= 1e3 && Number.isInteger(o) && Number.isInteger(a)) {
          let u = s.canonical;
          return t < 0 && (u = u.neg()), n._fn("Add", [i.canonical, u]);
        }
      }
    }
    let r = e12[1];
    if (!Number.isNaN(t)) {
      let s = r.canonical;
      if (s.re === 0 && s.im === 1) return n.number(n.complex(0, t));
    }
    if (i.symbol && r.operator === "Delimiter") {
      if (r.nops === 0) return n.lookupFunction(i.symbol) || n.declare(i.symbol, "function"), n.box([i.symbol]);
      let s = r.op1.operator === "Sequence" ? r.op1.ops : [r.op1];
      if (s = J(s), !n.lookupSymbol(i.symbol)) return n.lookupFunction(i.symbol) || n.declare(i.symbol, "function"), n.function(i.symbol, s);
    }
    if (i.symbol && r.operator === "Delimiter" && (r.op2.string === "[,]" || r.op2.string === "[;]")) {
      let s = r.op1.operator === "Sequence" ? r.op1.ops : [r.op1];
      return n.function("At", [i, ...s]);
    }
  }
  return e12 = yf(e12), e12 = J(e12), e12.every((t) => t.isValid && (t.type.isUnknown || t.type.matches("number") || si(t) && !t.string)) ? n._fn("Multiply", e12) : n._fn("Tuple", e12);
}
function yf(e12) {
  let n = [];
  for (let i of e12) i.operator === "InvisibleOperator" ? n.push(...yf(i.ops)) : n.push(i);
  return n;
}
function bf(e12) {
  if (e12.isNumberLiteral) {
    let n = e12.re;
    if (Number.isInteger(n)) return n;
  }
  if (e12.operator === "Negate") {
    let n = bf(e12.op1);
    if (!Number.isNaN(n)) return -n;
  }
  return Number.NaN;
}
function Ei(e12, n) {
  if (n === false) return e12;
  if (n === true) return e12.canonical;
  typeof n == "string" && (n = [n]);
  for (let i of n) switch (i) {
    case "InvisibleOperator":
      e12 = Wo(e12);
      break;
    case "Number":
      e12 = Ef(e12);
      break;
    case "Multiply":
      e12 = Nf(e12);
      break;
    case "Add":
      e12 = vf(e12);
      break;
    case "Power":
      e12 = ft(e12);
      break;
    case "Divide":
      e12 = Tf(e12);
      break;
    case "Flatten":
      e12 = Ho(e12);
      break;
    case "Order":
      e12 = Zs(e12, { recursive: true });
      break;
    default:
      throw Error("Invalid canonical form");
  }
  return e12;
}
function Ho(e12) {
  var _a2;
  if (!e12.operator || !e12.ops || e12.nops === 0) return e12;
  if (e12.operator === "Delimiter") return Ho(e12.op1);
  let n = e12.engine, i = e12.operator === "Add" || e12.operator === "Multiply";
  return i || ((_a2 = n.lookupFunction(e12.operator)) == null ? void 0 : _a2.associative) && (i = true), i ? n.function(e12.operator, Gn(e12.ops.map(Ho), e12.operator)) : e12;
}
function Wo(e12) {
  var _a2;
  return e12.ops ? e12.operator === "InvisibleOperator" ? (_a2 = ss(e12.ops.map(Wo), { engine: e12.engine })) != null ? _a2 : e12 : e12.engine._fn(e12.operator, e12.ops.map(Wo)) : e12;
}
function Ef(e12) {
  return e12.isNumberLiteral ? e12.canonical : e12.ops ? e12.engine._fn(e12.operator, e12.ops.map(Ef)) : e12;
}
function Nf(e12) {
  if (!e12.ops) return e12;
  let n = e12.ops.map(Nf);
  return e12.operator === "Multiply" ? pe(e12.engine, n.map((i) => i.canonical)) : e12.operator === "Negate" ? pe(e12.engine, [n[0], e12.engine.NegativeOne]) : e12;
}
function vf(e12) {
  if (!e12.ops) return e12;
  let n = e12.ops.map(vf);
  return e12.operator === "Add" ? Ve(e12.engine, n) : e12.operator === "Subtract" ? Ve(e12.engine, [n[0], n[1].neg()]) : e12.engine._fn(e12.operator, n);
}
function ft(e12) {
  return e12.ops ? e12.operator === "Power" ? ft(e12.op1).pow(ft(e12.op2)) : e12.ops ? e12.engine._fn(e12.operator, e12.ops.map(ft)) : e12 : e12;
}
function Tf(e12) {
  return e12.operator === "Divide" ? He(ft(e12.op1), ft(e12.op2)) : e12.ops ? e12.engine._fn(e12.operator, e12.ops.map(Tf)) : e12;
}
function Jo(e12, n, i) {
  if (n instanceof X) return n;
  if (n = F(n), typeof n == "string") return on(e12, n, i);
  if (Array.isArray(n)) {
    let [t, ...r] = n;
    return new Ge(e12, t, r.map((s) => Jo(e12, s, i)));
  }
  if (typeof n == "object") {
    if ("fn" in n) return Jo(e12, n.fn, i);
    if ("str" in n) return new Nn(e12, n.str);
    if ("sym" in n) return on(e12, n.sym, i);
    if ("num" in n) return on(e12, n.num, i);
  }
  return on(e12, n, i);
}
function os(e12, n, i, t) {
  var _a2, _b;
  if (t = t ? { ...t } : {}, "canonical" in t || (t.canonical = true), !xe(n)) throw new Error(`Unexpected function name: "${n}" (not a valid identifier: ${We(n)})`);
  let r = (_a2 = t.structural) != null ? _a2 : false;
  if (n === "Hold") return new Ge(e12, "Hold", [Jo(e12, i[0], t)], { ...t, canonical: true, structural: r });
  if (n === "Error" || n === "ErrorCode") return e12._fn(n, i.map((o) => e12.box(o, { canonical: false })), t.metadata);
  if (n === "String") return i.length === 0 ? new Nn(e12, "", t.metadata) : new Nn(e12, i.map((o) => {
    var _a3;
    return (_a3 = Sf(o)) != null ? _a3 : "";
  }).join(""), t.metadata);
  if (n === "Symbol" && i.length > 0) return e12.symbol(i.map((o) => {
    var _a3;
    return (_a3 = Sf(o)) != null ? _a3 : "";
  }).join(""), t);
  if (n === "Number" && i.length === 1) return on(e12, i[0], t);
  if (r === false && (t.canonical === true || t.canonical === "Number" || Array.isArray(t.canonical) && t.canonical.includes("Number"))) {
    if ((n === "Divide" || n === "Rational") && i.length === 2) {
      let o = _f(i[0]);
      if (o !== null) {
        let a = _f(i[1]);
        if (a !== null) return e12.number([o, a], t);
      }
      n = "Divide";
    }
    if (n === "Complex") {
      if (i.length === 1) {
        let o = i[0];
        if (o instanceof X && o.isNumberLiteral) return e12.number(e12.complex(0, o.re), t);
        let a = D(i[0]);
        return a !== null && a !== 0 ? e12.number(e12.complex(0, a), t) : e12.box(o).mul(e12.I);
      }
      if (i.length === 2) {
        let o = i[0] instanceof X ? i[0].re : D(i[0]), a = i[1] instanceof X ? i[1].re : D(i[1]);
        return a !== null && o !== null && !isNaN(a) && !isNaN(o) ? a === 0 && o === 0 ? e12.Zero : a !== 0 ? e12.number(e12._numericValue({ re: o, im: a }), t) : on(e12, i[0], t) : on(e12, i[0], t).add(on(e12, i[1], t).mul(e12.I));
      }
      throw new Error("Expected one or two arguments with Complex expression");
    }
    if (n === "Negate" && i.length === 1) {
      let o = i[0];
      if (typeof o == "number") return e12.number(-o, t);
      if (o instanceof M) return e12.number(o.neg(), t);
      let a = e12.box(o, t), u = a.numericValue;
      if (u !== null) return e12.number(typeof u == "number" ? -u : u.neg(), t);
      i = [a];
    }
  }
  return t.canonical === true ? Kd(e12, n, i, t.metadata) : Ei(new Ge(e12, n, i.map((o) => on(e12, o, { canonical: t.canonical, structural: r })), { metadata: t.metadata, canonical: false, structural: r }), (_b = t.canonical) != null ? _b : false);
}
function on(e12, n, i) {
  var _a2, _b;
  if (n == null) return e12.error("missing");
  if (n instanceof z) return nm(e12, n);
  if (n instanceof X) return Ei(n, (_a2 = i == null ? void 0 : i.canonical) != null ? _a2 : true);
  i = i ? { ...i } : {}, "canonical" in i || (i.canonical = true);
  let t = i.canonical === true, r = (_b = i.structural) != null ? _b : false;
  if (Array.isArray(n)) {
    if (typeof n[0] != "string") throw new Error(`The first element of an array should be a string (the function name): ${JSON.stringify(n)}`);
    return Ei(os(e12, n[0], n.slice(1), { canonical: t, structural: r }), i.canonical);
  }
  if (typeof n == "number" || n instanceof M || n instanceof $) return e12.number(n);
  if (typeof n == "string") {
    if (n.startsWith("'") && n.endsWith("'")) return new Nn(e12, n.slice(1, -1));
    let s = n;
    if (s = s.replace(/[\u0009-\u000d\u0020\u00a0]/g, ""), /^[+-]?[0-9]/.test(s)) {
      let o = e12.number(n);
      if (!o.isNaN) return o;
    }
    return xe(n) ? e12.symbol(n, { canonical: t }) : e12.error("invalid-identifier", n);
  }
  if (typeof n == "object") {
    if ("fn" in n) {
      let [s, ...o] = n.fn;
      return Ei(os(e12, s, o, { canonical: t, structural: r }), i.canonical);
    }
    if ("str" in n) return new Nn(e12, n.str);
    if ("sym" in n) return e12.symbol(n.sym, { canonical: t });
    if ("num" in n) return e12.number(n, { canonical: t });
    throw new Error(`Unexpected MathJSON object: ${JSON.stringify(n)}`);
  }
  return e12.symbol("Undefined");
}
function Sf(e12) {
  var _a2, _b;
  if (typeof e12 == "string") return e12;
  if (e12 instanceof X) return (_b = (_a2 = e12.string) != null ? _a2 : e12.symbol) != null ? _b : e12.toString();
  if (typeof e12 == "object") {
    if ("str" in e12) return e12.str;
    if ("fn" in e12 && e12.fn[0] === "String" && typeof e12.fn[1] == "string") return e12.fn[1];
  }
  return Array.isArray(e12) && e12[0] === "String" && typeof e12[1] == "string" ? e12[1] : null;
}
function Kd(e12, n, i, t) {
  var _a2, _b;
  let r = em(e12, n, i, t);
  if (r) return r;
  if (n === "List") {
    let l = i.map((p) => e12.box(p)), { shape: f, dtype: c } = (_a2 = Zo("List", l)) != null ? _a2 : {};
    return c && f ? new Jt(e12, { op: "List", ops: l }) : e12._fn("List", l);
  }
  let s = e12.lookupFunction(n);
  if (!s) return new Ge(e12, n, J(Fe(e12, i)), { metadata: t, canonical: true });
  if (s.lazy) {
    let l = i.map((f) => e12.box(f, { canonical: false }));
    if (s.canonical) {
      try {
        let f = s.canonical(l, { engine: e12 });
        if (f) return f;
      } catch (f) {
        console.error(f.message);
      }
      return new Ge(e12, n, l, { metadata: t, canonical: false });
    }
    return e12._fn(n, (_b = Ci(e12, l, s.signature.type, s.lazy, s.threadable)) != null ? _b : l, t);
  }
  let o = i.map((l) => e12.box(l));
  if (s.canonical) {
    try {
      let l = s.canonical(o, { engine: e12 });
      if (l) return l;
    } catch (l) {
      console.error(l.message);
    }
    return new Ge(e12, n, o, { metadata: t, canonical: false });
  }
  let a = J(o, s.associative ? n : void 0), u = Ci(e12, a, s.signature.type, s.lazy, s.threadable);
  if (u) return e12._fn(n, u, t);
  if (a.length === 1 && a[0].operator === n) {
    if (s.involution) return a[0].op1;
    if (s.idempotent) return e12._fn(n, o[0].ops, t);
  }
  return e12._fn(n, Rt(n, a), t);
}
function em(e12, n, i, t) {
  let r = [];
  if (n === "Add" || n === "Multiply") r = Me(e12, Di(e12, i), { flatten: n });
  else if (n === "Negate" || n === "Square" || n === "Sqrt" || n === "Exp") r = Me(e12, Di(e12, i), 1);
  else if (n === "Ln" || n === "Log") r = Me(e12, Di(e12, i)), r.length === 0 && (r = [e12.error("missing")]);
  else if (n === "Power" || n === "Root") r = Me(e12, Di(e12, i), 2);
  else if (n === "Divide") r = Me(e12, Di(e12, i)), r.length === 0 && (r = [e12.error("missing"), e12.error("missing")]), r.length === 1 && (r = [r[0], e12.error("missing")]);
  else return null;
  if (!r.every((s) => s.isValid)) return e12._fn(n, r, t);
  if (n === "Add") return Ve(e12, r);
  if (n === "Negate") return al(r[0]);
  if (n === "Multiply") return pe(e12, r);
  if (n === "Divide") return r.length === 2 ? He(...r) : r.slice(1).reduce((s, o) => He(s, o), r[0]);
  if (n === "Exp") return zi(e12.E, r[0]);
  if (n === "Square") return zi(r[0], e12.number(2));
  if (n === "Power") return zi(r[0], r[1]);
  if (n === "Root") return li(r[0], r[1]);
  if (n === "Sqrt") return li(r[0], 2);
  if (n === "Ln" || n === "Log") {
    if (r.length > 0) {
      if (r[0].is(1)) return e12.Zero;
      if (r.length === 1) return e12._fn(n, r, t);
    }
    return e12._fn("Log", r, t);
  }
  return null;
}
function nm(e12, n) {
  var _a2, _b;
  if (n.isZero) return e12.Zero;
  if (n.isOne) return e12.One;
  if (n.isNegativeOne) return e12.NegativeOne;
  if (n.isNaN) return e12.NaN;
  if (n.isNegativeInfinity) return e12.NegativeInfinity;
  if (n.isPositiveInfinity) return e12.PositiveInfinity;
  if (n = (_a2 = n.asExact) != null ? _a2 : n, !n.isExact) {
    let s = n.im;
    return s === 0 ? e12.number((_b = n.bignumRe) != null ? _b : n.re) : n.re === 0 ? e12.number(e12.complex(0, s)) : n.bignumRe !== void 0 && !fi(n.bignumRe) ? Ve(e12, [e12.number(n.bignumRe), e12.number(e12.complex(0, s))]) : e12.number(e12.complex(n.re, n.im));
  }
  let i = [], t = n;
  if (t.sign !== 0) if (t.radical === 1) i.push(e12.number(t.rational));
  else {
    let s = t.rational, o = e12.function("Sqrt", [e12.number(t.radical)]);
    if (ve(s)) i.push(o);
    else {
      let [a, u] = s;
      u === 1 ? a === 1 ? i.push(o) : i.push(e12.function("Multiply", [e12.number(a), o])) : a === 1 ? i.push(e12.function("Divide", [o, e12.number(u)])) : i.push(e12.function("Divide", [e12.function("Multiply", [e12.number(a), o]), e12.number(u)]));
    }
  }
  let r;
  return n.im === 0 ? i.length === 0 ? e12.Zero : (r = i.length === 1 ? i[0] : pe(e12, i), r) : i.length === 0 ? e12.number(e12.complex(0, n.im)) : (r = i.length === 1 ? i[0] : pe(e12, i), Ve(e12, [r, e12.number(e12.complex(0, n.im))]));
}
function _f(e12) {
  return typeof e12 == "bigint" ? e12 : typeof e12 == "number" && Number.isInteger(e12) ? BigInt(e12) : e12 instanceof X ? Dt(e12) : e12 instanceof M || typeof e12 == "string" ? K(e12) : e12 instanceof $ ? e12.im === 0 ? K(e12.re) : null : uu(e12);
}
var im = { Sin: ["Cos", "_"], Cos: ["Negate", ["Sin", "_"]], Tan: ["Power", ["Sec", "_"], 2], Sec: ["Multiply", ["Tan", "_"], ["Sec", "_"]], Csc: ["Multiply", ["Negate", ["Cot", "_"]], ["Csc", "_"]], Cot: ["Negate", ["Power", ["Csc", "_"], 2]], Arcsin: ["Power", ["Subtract", 1, ["Power", "_", 2]], ["Negate", "Half"]], Arccos: ["Negate", ["Power", ["Subtract", 1, ["Power", "_", 2]], ["Negate", "Half"]]], Arctan: ["Power", ["Add", 1, ["Power", "_", 2]], -1], Arcsec: ["Multiply", ["Power", ["Subtract", 1, ["Power", "_", 2]], ["Negate", "Half"]], ["Negate", ["Power", "_", 2]]], Arccsc: ["Multiply", ["Power", ["Subtract", 1, ["Power", "_", 2]], ["Negate", "Half"]], ["Negate", ["Power", "_", 2]]], Arccot: ["Negate", ["Power", ["Add", 1, ["Power", "_", 2]], -1]], Sinh: ["Cosh", "_"], Cosh: ["Sinh", "_"], Tanh: ["Power", ["Sech", "_"], 2], Sech: ["Multiply", ["Tanh", "_"], "Sech"], Csch: ["Multiply", ["Coth", "_"], "Csch"], Coth: ["Negate", ["Power", ["Csch", "_"], 2]], Arcsinh: ["Power", ["Add", ["Power", "_", 2], 1], ["Negate", "Half"]], Arccosh: ["Power", ["Subtract", ["Power", "_", 2], 1], ["Negate", "Half"]], Arctanh: ["Power", ["Subtract", 1, ["Power", "_", 2]], -1], Arcsech: ["Negate", ["Power", ["Multiply", "2", "Subtract", ["Power", "_", 2]], ["Negate", "Half"]]], Arccsch: ["Negate", ["Power", ["Multiply", "2", "Add", ["Power", "_", 2]], ["Negate", "Half"]]], Arccoth: ["Negate", ["Power", ["Subtract", 1, ["Power", "_", 2]], -1]], Ln: ["Divide", 1, "_"], Log: ["Power", ["Multiply", "_", ["Ln", "10"]], -1], Sqrt: ["Multiply", ["Power", "_", ["Negate", "Half"]], "Half"], Abs: ["Which", ["Equal", "_", 0], NaN, ["Less", "_", 0], -1, ["Greater", "_", 0], 1, "True", ["D", ["Abs", "_"], "_"]], Erf: ["Multiply", ["Divide", "2", ["Sqrt", "Pi"]], ["Exp", ["Negate", ["Square", "_"]]]], Gamma: ["Multiply", ["Gamma", "_"], ["Digamma", "_"]], Digamma: ["Add", ["Multiply", ["Digamma", "_"], ["Gamma", "_"]], ["Multiply", ["Power", "_", -1], ["Gamma", "_"]]], Zeta: ["Multiply", ["Multiply", -1, ["Zeta", "_"]], ["Digamma", "_"]], PolyGamma: ["Add", ["Multiply", ["PolyGamma", "_"], ["Gamma", "_"]], ["Multiply", ["Power", "_", -1], ["Gamma", "_"]]], Beta: ["Multiply", ["Add", ["Multiply", ["Beta", "_"], ["Digamma", "_"]], ["Multiply", ["Power", "_", -1], ["Beta", "_"]]], ["Beta", "_"]], Erfc: ["Multiply", ["Negate", ["Erfc", "_"]], ["Exp", ["Negate", ["Power", "_", 2]]], ["Power", "_", -1]], LambertW: ["Multiply", ["Power", "_", -1], ["Multiply", ["Add", "_", ["LambertW", "_"]], ["Add", ["LambertW", "_"], 1]]], AiryAi: ["Multiply", ["AiryAi", "_"], ["AiryBi", "_"]], AiryBi: ["Multiply", ["AiryAi", "_"], ["AiryBi", "_"]], BesselJ: ["Multiply", ["BesselJ", "_"], ["BesselY", "_"]], BesselY: ["Multiply", ["BesselJ", "_"], ["BesselY", "_"]], BesselI: ["Multiply", ["BesselI", "_"], ["BesselK", "_"]], BesselK: ["Multiply", ["BesselI", "_"], ["BesselK", "_"]], FresnelS: ["Multiply", ["FresnelS", "_"], ["FresnelC", "_"]], FresnelC: ["Multiply", ["FresnelS", "_"], ["FresnelC", "_"]], Erfi: ["Multiply", ["Erfi", "_"], ["Erf", "_"]] };
function If(e12, n) {
  var _a2;
  if (n === 0) return e12;
  let i = e12.engine, t = "_";
  e12.symbol && e12.functionDefinition && (e12 = Qi(i.symbol(e12.symbol), [i.symbol("_")])), e12.operator === "Function" && (t = (_a2 = e12.ops[1].symbol) != null ? _a2 : "_", e12 = e12.ops[0]);
  let r = e12;
  for (; n-- > 0 && r; ) r = Qe(r, t);
  return r;
}
function Qe(e12, n) {
  var _a2, _b, _c2, _d2, _e2, _f2;
  let i = e12.engine;
  if (e12.string) return;
  if (e12.isNumberLiteral) return e12.engine.Zero;
  if (e12.symbol === n) return e12.engine.One;
  if (e12.symbol) return e12.engine.Zero;
  if (!e12.operator) return;
  if (e12.operator === "Negate") {
    let o = Qe(e12.op1, n);
    return o ? o.neg() : i._fn("D", [e12.op1, i.symbol(n)]).neg();
  }
  if (e12.operator === "Add") {
    let o = e12.ops.map((a) => Qe(a, n));
    return o.some((a) => a === void 0) ? void 0 : H(...o).evaluate();
  }
  if (e12.operator === "Multiply") {
    let o = e12.ops.map((a, u) => {
      var _a3;
      let l = e12.ops.slice();
      l.splice(u, 1);
      let f = ae(...l);
      return ((_a3 = Qe(a, n)) != null ? _a3 : i._fn("D", [a, i.symbol(n)])).mul(f);
    });
    return o.some((a) => a === void 0) ? void 0 : H(...o).evaluate();
  }
  if (e12.operator === "Power") {
    let [o, a] = e12.ops;
    if (o.symbol === n) return a.mul(o.pow(a.add(i.NegativeOne))).evaluate();
    let u = o, l = a, f = (_a2 = Qe(u, n)) != null ? _a2 : i._fn("D", [u, i.symbol(n)]), p = ((_b = Qe(l, n)) != null ? _b : i._fn("D", [l, i.symbol(n)])).mul(u.ln()), m = l.mul(f).div(u);
    return e12.mul(p.add(m)).evaluate();
  }
  if (e12.operator === "Divide") {
    let [o, a] = e12.ops, u = (_c2 = Qe(o, n)) != null ? _c2 : i._fn("D", [o, i.symbol(n)]), l = (_d2 = Qe(a, n)) != null ? _d2 : i._fn("D", [a, i.symbol(n)]);
    return u.mul(a).sub(l.mul(o)).div(a.pow(2)).evaluate();
  }
  let t = im[e12.operator];
  if (!t) {
    if (e12.nops > 1) return;
    let o = i._fn("Derivative", [i.symbol(e12.operator), i.One]);
    if (!o.isValid) return;
    let a = e12.ops[0], u = (_e2 = Qe(a, n)) != null ? _e2 : i._fn("D", [a, i.symbol(n)]);
    return u.isValid ? i._fn("Apply", [o, a]).mul(u) : void 0;
  }
  if (e12.nops > 1) return i._fn("D", [e12, i.symbol(n)]);
  let r = e12.ops[0], s = (_f2 = Qe(r, n)) != null ? _f2 : i._fn("D", [r, i.symbol(n)]);
  return Qi(i.box(t), [r]).mul(s);
}
var Bf = [{ Derivative: { threadable: false, lazy: true, signature: "(any, order:number?) -> function", canonical: (e12, { engine: n }) => n._fn("Derivative", [e12[0].canonical, ...e12.slice(1)]), evaluate: (e12) => {
  var _a2;
  let n = e12[0].evaluate(), i = Math.floor((_a2 = e12[1]) == null ? void 0 : _a2.N().re);
  return If(n, isNaN(i) ? 1 : i);
} }, D: { threadable: false, lazy: true, signature: "(expression, variable:symbol, variables:...symbol) -> expression", canonical: (e12, { engine: n }) => {
  let i = n, t = e12[0];
  if (!t) return null;
  i.pushScope();
  let r = e12.slice(1);
  t.bind(), t = t.canonical;
  let s = i._fn("D", [t, ...r]);
  return i.popScope(), s;
}, evaluate: (e12, { engine: n }) => {
  let i = n, t = e12[0].canonical, r = i.swapScope(t.scope);
  t = t.evaluate();
  let s = e12.slice(1);
  s.length === 0 && (t = void 0);
  for (let o of s) {
    if (!o.symbol) {
      t = void 0;
      break;
    }
    if (t = Qe(t, o.symbol), t === void 0) break;
  }
  return i.swapScope(r), t = t == null ? void 0 : t.canonical, (t == null ? void 0 : t.operator) === "D" ? t : t == null ? void 0 : t.evaluate();
} }, ND: { threadable: false, lazy: true, signature: "(function, at:number) -> number", evaluate: ([e12, n], { engine: i }) => {
  let t = n == null ? void 0 : n.canonical.N().re;
  if (isNaN(t)) return;
  let r = go(i.box(e12));
  return i.number(Xa(r, t));
} }, Integrate: { wikidata: "Q80091", threadable: false, lazy: true, signature: "(expression, range:(tuple|symbol|nothing)) -> number", canonical: (e12, { engine: n }) => {
  var _a2, _b, _c2, _d2, _e2, _f2, _g, _h, _i2;
  let i = n, t = e12[1], r = null, s = null, o = null;
  t && t.operator !== "Tuple" && t.operator !== "Triple" && t.operator !== "Pair" && t.operator !== "Single" ? r = t : t && (r = (_b = (_a2 = t.ops) == null ? void 0 : _a2[0]) != null ? _b : null, s = (_e2 = (_d2 = (_c2 = t.ops) == null ? void 0 : _c2[1]) == null ? void 0 : _d2.canonical) != null ? _e2 : null, o = (_h = (_g = (_f2 = t.ops) == null ? void 0 : _f2[2]) == null ? void 0 : _g.canonical) != null ? _h : null), r && r.operator === "Hold" && (r = r.op1), r && r.operator === "ReleaseHold" && (r = r.op1.evaluate()), r != null ? r : r = i.Nothing, r.symbol || (r = i.typeError("symbol", r.type, r)), s && s.symbol !== "Nothing" && (s.type.isUnknown || (s = In(i, s, "number"))), o && o.symbol !== "Nothing" && (o.type.isUnknown || (o = In(i, o, "number"))), s && o ? t = i.tuple(r, s, o) : o ? t = i.tuple(r, i.NegativeInfinity, o) : s ? t = i.tuple(r, s) : t = r;
  let a = (_i2 = e12[0]) != null ? _i2 : i.error("missing");
  return a = a.canonical, a.operator === "Delimiter" && a.op1.operator === "Sequence" && (a = a.op1.op1), i._fn("Integrate", [a, t]);
} }, NIntegrate: { threadable: false, lazy: true, signature: "(expression, lower:number, upper:number) -> number", evaluate: (e12, { engine: n }) => {
  let i = n.precision;
  n.precision = "machine";
  let t = n.strict;
  n.strict = false;
  let [r, s] = e12.slice(1).map((a) => a.value), o;
  if (typeof r == "number" && typeof s == "number") {
    let a = go(e12[0]);
    o = n.number(jr(a, r, s));
  }
  return n.precision = i, n.strict = t, o;
} } }, { Limit: { description: "Limit of a function", complexity: 5e3, threadable: false, lazy: true, signature: "(expression, point:number, direction:number?) -> number", evaluate: (e12, { engine: n }) => {
  let [i, t, r] = e12, s = t.N().re;
  if (!isFinite(s)) return;
  let o = ze(i);
  return n.number(ii((a) => {
    var _a2;
    let u = (_a2 = o([n.number(a)])) == null ? void 0 : _a2.value;
    return typeof u == "number" ? u : Number.NaN;
  }, s, r ? r.re : 1));
} }, NLimit: { description: "Numerical approximation of the limit of a function", complexity: 5e3, threadable: false, lazy: true, signature: "(expression, point:number, direction:number?) -> number", evaluate: ([e12, n, i], { engine: t }) => {
  let r = n.N().re;
  if (Number.isNaN(r)) return;
  let s = ze(e12);
  return t.number(ii((o) => {
    var _a2;
    let a = (_a2 = s([t.number(o)])) == null ? void 0 : _a2.value;
    return typeof a == "number" ? a : Number.NaN;
  }, r, i ? i.re : 1));
} } }];
var wf = [{ Block: { lazy: true, signature: "(any) -> any", canonical: sm, evaluate: rm }, Condition: { lazy: true, signature: "(value, symbol) -> boolean", evaluate: ([e12, n], { engine: i }) => {
  let t = [];
  return n.symbol ? t = [n.symbol] : n.operator === "And" && (t = n.ops.map((r) => {
    var _a2;
    return (_a2 = r.symbol) != null ? _a2 : "";
  })), Rl(e12, t) ? i.True : i.False;
} }, If: { lazy: true, signature: "(expression, expression, expression) -> any", type: ([e12, n, i]) => ke(n.type.type, i.type.type), evaluate: ([e12, n, i], { engine: t }) => {
  var _a2, _b;
  return e12 = e12.evaluate(), e12 && e12.symbol === "True" ? (_a2 = n == null ? void 0 : n.evaluate()) != null ? _a2 : t.Nothing : (_b = i == null ? void 0 : i.evaluate()) != null ? _b : t.Nothing;
} }, Loop: { lazy: true, signature: "(body:expression, collection:expression) -> any", type: ([e12]) => e12.type, evaluate: ([e12, n], { engine: i }) => Ri(kf(e12, n, i), i._timeRemaining), evaluateAsync: async ([e12, n], { engine: i, signal: t }) => Ai(kf(e12, n, i), i._timeRemaining, t) }, Which: { lazy: true, signature: "(...expression) -> unknown", type: (e12) => e12.length % 2 !== 0 ? "nothing" : ke(...e12.filter((n, i) => i % 2 === 1).map((n) => n.type.type)), canonical: (e12, n) => e12.length % 2 !== 0 ? n.engine.Nothing : n.engine._fn("Which", e12.map((i) => i.canonical)), evaluate: (e12, n) => tm(e12, n) }, FixedPoint: { lazy: true, signature: "any -> any" } }];
function tm(e12, n) {
  let i = 0;
  for (; i < e12.length - 1; ) {
    if (e12[i].evaluate().symbol === "True") return e12[i + 1] ? e12[i + 1].evaluate(n) : n.engine.symbol("Undefined");
    i += 2;
  }
  return n.engine.symbol("Undefined");
}
function rm(e12, { engine: n }) {
  if (e12.length === 0) return n.Nothing;
  n.resetContext();
  let i;
  for (let t of e12) {
    let r = t.operator;
    if (r === "Return") {
      i = t.op1.evaluate();
      break;
    }
    if (r === "Break" || r === "Continue") {
      i = n.box([r, t.op1.evaluate()]);
      break;
    }
    i = t.evaluate();
  }
  return i != null ? i : n.Nothing;
}
function sm(e12, n) {
  let { engine: i } = n;
  if (e12.length === 0) return null;
  i.pushScope();
  let t = [], r = [];
  for (let o of e12) o.operator === "Declare" ? t.push(o) : r.push(Df(o));
  let s = i._fn("Block", [...t, ...r]);
  return i.popScope(), s;
}
function Df(e12) {
  return e12.operator === "Declare" && e12.engine.error("unexpected-declare"), e12.ops ? e12.engine._fn(e12.operator, e12.ops.map(Df)) : e12;
}
function* kf(e12, n, i) {
  var _a2;
  if (e12 != null ? e12 : e12 = i.Nothing, e12.symbol === "Nothing") return e12;
  if (n == null ? void 0 : n.isCollection) {
    let r, s = ze(e12), o = 0;
    for (let a of ee(n)) {
      if (r = (_a2 = s([a])) != null ? _a2 : i.Nothing, r.operator === "Break") return r.op1;
      if (r.operator === "Return") return r;
      if (o += 1, o % 1e3 === 0 && (yield r), o > i.iterationLimit) throw new dn({ cause: "iteration-limit-exceeded" });
    }
    return r;
  }
  let t = 0;
  for (; ; ) {
    let r = e12.evaluate();
    if (r.operator === "Break") return r.op1;
    if (r.operator === "Return") return r;
    if (t += 1, t % 1e3 === 0 && (yield r), t > i.iterationLimit) throw new dn({ cause: "iteration-limit-exceeded" });
  }
}
var Af = [{ Real: { threadable: true, complexity: 1200, signature: "number -> real", sgn: ([e12]) => {
  let n = e12.re;
  if (!isNaN(n)) return n === 0 ? "zero" : n > 0 ? "positive" : "negative";
}, evaluate: (e12, { engine: n }) => {
  var _a2;
  let i = e12[0].numericValue;
  if (i !== null) return typeof i == "number" ? e12[0] : n.number((_a2 = i.bignumRe) != null ? _a2 : i.re);
} }, Imaginary: { threadable: true, complexity: 1200, signature: "number -> real", sgn: ([e12]) => {
  let n = e12.im;
  if (!isNaN(n)) return n === 0 ? "zero" : n > 0 ? "positive" : "negative";
}, evaluate: (e12, { engine: n }) => {
  let i = e12[0].numericValue;
  if (i !== null) return typeof i == "number" ? n.Zero : n.number(i.im);
} }, Argument: { threadable: true, complexity: 1200, signature: "number -> real", evaluate: (e12, { engine: n }) => {
  let i = e12[0].numericValue;
  if (i !== null) return typeof i == "number" ? i >= 0 ? n.Zero : n.Pi : i.im === 0 ? i.re >= 0 ? n.Zero : n.Pi : n.function("ArcTan2", [i.im, i.re]).evaluate();
} }, AbsArg: { threadable: true, complexity: 1200, signature: "number -> tuple<real, real>", evaluate: (e12, { engine: n }) => {
  if (e12[0].numericValue !== null) return n.tuple(n.function("Abs", e12).evaluate(), n.function("Argument", e12).evaluate());
} }, Conjugate: { threadable: true, complexity: 1200, signature: "number -> number", type: ([e12]) => e12.type, sgn: ([e12]) => e12.sgn, evaluate: (e12, { engine: n }) => {
  let i = e12[0].numericValue;
  if (i !== null) return typeof i == "number" || i.im === 0 ? e12[0] : n.number(n.complex(i.re, -i.im));
} }, ComplexRoots: { threadable: true, complexity: 1200, signature: "(number, number) -> list<number>", evaluate: (e12, { engine: n }) => {
  var _a2;
  let i = e12[0].re;
  if (isNaN(i)) return;
  let t = e12[1].re;
  if (!Number.isInteger(t) || t <= 0) return;
  let r = [], s = (_a2 = e12[0].im) != null ? _a2 : 0, o = Math.atan2(s, i), a = Math.sqrt(i * i + s * s);
  for (let u = 0; u < t; u++) {
    let l = (o + 2 * Math.PI * u) / t, f = Math.pow(a, 1 / t);
    r.push([f * Math.cos(l), f * Math.sin(l)]);
  }
  return n.function("List", r.map((u) => n.number(u[1] !== 0 ? n.complex(u[0], u[1]) : u[0])));
} } }];
function Yt(e12) {
  return e12[Math.floor(Math.random() * e12.length)];
}
function Rf(e12, n) {
  if (e12 === "Add" || e12 === "Multiply") {
    let i = [], t = 1 + Math.floor(Math.random() * 12);
    for (; t > 0; ) i.push(vn(n + 1)), t -= 1;
    return [e12, ...i];
  }
  return e12 === "Divide" || e12 === "Power" ? [e12, vn(n + 1), vn(n + 1)] : e12 === "Root" ? [e12, vn(n + 1), vn(10)] : e12 === "trig" ? om() : [e12, vn(n + 1)];
}
function om() {
  return [Yt(["Cos", "Sin", "Tan", "Sinh", "Arccos", "Arcsinh"]), Yt(["Pi", "-1", "0", "1", ["Divide", "Pi", -5], ["Multiply", -2, ["Divide", "Pi", 11]], ["Multiply", "Half", "Pi"], ["Multiply", 5, "Pi"], ["Multiply", 12, "Pi"], ["Divide", "Pi", 5], ["Divide", "Pi", 9], ["Multiply", 5, ["Divide", "Pi", 9]], ["Multiply", 2, ["Divide", "Pi", 11]], ["Multiply", 2, ["Divide", "Pi", 3]]])];
}
function vn(e12) {
  if (e12 != null ? e12 : e12 = 1, e12 === 1) {
    let n = Yt([["Sqrt", ["Multiply", 6, ["Sum", ["Divide", 1, ["Power", "n", 2]], ["Triple", ["Hold", "n"], 1, "PositiveInfinity"]]]], "Add", "Add", "Add", "Add", "Add", "Multiply", "Multiply", "Multiply", "Multiply", "Divide", "Divide", "Divide", "Root", "Sqrt", "Subtract", "Negate", "trig"]);
    return typeof n == "string" ? Rf(n, 1) : n;
  }
  if (e12 === 2) {
    let n = Math.random();
    if (n > 0.75) return vn(1);
    if (n > 0.5) return vn(3);
    let i = Yt(["Multiply", "Multiply", "Add", "Power", "trig", "Ln", "Exp"]);
    return Rf(i, 2);
  }
  return Yt([-12345e-9, -2, -2, -2, -3, -5, -6, -12, -1654e-60, 0, 0, 12345e-8, 1654e-60, 1, 2, 2, 2, 2, 3, 3, 5, 5, 6, 6, 1234.5678, 5678.1234, 10, 15, 18, 30, 60, 1234e54, "123456789.12345678912345e200", "987654321.12345678912345", ["Rational", -6, 10], ["Rational", -12, 15], ["Rational", -15, 12], ["Rational", 3, 5], ["Rational", 12, 15], ["Rational", 15, 12], "ExponentialE", ["Sqrt", 3], ["Sqrt", 5], ["Sqrt", 15], ["Sqrt", 25], ["Complex", -1.1, 1.1], ["Complex", 4, 5], "x", "x", "x", "x", ["Add", "x", 1], ["Divide", "x", 3], ["Square", "x"], ["Power", "x", 3], ["Power", "x", 4], ["Subtract", "x", 1], ["Add", "x", 1], "Pi"]);
}
var Mf = [{ Nothing: { type: "nothing" } }, { InvisibleOperator: { complexity: 9e3, lazy: true, signature: "...any -> any", canonical: (e12, { engine: n }) => {
  let i = ss(e12, { engine: n });
  return i ? i.operator === "Multiply" ? pe(n, i.ops) : i : n.Nothing;
} }, Sequence: { lazy: true, signature: "...any -> any", type: (e12) => e12.length === 0 ? "nothing" : e12.length === 1 ? e12[0].type : "any", canonical: (e12, { engine: n }) => {
  let i = J(e12);
  return i.length === 0 ? n.Nothing : i.length === 1 ? i[0] : n._fn("Sequence", i);
} }, Delimiter: { complexity: 9e3, lazy: true, signature: "(any, string?) -> any", type: (e12) => e12.length === 0 ? "nothing" : e12[0].type, canonical: (e12, { engine: n }) => {
  var _a2, _b;
  if (e12.length === 0) return n._fn("Tuple", []);
  if (e12.length > 2) return n._fn("Delimiter", qe(n, e12, 2));
  let i = e12[0];
  if (i.operator === "Sequence") return n._fn("Tuple", Fe(n, i.ops));
  i = i.canonical;
  let t = (_a2 = e12[1]) == null ? void 0 : _a2.string;
  return !t || t.startsWith("(") && t.endsWith(")") ? i : ((_b = t == null ? void 0 : t.length) != null ? _b : 0) > 3 ? n._fn("Delimiter", [i, n.error("invalid-delimiter", e12[1].toString())]) : n._fn("Delimiter", [e12[0], In(n, e12[1], "string")]);
}, evaluate: (e12, n) => {
  let i = n.engine;
  if (e12.length === 0) return i.Nothing;
  let t = e12[0];
  return (t.operator === "Sequence" || t.operator === "Delimiter") && (e12 = Cs(e12[0].ops)), e12.length === 1 ? e12[0].evaluate(n) : i._fn("Tuple", e12.map((r) => r.evaluate(n)));
} }, Error: { lazy: true, complexity: 500, signature: "((string|expression), expression?) -> nothing", canonical: (e12, { engine: n }) => n._fn("Error", e12) }, ErrorCode: { complexity: 500, lazy: true, signature: "(string, ...any) -> error", canonical: (e12, { engine: n }) => {
  let i = In(n, e12[0], "string").string;
  return i === "incompatible-type" ? n._fn("ErrorCode", [n.string(i), e12[1], e12[2]]) : n._fn("ErrorCode", e12);
} }, Unevaluated: { description: "Prevent an expression from being evaluated", lazy: false, signature: "any -> any", type: ([e12]) => e12.type, evaluate: ([e12]) => e12 }, Hold: { description: "Hold an expression, preventing it from being canonicalized or evaluated until `ReleaseHold` is applied to it", lazy: true, signature: "any -> unknown", type: ([e12]) => {
  var _a2;
  return e12.symbol ? "symbol" : e12.string ? "string" : e12.isNumberLiteral ? e12.type : e12.ops ? (_a2 = Kn(e12.type.type)) != null ? _a2 : "unknown" : "unknown";
}, eq: (e12, n) => (n.operator === "Hold" && (n = n.ops[0]), e12.ops[0].isSame(n)), canonical: (e12, { engine: n }) => e12.length !== 1 ? null : n.hold(e12[0]), evaluate: ([e12], { engine: n }) => n.hold(e12) }, ReleaseHold: { description: "Release an expression held by `Hold`", lazy: true, signature: "any -> any", type: ([e12]) => e12.type, evaluate: ([e12], n) => e12.operator === "Hold" ? e12.ops[0].evaluate(n) : e12.evaluate(n) }, HorizontalSpacing: { signature: "number -> nothing", canonical: (e12, { engine: n }) => e12.length === 2 ? e12[0].canonical : n.Nothing }, Style: { complexity: 9e3, signature: "(expression, map) -> expression", lazy: true, type: ([e12]) => e12.type, canonical: ([e12, n], { engine: i }) => (e12 = e12.canonical, n = vo(i, n), n.nops === 0 ? e12 : i._fn("Style", [e12, n])), evaluate: ([e12, n], i) => e12.evaluate(i) } }, { About: { description: "Return information about an expression", lazy: true, signature: "any -> string", evaluate: ([e12], { engine: n }) => {
  let i = [e12.toString()];
  if (i.push(""), e12.string) i.push("string");
  else if (e12.symbol) if (e12.symbolDefinition) {
    let t = e12.symbolDefinition;
    t.isConstant && i.push("constant"), t.isFunction && i.push("function"), typeof t.description == "string" ? i.push(t.description) : Array.isArray(t.description) && i.push(t.description.join(`
`)), t.wikidata && i.push(`WikiData: ${t.wikidata}`), t.url && i.push(`Read More: ${t.url}`);
  } else i.push("symbol"), i.push(`value: ${e12.evaluate().toString()}`);
  else e12.isNumberLiteral ? i.push(e12.type.toString()) : e12.ops ? (i.push(e12.type.toString()), i.push(e12.isCanonical ? "canonical" : "non-canonical")) : i.push("Unknown expression's type");
  return n.string(i.join(`
`));
} }, Head: { description: "Return the head of an expression, the name of the operator", lazy: true, signature: "any -> symbol", canonical: (e12, { engine: n }) => {
  if (e12.length !== 1) return null;
  let i = e12[0];
  return i.operator ? n.box(i.operator) : n._fn("Head", Fe(n, e12));
}, evaluate: (e12, { engine: n }) => {
  var _a2, _b;
  return n.symbol((_b = (_a2 = e12[0]) == null ? void 0 : _a2.operator) != null ? _b : "Undefined");
} }, Tail: { description: "Return the tail of an expression, the operands of the expression", lazy: true, signature: "any -> collection", canonical: (e12, { engine: n }) => {
  if (e12.length !== 1) return null;
  let i = e12[0];
  return i.ops ? n._fn("Sequence", i.ops) : n._fn("Tail", Fe(n, e12));
}, evaluate: ([e12], { engine: n }) => (e12 == null ? void 0 : e12.ops) ? n._fn("Sequence", e12.ops) : n.Nothing }, Identity: { description: "Return the argument unchanged", signature: "any -> any", type: ([e12]) => e12.type, evaluate: ([e12]) => e12 } }, { Apply: { description: "Apply a function to a list of arguments", signature: "(name:symbol, arguments:...expression) -> any", type: ([e12]) => {
  var _a2;
  return (_a2 = Kn(e12.type.type)) != null ? _a2 : "any";
}, canonical: (e12, { engine: n }) => e12[0].symbol ? n.function(e12[0].symbol, e12.slice(1)) : n._fn("Apply", e12), evaluate: (e12) => Qi(e12[0], e12.slice(1)) }, Assign: { description: "Assign a value to a symbol", lazy: true, pure: false, signature: "(symbol, any) -> any", type: ([e12, n]) => n.type, canonical: (e12, { engine: n }) => {
  if (e12.length !== 2) return null;
  let i = e12[0];
  if (!i.symbol) return null;
  let t = e12[1];
  return n._fn("Assign", [i.canonical, t.canonical]);
}, evaluate: ([e12, n], { engine: i }) => {
  let t = n.evaluate();
  return i.assign(e12.symbol, t), t;
} }, Assume: { description: "Assume a type for a symbol", lazy: true, pure: false, signature: "any -> symbol", evaluate: (e12, { engine: n }) => n.symbol(n.assume(e12[0])) }, Declare: { lazy: true, pure: false, signature: "symbol -> any", type: ([e12, n]) => n.type, canonical: (e12, { engine: n }) => {
  if (e12.length !== 2) return null;
  let i = e12[0], t = e12[1];
  return i.symbol ? t.symbol ? n._fn("Declare", e12) : n._fn("Declare", [i, n._fn("Hold", [t])]) : null;
}, evaluate: (e12, { engine: n }) => {
  let i = e12[0], t = e12[1];
  if (!i.symbol) return n.Nothing;
  let r = t.evaluate();
  if (!r.string) return;
  let s = k(r.string);
  if (Sn(s)) return n.declare(i.symbol, s), r;
} }, Type: { lazy: true, signature: "any -> string", evaluate: ([e12], { engine: n }) => {
  var _a2;
  return n.string((_a2 = e12.type.toString()) != null ? _a2 : "unknown");
} }, Evaluate: { lazy: true, signature: "any -> any", type: ([e12]) => e12.type, canonical: (e12, { engine: n }) => n._fn("Evaluate", qe(n, e12, 1)), evaluate: ([e12], n) => e12.evaluate(n) }, Function: { complexity: 9876, lazy: true, signature: "function", type: ([e12, ...n]) => `(${n.map((i) => i.type)}) -> ${e12.type.type}`, canonical: (e12, { engine: n }) => {
  if (e12.length === 0) return n.Nothing;
  let i = $r(e12[0], e12.slice(1));
  if (!i) return null;
  let t = i[0].canonical, r = i.slice(1).map((s) => n.symbol(s));
  return r.length === 0 ? t : n._fn("Function", [t, ...r]);
}, evaluate: (e12) => {
} }, Simplify: { lazy: true, signature: "any -> expression", canonical: (e12, { engine: n }) => n._fn("Simplify", qe(n, e12, 1)), evaluate: ([e12]) => {
  var _a2;
  return (_a2 = e12.simplify()) != null ? _a2 : void 0;
} }, CanonicalForm: { description: ["Return the canonical form of an expression", "Can be used to sort arguments of an expression.", 'Sorting arguments of commutative functions is a weak form of canonicalization that can be useful in some cases, for example to accept "x+1" and "1+x" while rejecting "x+1" and "2x-x+1"'], complexity: 8200, lazy: true, signature: "(any, ...symbol) -> any", canonical: (e12) => {
  if (e12.length === 1) return e12[0].canonical;
  let n = e12.slice(1).map((i) => {
    var _a2;
    return (_a2 = i.symbol) != null ? _a2 : i.string;
  }).filter((i) => i != null);
  return Ei(e12[0], n);
} }, N: { description: "Numerically evaluate an expression", lazy: true, signature: "any -> any", type: ([e12]) => e12.type, canonical: (e12, { engine: n }) => {
  if (e12.length !== 1) return n._fn("N", qe(n, e12, 1));
  let i = e12[0].operator;
  if (i === "N") return e12[0].canonical;
  if (i === "Integrate") {
    let { index: t, lower: r, upper: s } = nt(e12[0].op2);
    if (!t || r === void 0 || s === void 0) return null;
    let o = e12[0].op1;
    return n._fn("NIntegrate", [n.function("Function", [o, t]), n.number(r), n.number(s)]);
  }
  return i === "Limit" ? n._fn("NLimit", e12[0].ops) : n._fn("N", e12);
}, evaluate: ([e12]) => e12.N() }, Random: { description: ["Random(): Return a random number between 0 and 1", "Random(n): Return a random integer between 0 and n-1", "Random(m, n): Return a random integer between m and n-1"], pure: false, signature: "(lower:integer?, upper:integer?) -> finite_number", type: ([e12, n]) => e12 === void 0 && n === void 0 ? "finite_number" : "finite_integer", sgn: () => "non-negative", evaluate: (e12, { engine: n }) => {
  if (e12.length === 0) return n.number(Math.random());
  let [i, t] = e12, r, s;
  return t === void 0 ? (r = 0, s = Math.floor(i.re - 1), isNaN(s) && (s = 0)) : (r = Math.floor(i.re), s = Math.floor(t.re), isNaN(r) && (r = 0), isNaN(s) && (s = 0)), n.number(r + Math.floor(Math.random() * (s - r)));
} }, Signature: { lazy: true, signature: "symbol -> string | nothing", evaluate: ([e12], { engine: n }) => e12.functionDefinition ? n.string(e12.functionDefinition.signature.toString()) : n.Nothing }, Subscript: { lazy: true, signature: "(collection|string, any) -> any", type: ([e12, n]) => {
  var _a2;
  return e12.string && G(n) !== null ? "integer" : e12.isCollection && si(e12) ? (_a2 = ei(e12.type.type)) != null ? _a2 : "any" : e12.symbol ? "symbol" : "expression";
}, canonical: ([e12, n], { engine: i }) => {
  var _a2, _b, _c2;
  if (e12 = e12.canonical, e12.string) {
    let t = G(n.canonical);
    if (t !== null && t > 1 && t <= 36) {
      let [r, s] = Vi(e12.string, t);
      return s ? i.error(["unexpected-digit", s[0]], e12.toString()) : i.number(r);
    }
    return i._fn("Baseform", [e12, i.error(["invalid-base", n.toString()])]);
  }
  if (e12.isCollection && si(e12)) return i._fn("At", [e12, n.canonical]);
  if (e12.symbol) {
    let t = (_c2 = (_a2 = n.string) != null ? _a2 : n.symbol) != null ? _c2 : (_b = G(n)) == null ? void 0 : _b.toString();
    if (t) return i.symbol(e12.symbol + "_" + t);
  }
  return n.operator === "Sequence" && i._fn("Subscript", [e12, i._fn("List", n.ops)]), i._fn("Subscript", [e12, n]);
} }, Symbol: { complexity: 500, description: "Construct a new symbol with a name formed by concatenating the arguments", threadable: true, lazy: true, signature: "...any -> any", type: (e12) => e12.length === 0 ? "nothing" : "symbol", canonical: (e12, { engine: n }) => {
  if (e12.length === 0) return n.Nothing;
  let i = e12.map((t) => {
    var _a2, _b, _c2, _d2;
    return (_d2 = (_c2 = (_a2 = t.symbol) != null ? _a2 : t.string) != null ? _c2 : (_b = G(t)) == null ? void 0 : _b.toString()) != null ? _d2 : "";
  }).join("");
  return i.length > 0 ? n.symbol(i) : n.Nothing;
} }, Timing: { description: "`Timing(expr)` evaluates `expr` and return a `Pair` of the number of second elapsed for the evaluation, and the value of the evaluation", signature: "(value, repeat: integer?) -> tuple<result:value, time:number>", evaluate: (e12, { engine: n }) => {
  var _a2;
  if (e12[1].symbol === "Nothing") {
    let u = globalThis.performance.now(), l = e12[0].evaluate(), f = 1e3 * (globalThis.performance.now() - u);
    return n.tuple(n.number(f), l);
  }
  let i = Math.max(3, Math.round((_a2 = G(e12[1])) != null ? _a2 : 3)), t = [], r;
  for (; i > 0; ) {
    let u = globalThis.performance.now();
    r = e12[0].evaluate(), t.push(1e3 * (globalThis.performance.now() - u)), i -= 1;
  }
  let s = Math.max(...t), o = Math.min(...t);
  t = t.filter((u) => u > o && u < s);
  let a = t.reduce((u, l) => u + l, 0);
  return a === 0 ? n.tuple(n.number(s), r) : n.tuple(n.number(a / t.length), r);
} } }, { Wildcard: { signature: "symbol -> symbol", canonical: (e12, { engine: n }) => e12.length !== 1 ? n.symbol("_") : n.symbol("_" + e12[0].symbol) }, WildcardSequence: { signature: "symbol -> symbol", canonical: (e12, { engine: n }) => e12.length !== 1 ? n.symbol("__") : n.symbol("__" + e12[0].symbol) }, WildcardOptionalSequence: { signature: "symbol -> symbol", canonical: (e12, { engine: n }) => e12.length !== 1 ? n.symbol("___") : n.symbol("___" + e12[0].symbol) } }, { LatexString: { description: "Value preserving type conversion/tag indicating the string is a LaTeX string", signature: "string -> string", evaluate: ([e12]) => e12 }, Latex: { description: "Serialize an expression to LaTeX", signature: "...any -> string", evaluate: (e12, { engine: n }) => n.box(["LatexString", n.string(b(e12.map((i) => i.latex)))]) }, Parse: { description: "Parse a LaTeX string and evaluate to a corresponding expression", signature: "string -> any", evaluate: ([e12], { engine: n }) => {
  var _a2;
  return (_a2 = n.parse(e12.string)) != null ? _a2 : n.Nothing;
} } }, { RandomExpression: { signature: "() -> expression", evaluate: (e12, { engine: n }) => n.box(vn()) } }];
var Cf = [{ Matrix: { complexity: 9e3, lazy: true, signature: "(matrix, string?, string?) -> matrix", type: ([e12]) => e12.type, canonical: am, evaluate: (e12, n) => e12[0].evaluate(n) }, Vector: { complexity: 9e3, lazy: true, signature: "...number -> vector", type: (e12) => k(`vector<${e12.length}>`), canonical: (e12, { engine: n }) => n._fn("Matrix", [n.function("List", e12.map((i) => n.function("List", [i])))]) } }, { Shape: { complexity: 8200, signature: "(value) -> tuple", evaluate: (e12, { engine: n }) => {
  let i = e12[0];
  return Oe(i) ? n.tuple(...i.tensor.shape) : n.tuple();
} }, Rank: { description: "The length of the shape of the expression. Note this is not the matrix rank (the number of linearly independent rows or columns in the matrix)", complexity: 8200, signature: "(value) -> number", sgn: () => "positive", evaluate: (e12, { engine: n }) => {
  let i = e12[0];
  return Oe(i) ? n.number(i.tensor.rank) : n.Zero;
} }, Reshape: { complexity: 8200, signature: "(list<number>, tuple) -> value", type: ([e12, n]) => {
  if (!e12.type.matches("list")) return "nothing";
  let i = e12.type.type;
  return v(i.elements, "number") ? k(`list<number^${n.ops.map((t) => t.toString()).join("x")}>`) : "nothing";
}, evaluate: (e12, { engine: n }) => {
  var _a2, _b;
  let i = e12[0], t = (_b = (_a2 = e12[1].ops) == null ? void 0 : _a2.map((r) => r.value)) != null ? _b : [];
  if (!Oe(i) && ie(i) && (i = n.function("List", [...ee(i)])), Oe(i)) return t.join("x") === i.tensor.shape.join("x") ? i : i.tensor.reshape(...t).expression;
} }, Flatten: { complexity: 8200, signature: "(value) -> list", evaluate: (e12, { engine: n }) => {
  let i = e12[0];
  if (Oe(i)) return n.box(["List", ...i.tensor.flatten().map((t) => n.box(t))]);
  if (ie(i)) return n.function("List", [...ee(i)]);
} }, Transpose: { complexity: 8200, signature: "(matrix|vector, axis1: integer?, axis2: integer?) -> matrix", evaluate: (e12, { engine: n }) => {
  var _a2, _b;
  let i = e12[0], t = 1, r = 2;
  if (e12.length === 3 && (t = e12[1].value, r = e12[2].value, t > 0 && r > 0), t !== r && (!Oe(i) && ie(i) && (i = n.function("List", [...ee(i)])), Oe(i))) return t === 1 && r === 2 ? (_a2 = i.tensor.transpose()) == null ? void 0 : _a2.expression : (_b = i.tensor.transpose(t, r)) == null ? void 0 : _b.expression;
} }, ConjugateTranspose: { complexity: 8200, signature: "(tensor, axis1: integer?, axis2: integer?) -> matrix", evaluate: (e12) => {
  var _a2;
  let n = e12[0], i = 1, t = 2;
  if (e12.length === 3 && (i = e12[1].value, t = e12[2].value, i > 0 && t > 0), i !== t && Oe(n)) return (_a2 = n.tensor.conjugateTranspose(i, t)) == null ? void 0 : _a2.expression;
} }, Determinant: { complexity: 8200, signature: "(matrix) -> number", evaluate: (e12) => {
  let n = e12[0];
  if (Oe(n)) return n.tensor.determinant();
} }, Inverse: { complexity: 8200, signature: "(matrix) -> matrix", type: ([e12]) => e12.type, evaluate: ([e12]) => {
  var _a2;
  if (Oe(e12)) return (_a2 = e12.tensor.inverse()) == null ? void 0 : _a2.expression;
} }, PseudoInverse: { complexity: 8200, signature: "(matrix) -> matrix", evaluate: ([e12]) => {
  var _a2;
  if (Oe(e12)) return (_a2 = e12.tensor.pseudoInverse()) == null ? void 0 : _a2.expression;
} }, AdjugateMatrix: { complexity: 8200, signature: "(matrix) -> matrix", evaluate: (e12) => {
  var _a2;
  let n = e12[0];
  if (Oe(n)) return (_a2 = n.tensor.adjugateMatrix()) == null ? void 0 : _a2.expression;
} }, Trace: { complexity: 8200, signature: "(matrix) -> number", evaluate: (e12) => {
  let n = e12[0];
  if (Oe(n)) return n.tensor.trace();
} } }];
function am(e12, { engine: n }) {
  var _a2, _b;
  let i = "Matrix";
  if (e12.length === 0) return n._fn(i, []);
  let t = e12[0].operator === "Vector" ? e12[0].canonical.ops[0] : e12[0].canonical, r = (_a2 = e12[1]) == null ? void 0 : _a2.canonical, s = (_b = e12[2]) == null ? void 0 : _b.canonical;
  return e12.length > 3 ? n._fn(i, qe(n, e12, 3)) : s ? n._fn(i, [t, r, s]) : r ? n._fn(i, [t, r]) : n._fn(i, [t]);
}
var Pf = { True: { wikidata: "Q16751793", type: "boolean", constant: true }, False: { wikidata: "Q5432619", type: "boolean", constant: true }, And: { wikidata: "Q191081", threadable: true, associative: true, commutative: true, idempotent: true, complexity: 1e4, signature: "(boolean, ...boolean) -> boolean", evaluate: Of }, Or: { wikidata: "Q1651704", threadable: true, associative: true, commutative: true, idempotent: true, complexity: 1e4, signature: "(boolean, ...boolean) -> boolean", evaluate: Lf }, Not: { wikidata: "Q190558", threadable: true, involution: true, complexity: 10100, signature: "boolean -> boolean", evaluate: Ff }, Equivalent: { wikidata: "Q220433", threadable: true, complexity: 10200, signature: "(boolean, boolean) -> boolean", canonical: (e12, { engine: n }) => {
  let i = e12[0].symbol, t = e12[1].symbol;
  return i === "True" && t === "True" || i === "False" && t === "False" ? n.True : i === "True" && t === "False" || i === "False" && t === "True" ? n.False : n._fn("Equivalent", e12);
}, evaluate: qf }, Implies: { wikidata: "Q7881229", threadable: true, complexity: 10200, signature: "(boolean, boolean) -> boolean", evaluate: $f }, Exists: { signature: "function", lazy: true }, NotExists: { signature: "function", lazy: true }, ExistsUnique: { signature: "function", lazy: true }, ForAll: { signature: "function", lazy: true }, NotForAll: { signature: "function", lazy: true }, KroneckerDelta: { description: "Return 1 if the arguments are equal, 0 otherwise", signature: "(value, ...value) -> integer", evaluate: (e12, { engine: n }) => {
  if (e12.length === 1) return e12[0].symbol === "True" ? n.One : n.Zero;
  if (e12.length === 2) return e12[0].isEqual(e12[1]) ? n.One : n.Zero;
  for (let i = 1; i < e12.length; i++) if (!e12[i].isEqual(e12[0])) return n.Zero;
  return n.One;
} }, Boole: { description: "Return 1 if the argument is true, 0 otherwise. Also known as the Iverson bracket", signature: "boolean -> integer", evaluate: (e12, { engine: n }) => e12[0].symbol === "True" ? n.One : n.Zero } };
function Of(e12, { engine: n }) {
  if (e12.length === 0) return n.True;
  let i = [];
  for (let t of e12) {
    if (t.symbol === "False") return n.False;
    if (t.symbol !== "True") {
      let r = false;
      for (let s of i) if (s.isSame(t)) r = true;
      else if (t.operator === "Not" && t.op1.isSame(s) || s.operator === "Not" && s.op1.isSame(t)) return n.False;
      r || i.push(t);
    }
  }
  return i.length === 0 ? n.True : i.length === 1 ? i[0] : n._fn("And", i);
}
function Lf(e12, { engine: n }) {
  if (e12.length === 0) return n.True;
  let i = [];
  for (let t of e12) {
    if (t.symbol === "True") return n.True;
    if (t.symbol !== "False") {
      let r = false;
      for (let s of i) if (s.isSame(t)) r = true;
      else if (t.operator === "Not" && t.op1.isSame(s) || s.operator === "Not" && s.op1.isSame(t)) return n.True;
      r || i.push(t);
    }
  }
  return i.length === 0 ? n.False : i.length === 1 ? i[0] : n._fn("Or", i);
}
function Ff(e12, { engine: n }) {
  var _a2;
  let i = (_a2 = e12[0]) == null ? void 0 : _a2.symbol;
  if (i === "True") return n.False;
  if (i === "False") return n.True;
}
function qf(e12, { engine: n }) {
  let i = e12[0].symbol, t = e12[1].symbol;
  if (i === "True" && t === "True" || i === "False" && t === "False") return n.True;
  if (i === "True" && t === "False" || i === "False" && t === "True") return n.False;
}
function $f(e12, { engine: n }) {
  let i = e12[0].symbol, t = e12[1].symbol;
  if (i === "True" && t === "True" || i === "False" && t === "False" || i === "False" && t === "True") return n.True;
  if (i === "True" && t === "False") return n.False;
}
function Vf(e12) {
  var _a2, _b;
  let n = (_b = (_a2 = { And: Of, Or: Lf, Not: Ff, Equivalent: qf, Implies: $f })[e12.operator]) == null ? void 0 : _b.call(_a2, e12.engine, e12.ops);
  if (n) return { value: n, because: "logic" };
}
function Yo(e12, n, i, t) {
  let r = e12.engine;
  return e12.operator === i ? r.box([t, ...e12.ops.map((s) => Yo(s, n, i, t))]) : n.operator === i ? r.box([t, ...n.ops.map((s) => Yo(e12, s, i, t))]) : r.box([t, e12, n]);
}
function zf(e12, n = "Add", i = "Multiply") {
  if (e12.operator !== i) return e12;
  let t = e12.ops;
  return !t || t.length < 2 ? e12 : e12.engine.box([n, t.slice(1).reduce((r, s) => Yo(r, s, n, i), t[0])]);
}
var Gf = [{ Expand: { description: "Expand out products and positive integer powers", lazy: true, signature: "(value)-> value", evaluate: ([e12]) => {
  var _a2;
  return (_a2 = Pe(e12.canonical)) != null ? _a2 : e12;
} }, ExpandAll: { description: "Recursively expand out products and positive integer powers", lazy: true, signature: "(value)-> value", evaluate: ([e12]) => {
  var _a2;
  return (_a2 = ol(e12)) != null ? _a2 : e12;
} }, Factor: { description: "Factors an algebraic expression into a product of irreducible factors", lazy: true, signature: "(value)-> value", evaluate: ([e12]) => Yn(e12.canonical) }, Together: { description: "Combine rational expressions into a single fraction", lazy: true, signature: "(value)-> value", evaluate: ([e12]) => Wt(e12) }, Distribute: { description: "Distribute multiplication over addition", lazy: true, signature: "(value)-> value", evaluate: ([e12]) => e12 && zf(e12) } }];
var jf = { Congruent: { description: "Indicate that two expressions are congruent modulo a number", complexity: 11e3, signature: "(number, number, modulo: integer) -> boolean", evaluate: (e12, { engine: n }) => {
  if (e12.length < 3) return;
  let [i, t, r] = e12, s = i.value, o = t.value, a = r.value;
  if (typeof s == "number" && typeof o == "number" && typeof a == "number") return s % a === o % a ? n.True : n.False;
} }, IsSame: { description: "Compare two expressions for structural equality", lazy: true, signature: "(any, any) -> boolean", evaluate: (e12, { engine: n }) => {
  if (e12.length !== 2) return;
  let [i, t] = e12;
  return i.isSame(t) ? n.True : n.False;
} }, Equal: { complexity: 11e3, signature: "(any, any) -> boolean", lazy: true, canonical: (e12, { engine: n }) => re(n, "Equal", e12), eq: (e12, n) => e12.operator !== n.operator ? false : e12.op1.sub(e12.op2).N().isEqual(n.op1.sub(n.op2).N()), evaluate: (e12, { engine: n }) => {
  if (e12.length < 2) return n.True;
  let i;
  for (let t of e12) if (!i) i = t;
  else if (qr(i, t) !== true) return n.False;
  return n.True;
} }, NotEqual: { wikidata: "Q28113351", complexity: 11e3, signature: "(any, any) -> boolean", canonical: (e12, { engine: n }) => re(n, "NotEqual", e12), eq: (e12, n) => e12.operator !== n.operator ? false : !!(e12.op1.isEqual(n.op1) && e12.op2.isEqual(n.op2) || e12.op1.isEqual(n.op2) && e12.op2.isEqual(n.op1)), evaluate: (e12, { engine: n }) => {
  if (e12.length < 2) return n.False;
  let i;
  for (let t of e12) if (!i) i = t;
  else if (i.isEqual(t) === true) return n.False;
  return n.True;
} }, Less: { complexity: 11e3, signature: "(any, any, ...any) -> boolean", canonical: (e12, { engine: n }) => re(n, "Less", e12), eq: (e12, n) => Uf(e12, n, "Greater"), evaluate: (e12, { engine: n }) => {
  if (e12.length === 2) {
    let [t, r] = e12, s = t.isLess(r);
    return s === void 0 ? void 0 : s ? n.True : n.False;
  }
  if (e12.length < 2) return n.True;
  let i;
  for (let t of e12) if (!i) i = t;
  else {
    let r = t.isLess(i);
    if (r === void 0) return;
    if (r === false) return n.False;
    i = t;
  }
  return n.True;
} }, NotLess: { complexity: 11e3, signature: "(any, any, ...any) -> boolean", canonical: (e12, { engine: n }) => n._fn("Not", [re(n, "Less", e12)]) }, Greater: { complexity: 11e3, signature: "(any, any, ...any) -> boolean", canonical: (e12, { engine: n }) => re(n, "Less", [...e12].reverse()) }, NotGreater: { complexity: 11e3, signature: "(any, any, ...any) -> boolean", canonical: (e12, { engine: n }) => n._fn("Not", [n._fn("Greater", e12)]) }, LessEqual: { complexity: 11e3, signature: "(any, any, ...any) -> boolean", canonical: (e12, { engine: n }) => re(n, "LessEqual", e12), eq: (e12, n) => Uf(e12, n, "LessGreater"), evaluate: (e12, { engine: n }) => {
  if (e12.length === 2) {
    let [t, r] = e12, s = t.isLessEqual(r);
    return s === void 0 ? void 0 : s ? n.True : n.False;
  }
  if (e12.length < 2) return n.True;
  let i;
  for (let t of e12) if (!i) i = t;
  else {
    let r = t.isLessEqual(i);
    if (r === void 0) return;
    if (r === false) return n.False;
    i = t;
  }
  return n.True;
} }, NotLessNotEqual: { complexity: 11e3, signature: "(any, any, ...any) -> boolean", canonical: (e12, { engine: n }) => n._fn("Not", [re(n, "LessEqual", e12)]) }, GreaterEqual: { complexity: 11e3, signature: "(any, any, ...any) -> boolean", canonical: (e12, { engine: n }) => re(n, "LessEqual", [...e12].reverse()) }, NotGreaterNotEqual: { complexity: 11e3, signature: "(any, any, ...any) -> boolean", canonical: (e12, { engine: n }) => n._fn("Not", [re(n, "GreaterEqual", e12)]) }, TildeFullEqual: { description: "Indicate isomorphism, congruence and homotopic equivalence", signature: "(any, any, ...any) -> boolean", canonical: (e12, { engine: n }) => re(n, "TildeFullEqual", e12) }, NotTildeFullEqual: { complexity: 11100, signature: "(any, any, ...any) -> boolean", canonical: (e12, { engine: n }) => n._fn("Not", [re(n, "TildeFullEqual", e12)]) }, TildeEqual: { description: "Approximately or asymptotically equal", complexity: 11e3, signature: "(any, any, ...any) -> boolean", canonical: (e12, { engine: n }) => re(n, "TildeEqual", e12) }, NotTildeEqual: { complexity: 11100, signature: "(any, any, ...any) -> boolean", canonical: (e12, { engine: n }) => n._fn("Not", [re(n, "TildeEqual", e12)]) }, Approx: { complexity: 11100, signature: "(any, any, ...any) -> boolean", canonical: (e12, { engine: n }) => re(n, "Approx", e12) }, NotApprox: { complexity: 11100, signature: "(any, any, ...any) -> boolean", canonical: (e12, { engine: n }) => n._fn("Not", [re(n, "Approx", e12)]) }, ApproxEqual: { complexity: 11100, signature: "(any, any, ...any) -> boolean", canonical: (e12, { engine: n }) => re(n, "ApproxEqual", e12) }, NotApproxEqual: { complexity: 11100, canonical: (e12, { engine: n }) => n._fn("Not", [re(n, "ApproxEqual", e12)]) }, ApproxNotEqual: { complexity: 11100, signature: "(any, any, ...any) -> boolean", canonical: (e12, { engine: n }) => re(n, "ApproxNotEqual", e12) }, NotApproxNotEqual: { complexity: 11100, signature: "(any, any, ...any) -> boolean", canonical: (e12, { engine: n }) => n._fn("Not", [re(n, "ApproxNotEqual", e12)]) }, Precedes: { complexity: 11100, signature: "(any, any, ...any) -> boolean", canonical: (e12, { engine: n }) => re(n, "Precedes", e12) }, NotPrecedes: { complexity: 11100, signature: "(any, any, ...any) -> boolean", canonical: (e12, { engine: n }) => n._fn("Not", [re(n, "Precedes", e12)]) }, Succeeds: { signature: "(any, any, ...any) -> boolean", canonical: (e12, { engine: n }) => re(n, "Succeeds", e12) }, NotSucceeds: { complexity: 11100, signature: "(any, any, ...any) -> boolean", canonical: (e12, { engine: n }) => n._fn("Not", [re(n, "Succeeds", e12)]) } };
function re(e12, n, i) {
  i = J(i, n);
  let t = [], r = [];
  for (let s of i) we(s) ? (t.push(s), r.push(s.ops[s.ops.length - 1])) : r.push(s);
  return t.length === 0 ? e12._fn(n, r) : e12._fn("And", [e12._fn(n, r), ...t]);
}
function Uf(e12, n, i) {
  return e12.operator === n.operator ? e12.nops !== n.nops ? false : e12.ops.every((t, r) => t.isEqual(n.ops[r])) : n.operator === i ? e12.nops !== n.nops ? false : e12.ops.every((t, r) => t.isEqual(n.ops[n.nops - 1 - r])) : false;
}
var Zf = { EmptySet: { type: "set", constant: true, wikidata: "Q226183", eq: (e12) => e12.type.matches("set") && e12.size === 0, collection: { size: () => 0, contains: () => false, subsetOf: () => true, eltsgn: () => {
}, elttype: () => "never" } }, Numbers: { type: "set<number>", constant: true, collection: { size: () => 1 / 0, contains: (e12, n) => n.type.matches("number"), subsetOf: (e12, n, i) => n.operator === "Range" || n.operator === "Linspace" ? true : n.type.matches("set<number>") && (!i || n.symbol !== "Numbers"), eltsgn: () => "unsigned", elttype: () => "number" } }, ComplexNumbers: { type: "set<finite_complex>", constant: true, collection: { size: () => 1 / 0, contains: (e12, n) => n.type.matches("finite_complex"), subsetOf: (e12, n, i) => n.operator === "Range" || n.operator === "Linspace" ? true : n.type.matches("set<complex>") && (!i || n.symbol !== "ComplexNumbers"), eltsgn: () => "unsigned", elttype: () => "finite_complex" } }, ExtendedComplexNumbers: { type: "set<complex>", constant: true, collection: { size: () => 1 / 0, contains: (e12, n) => n.type.matches("complex"), subsetOf: (e12, n, i) => n.operator === "Range" || n.operator === "Linspace" ? true : n.type.matches("set<complex>") && (!i || n.symbol !== "ComplexNumbers"), eltsgn: () => "unsigned", elttype: () => "complex" } }, ImaginaryNumbers: { type: "set<imaginary>", constant: true, collection: { size: () => 1 / 0, contains: (e12, n) => n.type.matches("imaginary"), subsetOf: (e12, n, i) => n.type.matches("set<imaginary>") && (!i || n.symbol !== "ImaginaryNumbers"), eltsgn: () => "unsigned", elttype: () => "imaginary" } }, RealNumbers: { type: "set<finite_real>", constant: true, collection: { contains: (e12, n) => n.type.matches("finite_real"), size: () => 1 / 0, subsetOf: (e12, n, i) => n.type.matches("set<real>") && (!i || n.symbol !== "RealNumbers"), eltsgn: () => {
}, elttype: () => "finite_real" } }, ExtendedRealNumbers: { type: "set<real>", constant: true, collection: { contains: (e12, n) => n.type.matches("real"), size: () => 1 / 0, subsetOf: (e12, n, i) => n.type.matches("set<real>") && (!i || n.symbol !== "ExtendedRealNumbers"), eltsgn: () => {
}, elttype: () => "real" } }, Integers: { type: "set<finite_integer>", constant: true, collection: { contains: (e12, n) => n.type.matches("finite_integer"), size: () => 1 / 0, subsetOf: (e12, n, i) => n.operator === "Range" ? true : n.type.matches("set<finite_integer>") && (!i || n.symbol !== "Integers"), eltsgn: () => {
}, elttype: () => "finite_integer" } }, ExtendedIntegers: { type: "set<integer>", constant: true, collection: { contains: (e12, n) => n.type.matches("integer"), size: () => 1 / 0, subsetOf: (e12, n, i) => n.operator === "Range" ? true : n.type.matches("set<integer>") && (!i || n.symbol !== "ExtendedIntegers"), eltsgn: () => {
}, elttype: () => "integer" } }, RationalNumbers: { type: "set<finite_rational>", constant: true, collection: { size: () => 1 / 0, contains: (e12, n) => n.type.matches("finite_rational"), subsetOf: (e12, n, i) => n.type.matches("set<rational>") && (!i || n.symbol !== "RationalNumbers"), eltsgn: () => {
}, elttype: () => "finite_rational" } }, ExtendedRationalNumbers: { type: "set<rational>", constant: true, collection: { contains: (e12, n) => n.type.matches("rational"), size: () => 1 / 0, subsetOf: (e12, n, i) => n.type.matches("set<rational>") && (!i || n.symbol !== "ExtendedRationalNumbers"), eltsgn: () => {
}, elttype: () => "rational" } }, NegativeNumbers: { type: "set<real>", constant: true, collection: { size: () => 1 / 0, contains: (e12, n) => n.type.matches("real") && n.isNegative === true, subsetOf: (e12, n, i) => {
  var _a2, _b, _c2;
  if (n.operator === "Range" || n.operator === "Linspace") {
    let t = n.ops[0].re, r = n.ops[1].re;
    return t < 0 && r < 0;
  }
  return n.type.matches("set<real>") && ((_c2 = (_b = (_a2 = n.symbolDefinition) == null ? void 0 : _a2.collection) == null ? void 0 : _b.eltsgn) == null ? void 0 : _c2.call(_b, n)) === "negative" && (!i || n.symbol !== "NegativeNumbers");
}, eltsgn: () => "negative", elttype: () => "real" } }, NonPositiveNumbers: { type: "set<real>", constant: true, collection: { contains: (e12, n) => n.type.matches("real") && n.isNonPositive === true, size: () => 1 / 0, subsetOf: (e12, n, i) => {
  var _a2, _b, _c2;
  if (n.operator === "Range" || n.operator === "Linspace") {
    let t = n.ops[0].re, r = n.ops[1].re;
    return t >= 0 && r >= 0;
  }
  return n.type.matches("set<real>") && ((_c2 = (_b = (_a2 = n.symbolDefinition) == null ? void 0 : _a2.collection) == null ? void 0 : _b.eltsgn) == null ? void 0 : _c2.call(_b, n)) === "non-positive" && (!i || n.symbol !== "NonPositiveNumbers");
}, eltsgn: () => "non-positive", elttype: () => "real" } }, NonNegativeNumbers: { type: "set<real>", constant: true, collection: { contains: (e12, n) => n.type.matches("real") && n.isNonNegative === true, size: () => 1 / 0, subsetOf: (e12, n, i) => {
  var _a2, _b, _c2;
  if (n.operator === "Range" || n.operator === "Linspace") {
    let t = n.ops[0].re, r = n.ops[1].re;
    return t <= 0 && r <= 0;
  }
  return n.type.matches("set<real>") && ((_c2 = (_b = (_a2 = n.symbolDefinition) == null ? void 0 : _a2.collection) == null ? void 0 : _b.eltsgn) == null ? void 0 : _c2.call(_b, n)) === "non-negative" && (!i || n.symbol !== "NonNegativeNumbers");
}, eltsgn: () => "non-negative", elttype: () => "real" } }, PositiveNumbers: { type: "set<real>", constant: true, collection: { contains: (e12, n) => n.type.matches("real") && n.isPositive === true, size: () => 1 / 0, subsetOf: (e12, n, i) => {
  var _a2, _b, _c2;
  if (n.operator === "Range" || n.operator === "Linspace") {
    let t = n.ops[0].re, r = n.ops[1].re;
    return t > 0 && r > 0;
  }
  return n.type.matches("set<real>") && ((_c2 = (_b = (_a2 = n.symbolDefinition) == null ? void 0 : _a2.collection) == null ? void 0 : _b.eltsgn) == null ? void 0 : _c2.call(_b, n)) === "positive" && (!i || n.symbol !== "PositiveNumbers");
}, eltsgn: () => "positive", elttype: () => "real" } }, NegativeIntegers: { type: "set<integer>", constant: true, collection: { contains: (e12, n) => n.type.matches("integer") && n.isNegative === true, size: () => 1 / 0, subsetOf: (e12, n, i) => {
  var _a2, _b, _c2;
  if (n.operator === "Range") {
    let t = n.ops[0].re, r = n.ops[1].re;
    return t < 0 && r < 0;
  }
  return n.type.matches("set<integer>") && ((_c2 = (_b = (_a2 = n.symbolDefinition) == null ? void 0 : _a2.collection) == null ? void 0 : _b.eltsgn) == null ? void 0 : _c2.call(_b, n)) === "negative" && (!i || n.symbol !== "NegativeIntegers");
}, eltsgn: () => "negative", elttype: () => "integer" } }, NonPositiveIntegers: { type: "set<integer>", constant: true, collection: { contains: (e12, n) => n.type.matches("integer") && n.isNonPositive === true, size: () => 1 / 0, subsetOf: (e12, n, i) => {
  var _a2, _b, _c2;
  if (n.operator === "Range") {
    let t = n.ops[0].re, r = n.ops[1].re;
    return t <= 0 && r <= 0;
  }
  return n.type.matches("set<integer>") && ((_c2 = (_b = (_a2 = n.symbolDefinition) == null ? void 0 : _a2.collection) == null ? void 0 : _b.eltsgn) == null ? void 0 : _c2.call(_b, n)) === "non-positive" && (!i || n.symbol !== "NonPositiveIntegers");
}, eltsgn: () => "non-positive", elttype: () => "integer" } }, NonNegativeIntegers: { type: "set<integer>", constant: true, collection: { contains: (e12, n) => n.type.matches("integer") && n.isNonNegative === true, size: () => 1 / 0, subsetOf: (e12, n, i) => {
  var _a2, _b, _c2;
  if (n.operator === "Range") {
    let t = n.ops[0].re, r = n.ops[1].re;
    return t > 0 && r > 0;
  }
  return n.type.matches("set<integer>") && ((_c2 = (_b = (_a2 = n.symbolDefinition) == null ? void 0 : _a2.collection) == null ? void 0 : _b.eltsgn) == null ? void 0 : _c2.call(_b, n)) === "non-negative" && (!i || n.symbol !== "NonNegativeIntegers");
}, eltsgn: () => "non-negative", elttype: () => "integer" } }, PositiveIntegers: { type: "set<integer>", constant: true, collection: { contains: (e12, n) => n.type.matches("integer") && n.isPositive === true, size: () => 1 / 0, subsetOf: (e12, n, i) => {
  var _a2, _b, _c2;
  if (n.operator === "Range") {
    let t = n.ops[0].re, r = n.ops[1].re;
    return t > 0 && r > 0;
  }
  return n.type.matches("set<integer>") && ((_c2 = (_b = (_a2 = n.symbolDefinition) == null ? void 0 : _a2.collection) == null ? void 0 : _b.eltsgn) == null ? void 0 : _c2.call(_b, n)) === "positive" && (!i || n.symbol !== "PositiveIntegers");
}, eltsgn: () => "positive", elttype: () => "integer" } }, Element: { complexity: 11200, signature: "(value, collection|string) -> boolean", evaluate: ([e12, n], { engine: i }) => {
  let t = n.contains(e12);
  if (t === true) return i.True;
  if (t === false) return i.False;
} }, NotElement: { complexity: 11200, signature: "(value, collection|string) -> boolean", evaluate: ([e12, n], { engine: i }) => {
  let t = n.contains(e12);
  if (t === true) return i.False;
  if (t === false) return i.True;
} }, Subset: { complexity: 11200, signature: "(lhs:collection, rhs: collection) -> boolean", evaluate: ([e12, n], { engine: i }) => {
  let t = Ni(e12, n);
  if (t === true) return i.True;
  if (t === false) return i.False;
} }, SubsetEqual: { complexity: 11200, signature: "(lhs:collection, rhs: collection) -> boolean", evaluate: ([e12, n], { engine: i }) => {
  let t = Ni(e12, n, false);
  if (t === true) return i.True;
  if (t === false) return i.False;
} }, NotSubset: { complexity: 11200, signature: "(lhs:collection, rhs: collection) -> boolean", evaluate: ([e12, n], { engine: i }) => {
  let t = Ni(e12, n);
  if (t === true) return i.False;
  if (t === false) return i.True;
} }, Superset: { complexity: 11200, signature: "(lhs:collection, rhs: collection) -> boolean", evaluate: ([e12, n], { engine: i }) => {
  let t = Ni(n, e12);
  if (t === true) return i.True;
  if (t === false) return i.False;
} }, SupersetEqual: { complexity: 11200, signature: "(lhs:collection, rhs: collection) -> boolean", evaluate: ([e12, n], { engine: i }) => {
  let t = Ni(n, e12, true);
  if (t === true) return i.True;
  if (t === false) return i.False;
} }, NotSuperset: { complexity: 11200, signature: "(lhs:collection, rhs: collection) -> boolean", evaluate: ([e12, n], { engine: i }) => {
  let t = Ni(n, e12);
  if (t === true) return i.False;
  if (t === false) return i.True;
} }, NotSupersetEqual: { complexity: 11200, signature: "(lhs:collection, rhs: collection) -> boolean", evaluate: ([e12, n], { engine: i }) => {
  let t = Ni(n, e12, true);
  if (t === true) return i.False;
  if (t === false) return i.True;
} }, CartesianProduct: { wikidata: "Q173740", signature: "(set, ...set) -> set" }, Complement: { wikidata: "Q242767", signature: "(set, ...set) -> set" }, Intersection: { wikidata: "Q185837", signature: "(set, ...set) -> set", canonical: (e12, { engine: n }) => {
  var _a2;
  return e12.length === 0 || e12.length === 1 ? n.symbol("EmptySet") : (e12 = (_a2 = Ci(n, J(e12, "Intersection"), k("(set, ...set) -> set"))) != null ? _a2 : e12, n._fn("Intersection", e12));
}, evaluate: lm }, Union: { wikidata: "Q185359", signature: "(collection, ...collection) -> set", canonical: (e12, { engine: n }) => {
  var _a2;
  return e12.length === 0 ? n.symbol("EmptySet") : (e12 = (_a2 = Ci(n, J(e12, "Union"), k("(collection, ...collection) -> set"))) != null ? _a2 : e12, n._fn("Union", e12));
}, evaluate: um, collection: { contains: (e12, n) => e12.ops.some((i) => i.contains(n)), size: (e12) => {
  if (e12.ops.some((t) => t.size === 1 / 0)) return 1 / 0;
  let n = [], i = 0;
  for (let t of e12.ops) {
    for (let r of ee(t)) n.every((s) => !s.contains(r)) && (i += 1);
    n.push(t);
  }
  return i;
}, iterator: (e12) => {
  let n = [], i = 0, t = Mi(e12.ops[i]);
  return t ? { next: () => {
    let r = false, s;
    do {
      if (s = t.next(), s.done) {
        if (n.push(e12.ops[i]), i += 1, i === e12.ops.length) return { value: void 0, done: true };
        if (t = Mi(e12.ops[i]), !t) return { value: void 0, done: true };
      }
      r = n.every((o) => !o.contains(s.value));
    } while (!r);
    return { value: s.value, done: false };
  } } : { next: () => ({ value: void 0, done: true }) };
} } }, SetMinus: { wikidata: "Q18192442", signature: "(set, ...value) -> set", evaluate: fm, collection: { contains: (e12, n) => {
  var _a2;
  let [i, ...t] = e12.ops;
  return ((_a2 = i.contains(n)) != null ? _a2 : false) && !t.some((r) => r.isSame(n));
}, iterator: (e12) => {
  let [n, ...i] = e12.ops, t = Mi(n);
  return t ? { next() {
    let r = t.next();
    for (; !r.done && i.some((s) => s.isSame(r.value)); ) r = t.next();
    return r;
  } } : { next: () => ({ value: void 0, done: true }) };
} } }, SymmetricDifference: { wikidata: "Q1147242", signature: "(set, set) -> set" } };
function Ni(e12, n, i = true) {
  var _a2, _b, _c2;
  return !e12.isCollection || !n.isCollection ? false : !!((_c2 = (_b = (_a2 = e12.symbolDefinition) == null ? void 0 : _a2.collection) == null ? void 0 : _b.subsetOf) == null ? void 0 : _c2.call(_b, e12, n, i));
}
function um(e12, { engine: n }) {
  let i = e12.map((s) => s.isCollection ? s : n.function("Set", [s]));
  if (i.reduce((s, o) => {
    var _a2;
    return s + ((_a2 = o.size) != null ? _a2 : 0);
  }, 0) > Ka) return n._fn("Union", i);
  let r = [];
  for (let s of i) for (let o of ee(s)) r.every((a) => !a.isSame(o)) && r.push(o);
  return r.length === 0 ? n.symbol("EmptySet") : n._fn("Set", r);
}
function lm(e12, { engine: n }) {
  var _a2;
  let i = [...(_a2 = e12[0].ops) != null ? _a2 : []];
  for (let t of e12.slice(1)) ie(t) ? i = i.filter((r) => [...ee(t)].some((s) => r.isSame(s))) : i = i.filter((r) => r.isSame(t));
  return i.length === 0 ? n.symbol("EmptySet") : n._fn("Set", i);
}
function fm(e12, { engine: n }) {
  return n.symbol("EmptySet");
}
var Hf = [{ Choose: { complexity: 1200, signature: "(n:number, m:number) -> number", evaluate: (e12, { engine: n }) => {
  let i = e12[0].re, t = e12[1].re;
  if (!(!Number.isFinite(i) || !Number.isFinite(t))) return i < 0 || t < 0 || t > i ? n.NaN : n.number(po(i, t));
} } }, { Mean: { complexity: 1200, threadable: false, signature: "((collection|number)...) -> number", evaluate: (e12, { engine: n }) => n.number(oe(n) ? $l(n.bignum.bind(n), un(e12)) : Zr(an(e12))) }, Median: { complexity: 1200, threadable: false, signature: "((collection|number)...) -> number", evaluate: (e12, { engine: n }) => n.number(oe(n) ? hi(un(e12)) : Cn(an(e12))) }, Variance: { complexity: 1200, threadable: false, signature: "((collection|number)...) -> number", evaluate: (e12, { engine: n }) => n.number(oe(n) ? Do(n.bignum.bind(n), un(e12)) : tt(an(e12))) }, PopulationVariance: { complexity: 1200, threadable: false, signature: "((collection|number)...) -> number", evaluate: (e12, { engine: n }) => n.number(oe(n) ? Ao(n.bignum.bind(n), un(e12)) : rt(an(e12))) }, StandardDeviation: { complexity: 1200, threadable: false, description: "Sample Standard Deviation of a collection of numbers.", signature: "((collection|number)...) -> number", evaluate: (e12, { engine: n }) => n.number(oe(n) ? Do(n.bignum.bind(n), un(e12)).sqrt() : Math.sqrt(tt(an(e12)))) }, PopulationStandardDeviation: { complexity: 1200, threadable: false, description: "Population Standard Deviation of a collection of numbers.", signature: "((collection|number)...) -> number", evaluate: (e12, { engine: n }) => n.number(oe(n) ? Ao(n.bignum.bind(n), un(e12)).sqrt() : Math.sqrt(rt(an(e12)))) }, Kurtosis: { complexity: 1200, threadable: false, signature: "((collection|number)...) -> number", evaluate: (e12, { engine: n }) => n.number(oe(n) ? Gl(n.bignum.bind(n), un(e12)) : Hr(an(e12))) }, Skewness: { complexity: 1200, threadable: false, signature: "((collection|number)...) -> number", evaluate: (e12, { engine: n }) => n.number(oe(n) ? Ul(n.bignum.bind(n), un(e12)) : Wr(an(e12))) }, Mode: { complexity: 1200, threadable: false, signature: "((collection|number)...) -> number", evaluate: (e12, { engine: n }) => n.number(oe(n) ? jl(n.bignum.bind(n), un(e12)) : Jr(an(e12))) }, Quartiles: { complexity: 1200, threadable: false, signature: "((collection|number)...) -> tuple<mid:number, lower:number, upper:number>", evaluate: (e12, { engine: n }) => {
  let [i, t, r] = (oe(n) ? Zl(un(e12)) : Yr(an(e12))).map((s) => n.number(s));
  return n.tuple(i, t, r);
} }, InterquartileRange: { complexity: 1200, threadable: false, signature: "((collection|number)...) -> number", evaluate: (e12, { engine: n }) => n.number(oe(n) ? Hl(un(e12)) : Qr(an(e12))) }, Erf: { complexity: 7500, signature: "number -> number", evaluate: (e12, { engine: n }) => {
  let i = e12[0].re;
  if (Number.isFinite(i)) return n.number(Ws(i));
} }, Erfc: { complexity: 7500, signature: "number -> number", evaluate: (e12, { engine: n }) => {
  let i = e12[0].re;
  if (Number.isFinite(i)) return n.number(1 - Ws(i));
} }, ErfInv: { complexity: 7500, signature: "number -> number", evaluate: (e12, { engine: n }) => {
  let i = e12[0].re;
  if (Number.isFinite(i)) return n.number(xu(i));
} } }];
function* Wf(e12) {
  if (e12.length === 1 && ri(e12[0])) yield* ee(e12[0]);
  else for (let n of e12) ri(n) ? yield* ee(n) : yield n;
}
function* an(e12) {
  for (let n of Wf(e12)) yield n.re;
}
function* un(e12) {
  var _a2;
  for (let n of Wf(e12)) yield (_a2 = n.bignumRe) != null ? _a2 : n.engine.bignum(n.re);
}
var cm = { Sin: [[1, "Sin"], [1, "Cos"], [-1, "Sin"], [-1, "Cos"]], Cos: [[1, "Cos"], [-1, "Sin"], [-1, "Cos"], [1, "Sin"]], Sec: [[1, "Sec"], [-1, "Csc"], [-1, "Sec"], [1, "Csc"]], Csc: [[1, "Csc"], [1, "Sec"], [-1, "Csc"], [-1, "Sec"]], Tan: [[1, "Tan"], [-1, "Cot"], [1, "Tan"], [-1, "Cot"]], Cot: [[1, "Cot"], [-1, "Tan"], [1, "Cot"], [-1, "Tan"]] };
var Qn = ["Sqrt", 2];
var ct = ["Sqrt", 3];
var pt = ["Sqrt", 5];
var as = ["Sqrt", 6];
var pm = [[[0, 1], { Sin: 0, Cos: 1, Tan: 0, Cot: "ComplexInfinity", Sec: 1, Csc: "ComplexInfinity" }], [[1, 12], { Sin: ["Divide", ["Subtract", as, Qn], 4], Cos: ["Divide", ["Add", as, Qn], 4], Tan: ["Subtract", 2, ct], Cot: ["Add", 2, ct], Sec: ["Subtract", as, Qn], Csc: ["Add", as, Qn] }], [[1, 10], { Sin: ["Divide", ["Subtract", pt, 1], 4], Cos: ["Divide", ["Sqrt", ["Add", 10, ["Multiply", 2, pt]]], 4], Tan: ["Divide", ["Sqrt", ["Subtract", 25, ["Multiply", 10, pt]]], 5], Cot: ["Sqrt", ["Add", 5, ["Multiply", 2, pt]]], Sec: ["Divide", ["Sqrt", ["Subtract", 50, ["Multiply", 10, pt]]], 5], Csc: ["Add", 1, pt] }], [[1, 8], { Sin: "$\\frac{\\sqrt{2-\\sqrt2}}{2}$", Cos: "$\\frac{\\sqrt {2+{\\sqrt {2}}}}{2}$", Tan: "$\\sqrt{2} - 1$", Cot: "$\\sqrt{2} + 1$", Sec: "$\\sqrt{ 4 - 2\\sqrt{2}}$", Csc: "$\\sqrt{ 4 + 2\\sqrt{2}}$" }], [[1, 6], { Sin: "$\\frac{1}{2}$", Cos: "$\\frac{\\sqrt{3}}{2}$", Tan: "$\\frac{\\sqrt{3}}{3}$", Cot: "$\\sqrt{3}$", Sec: "$\\frac{2\\sqrt{3}}{3}$", Csc: 2 }], [[1, 5], { Sin: "$\\frac{\\sqrt{10- 2\\sqrt{5}}} {4}$", Cos: "$\\frac{1+ \\sqrt{5}} {4}$", Tan: "$\\sqrt{5-2\\sqrt5}$", Cot: "$\\frac{\\sqrt{25+10\\sqrt5}} {5}$", Sec: "$\\sqrt{5} - 1$", Csc: "$\\frac{\\sqrt{50+10\\sqrt{5}}} {5}$" }], [[1, 4], { Sin: ["Divide", Qn, 2], Cos: ["Divide", Qn, 2], Tan: 1, Cot: 1, Sec: Qn, Csc: Qn }], [[3, 10], { Sin: "$\\frac{1+ \\sqrt5} {4}$", Cos: "$\\frac{\\sqrt{10- 2\\sqrt5}} {4}$", Tan: "$\\frac{\\sqrt{25+10\\sqrt5}} {5}$", Cot: "$\\sqrt{5-2\\sqrt5}$", Sec: "$\\frac{\\sqrt{50+10\\sqrt5}} {5}$", Csc: "$\\sqrt5-1$" }], [[1, 3], { Sin: ["Divide", ct, 2], Cos: "Half", Tan: ct, Cot: ["Divide", ct, 3], Sec: 2, Csc: ["Divide", ["Multiply", 2, ct], 3] }], [[3, 8], { Sin: "$\\frac{ \\sqrt{2 + \\sqrt{2}} } {2}$", Cos: "$\\frac{ \\sqrt{2 - \\sqrt{2}} } {2}$", Tan: "$\\sqrt{2} + 1$", Cot: "$\\sqrt{2} - 1$", Sec: "$\\sqrt{ 4 + 2 \\sqrt{2} }$", Csc: "$\\sqrt{ 4 - 2 \\sqrt{2} }$" }], [[2, 5], { Sin: "$\\frac{\\sqrt{10+ 2\\sqrt{5}}} {4}$", Cos: "$\\frac{\\sqrt{5}-1} {4}$", Tan: "$\\sqrt{5+2\\sqrt{5}}$", Cot: "$\\frac{\\sqrt{25-10\\sqrt{5}}} {5}$", Sec: "$1 + \\sqrt{5}$", Csc: "$\\frac{\\sqrt{50-10\\sqrt{5}}} {5}$" }], [[5, 12], { Sin: "$\\frac{\\sqrt{6} + \\sqrt{2}} {4}$", Cos: "$\\frac{ \\sqrt{6} - \\sqrt{2}} {4}$", Tan: "$2+\\sqrt{3}$", Cot: "$2-\\sqrt{3}$", Sec: "$\\sqrt{6}+\\sqrt{2}$", Csc: "$\\sqrt{6} - \\sqrt{2}$" }], [[1, 2], { Sin: 1, Cos: 0, Tan: "ComplexInfinity", Cot: 0, Sec: "ComplexInfinity", Csc: 1 }]];
function Xe(e12, n, i, t) {
  var _a2;
  let r = (_a2 = Tr(e12)) == null ? void 0 : _a2.N();
  if (r !== void 0) return Q(r, n, i, t);
}
function Ke(e12) {
  if (!e12) return e12;
  let n = e12.engine, i = n.angularUnit;
  if (i === "rad") return e12;
  let t = e12.N().re;
  return Number.isNaN(t) ? e12 : i === "deg" ? n.number(t * (180 / Math.PI)) : i === "grad" ? n.number(t * (200 / Math.PI)) : i === "turn" ? n.number(t / (2 * Math.PI)) : e12;
}
function Qt(e12, n) {
  if (!n) return;
  let i = n.engine;
  switch (e12) {
    case "Arccos":
      return Ke(Q(n, Math.acos, (t) => t.acos(), (t) => t.acos()));
    case "Arccot":
      return Ke(Q(n, (t) => Math.atan2(1, t), (t) => M.atan2(i._BIGNUM_ONE, t), (t) => t.inverse().atan()));
    case "Arccsc":
      return Ke(Q(n, (t) => Math.asin(1 / t), (t) => i._BIGNUM_ONE.div(t).asin(), (t) => t.inverse().asin()));
    case "Arccosh":
      return Ke(Q(n, Math.acosh, (t) => t.acosh(), (t) => t.acosh()));
    case "Arccoth":
      return Ke(Q(n, (t) => Math.log((1 + t) / (t - 1)) / 2, (t) => i._BIGNUM_ONE.add(t).div(t.sub(i._BIGNUM_ONE)).log().div(2), (t) => i.complex(1).add(t).div(t.sub(1)).log().div(2)));
    case "Arccsch":
      return Ke(Q(n, (t) => Math.log(1 / t + Math.sqrt(1 / (t * t) + 1)), (t) => i._BIGNUM_ONE.div(t.mul(t)).add(i._BIGNUM_ONE).sqrt().add(i._BIGNUM_ONE.div(t)).log(), (t) => t.mul(t).inverse().add(1).sqrt().add(t.inverse()).log()));
    case "Arcsec":
      return Ke(Q(n, (t) => Math.acos(1 / t), (t) => i._BIGNUM_ONE.div(t).acos(), (t) => t.inverse().acos()));
    case "Arcsin":
      return Ke(Q(n, Math.asin, (t) => t.asin(), (t) => t.asin()));
    case "Arcsech":
      return Ke(Q(n, (t) => Math.log((1 + Math.sqrt(1 - t * t)) / t), (t) => i._BIGNUM_ONE.sub(t.mul(t).add(i._BIGNUM_ONE).div(t)).log(), (t) => i.complex(1).sub(t.mul(t)).add(1).div(t).log()));
    case "Arcsinh":
      return Ke(Q(n, Math.asinh, (t) => t.asinh(), (t) => t.asinh()));
    case "Arctan":
      return Ke(Q(n, Math.atan, (t) => t.atan(), (t) => t.atan()));
    case "Arctanh":
      return Ke(Q(n, Math.atanh, (t) => t.atanh(), (t) => t.atanh()));
    case "Cos":
      return Xe(n, Math.cos, (t) => i.chop(t.cos()), (t) => t.cos());
    case "Cosh":
      return Xe(n, Math.cosh, (t) => t.cosh(), (t) => t.cosh());
    case "Cot":
      return Xe(n, (t) => 1 / Math.tan(t), (t) => i._BIGNUM_ONE.div(t.tan()), (t) => t.tan().inverse());
    case "Coth":
      return Xe(n, (t) => 1 / Math.tanh(t), (t) => i._BIGNUM_ONE.div(t.tanh()), (t) => t.tanh().inverse());
    case "Csc":
      return Xe(n, (t) => 1 / Math.sin(t), (t) => i._BIGNUM_ONE.div(t.sin()), (t) => t.sin().inverse());
    case "Csch":
      return Xe(n, (t) => 1 / Math.sinh(t), (t) => i._BIGNUM_ONE.div(t.sinh()), (t) => t.sinh().inverse());
    case "Sec":
      return Xe(n, (t) => 1 / Math.cos(t), (t) => i._BIGNUM_ONE.div(t.cos()), (t) => t.cos().inverse());
    case "Sech":
      return Xe(n, (t) => 1 / Math.cosh(t), (t) => i._BIGNUM_ONE.div(t.cosh()), (t) => t.cosh().inverse());
    case "Sin":
      return Xe(n, Math.sin, (t) => i.chop(t.sin()), (t) => t.sin());
    case "Sinh":
      return Xe(n, Math.sinh, (t) => t.sinh(), (t) => t.sinh());
    case "Tan":
      return Xe(n, (r) => {
        let s = Math.tan(r);
        return s > 1e6 || s < -1e6 ? i.ComplexInfinity : s;
      }, (r) => {
        let s = r.tan();
        return s.greaterThan(1e6) || s.lessThan(-1e6) ? i.ComplexInfinity : s;
      }, (r) => r.tan());
    case "Tanh":
      return Xe(n, Math.tanh, (t) => t.tanh(), (t) => t.tanh());
  }
}
function dm(e12) {
  return !!(e12.startsWith("Ar") && Qo(e12));
}
function Qo(e12) {
  return { Sin: "Arcsin", Cos: "Arccos", Tan: "Arctan", Sec: "Arcsec", Csc: " Arccsc", Sinh: "Arcsinh", Cosh: "Arccosh", Tanh: "Arctanh", Sech: "Arcsech", Csch: "Arccsch", Arccosh: "Cosh", Arccos: "Cos", Arccsc: "Csc", Arccsch: "Csch", Arcsec: "Sec", Arcsin: "Sin", Arcsinh: "Sinh", Arctan: "Tan", Arctanh: "Tanh" }[e12];
}
function Xt(e12, n) {
  if (n.length !== 1 || !n[0].isValid) return;
  let i = n[0], t = i.symbol;
  if (typeof t != "string") return;
  if (t === "InverseFunction") return i.op1;
  let r = Qo(t);
  return r ? e12.symbol(r) : void 0;
}
function Jf(e12) {
  return e12 !== "Cos" && e12 !== "Sec" ? -1 : 1;
}
function mm(e12, n, i, t) {
  if (!i) return;
  let r = i.N().re;
  if (Number.isNaN(r)) return;
  let s = Qo(n), o = e12.cache("constructible-inverse-trigonometric-values-" + n, () => {
    let u = [];
    for (let [[l, f], c] of t) {
      let p = c[s];
      if (p === void 0) continue;
      let m = p.N().re;
      Number.isNaN(m) || u.push([[p, m], [l, f]]);
    }
    return u;
  }, (u) => {
    for (let [[l, f], [c, p]] of u) l.reset();
    return u;
  }), a = 0;
  r < 0 && (a = Jf(s) == -1 ? -1 : 1, r = -r, i = i.neg());
  for (let [[u, l], [f, c]] of o) if (e12.chop(r - l) === 0) {
    let p = e12.Pi.mul(f).div(c);
    return a == -1 ? p = p.neg() : a == 1 && (p = e12.Pi.sub(p)), p.evaluate();
  }
}
function Xo(e12, n) {
  var _a2;
  let [i, t] = hm(n);
  if (i !== void 0) return t !== void 0 && ((e12 === "Sin" || e12 === "Tan") && (t === 0 || t === 2) || (e12 === "Cos" || e12 === "Cot") && (t === 1 || t === 3)) ? "zero" : (_a2 = { Sin: ["positive", "positive", "negative", "negative"], Cos: ["positive", "negative", "negative", "positive"], Sec: ["positive", "negative", "negative", "positive"], Csc: ["positive", "positive", "negative", "negative"], Tan: ["positive", "negative", "positive", "negative"], Cot: ["positive", "negative", "positive", "negative"] }[e12]) == null ? void 0 : _a2[i];
}
function Ko(e12) {
  return ["Sin", "Cos", "Tan", "Csc", "Sec", "Cot"].includes(typeof e12 == "string" ? e12 : e12.operator);
}
function Kt(e12, n) {
  var _a2, _b;
  if (!n || !Ko(e12)) return;
  let i = n.engine;
  if (n = n.N(), n.im !== 0) return;
  let t = n.re;
  if (Number.isNaN(t)) return;
  let r = i.cache("constructible-trigonometric-values", () => pm.map(([l, f]) => [l, Object.fromEntries(Object.entries(f).map(([c, p]) => {
    var _a3;
    return [c, ((_a3 = i.parse(Vn(p))) != null ? _a3 : i.box(p)).simplify()];
  }))]), (l) => {
    for (let [f, c] of l) for (let p of Object.values(c)) p.reset();
    return l;
  });
  if (dm(e12)) return mm(i, e12, n, r);
  let s = i.angularUnit;
  s !== "rad" && (s === "deg" && (t *= Math.PI / 180), s === "grad" && (t *= Math.PI / 200), s === "turn" && (t *= 2 * Math.PI));
  let o = Jf(e12) == -1 ? Math.sign(t) : 1;
  t = Math.abs(t % (2 * Math.PI));
  let a = Math.floor(t * 2 / Math.PI);
  t = t % (Math.PI / 2);
  let u;
  [u, e12] = (_b = (_a2 = cm[e12]) == null ? void 0 : _a2[a]) != null ? _b : [1, e12];
  for (let [[l, f], c] of r) {
    let p = c[e12];
    if (p && Math.abs(t - Math.PI * l / f) <= 1e-12) return p.symbol === "ComplexInfinity" ? p : o * u < 0 ? p.neg() : p;
  }
}
function hm(e12) {
  if (!e12.isValid || !e12.isNumberLiteral) return [void 0, void 0];
  if (e12.im !== 0) return [void 0, void 0];
  let n = e12.re;
  if (isNaN(n)) return [void 0, void 0];
  let i = (n % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
  return Math.abs(i) < 1e-12 ? [1, 0] : Math.abs(i - Math.PI / 2) < 1e-12 ? [2, 1] : Math.abs(i - Math.PI) < 1e-12 ? [3, 2] : Math.abs(i - 3 * Math.PI / 2) < 1e-12 ? [4, 3] : [Math.floor(i / (Math.PI / 2)) + 1, void 0];
}
var Yf = [{ Pi: { type: "finite_real", constant: true, holdUntil: "N", wikidata: "Q167", value: (e12) => e12.number(oe(e12) ? e12._BIGNUM_PI : Math.PI) } }, { Degrees: { signature: "real -> real", canonical: (e12, { engine: n }) => {
  let i = n;
  if (i.angularUnit === "deg") return e12[0];
  if (e12.length !== 1) return i._fn("Degrees", e12);
  let t = e12[0];
  if (t.numericValue === null || !t.isValid) return i._fn("Degrees", e12);
  let r = t.re;
  if (Number.isNaN(r)) return t.mul(i.Pi).div(180);
  if (r = r % 360, r < 0 && (r += 360), Number.isInteger(r)) {
    let s = Pi([r, 180]);
    return s[0] === 0 ? i.Zero : s[0] === 1 && s[1] === 1 ? i.Pi : s[0] === 1 ? i.Pi.div(s[1]) : i.number(s).mul(i.Pi);
  }
  return i.number(r).div(180).mul(i.Pi);
}, evaluate: (e12, n) => n.engine.angularUnit === "deg" ? e12[0] : e12[0].mul(n.engine.Pi.div(180)).evaluate(n) }, Hypot: { threadable: true, signature: "(real, real) -> real", sgn: () => "non-negative", evaluate: ([e12, n], { engine: i }) => i.box(["Sqrt", ["Add", ["Square", e12], ["Square", n]]]) }, Sin: se("Sin", 5e3) }, { Arctan: { wikidata: "Q2257242", complexity: 5200, threadable: true, signature: "number -> finite_real", sgn: ([e12]) => Xo("Arctan", e12), evaluate: ([e12], { numericApproximation: n }) => {
  var _a2;
  return n ? Qt("Arctan", e12) : (_a2 = Kt("Arctan", e12)) != null ? _a2 : Qt("Arctan", e12);
} }, Arctan2: { wikidata: "Q776598", complexity: 5200, threadable: true, signature: "(y:number, x: number) -> real", evaluate: ([e12, n], { engine: i, numericApproximation: t }) => t ? gn(e12, n, Math.atan2, (r, s) => M.atan2(r, s)) : e12.isFinite === false && n.isFinite === false ? i.NaN : e12.is(0) && n.is(0) ? i.Zero : n.isFinite === false ? n.isPositive ? i.Zero : i.Pi : e12.isFinite === false ? e12.isPositive ? i.Pi.div(2) : i.Pi.div(-2) : e12.is(0) ? n.isPositive ? i.Zero : i.Pi : i.function("Arctan", [e12.div(n)]).evaluate() }, Cos: se("Cos", 5050), Tan: se("Tan", 5100) }, { Arccosh: se("Arccosh", 6200), Arcsin: se("Arcsin", 5500), Arcsinh: se("Arcsinh", 6100), Arctanh: se("Arctanh", 6300), Cosh: se("Cosh", 6050), Cot: se("Cot", 5600), Csc: se("Csc", 5600, "Cosecant"), Sec: se("Sec", 5600, "Secant, inverse of cosine"), Sinh: se("Sinh", 6e3), Haversine: { wikidata: "Q2528380", threadable: true, signature: "real -> number", evaluate: ([e12], { engine: n }) => n.box(["Divide", ["Subtract", 1, ["Cos", e12]], 2]) }, InverseHaversine: { threadable: true, signature: "real -> real", evaluate: ([e12], { engine: n }) => n.box(["Multiply", 2, ["Arcsin", ["Sqrt", e12]]]) } }, { Csch: se("Csch", 6200, "Hyperbolic cosecant"), Sech: se("Sech", 6200, "Hyperbolic secant"), Tanh: se("Tanh", 6200, "Hyperbolic tangent") }, { Arccos: se("Arccos", 5550), Arccot: se("Arccot", 5650), Arccoth: se("Arccoth", 6350), Arccsch: se("Arccsch", 6250), Arcsec: se("Arcsec", 5650), Arcsech: se("Arcsech", 6250), Arccsc: se("Arccsc", 5650), Coth: se("Coth", 6300), InverseFunction: { lazy: true, signature: "function -> function", canonical: (e12, { engine: n }) => {
  var _a2;
  return e12 = qe(n, e12, 1), (_a2 = Xt(n, e12)) != null ? _a2 : n._fn("InverseFunction", e12);
}, evaluate: (e12, { engine: n }) => Xt(n, e12) } }];
function se(e12, n, i) {
  return { complexity: n, description: i, threadable: true, signature: "number -> number", sgn: ([t]) => Xo(e12, t), evaluate: ([t], { numericApproximation: r }) => {
    var _a2;
    return r ? Qt(e12, t) : (_a2 = Kt(e12, t)) != null ? _a2 : Qt(e12, t);
  } };
}
var ue = class {
  constructor(n, i, t) {
    this.constant = false;
    this.holdUntil = "evaluate";
    if (!n.context) throw Error("No context available");
    this.name = i, this._engine = n, this.scope = n.context, this.update(t);
  }
  get isFunction() {
    return this.type.matches("function");
  }
  get isConstant() {
    return this.constant;
  }
  update(n) {
    var _a2;
    if (n.wikidata && (this.wikidata = n.wikidata), n.description && (this.description = n.description), n.url && (this.url = n.url), n.flags && (this._flags = Rs(n.flags)), n.holdUntil && (this.holdUntil = n.holdUntil), this.constant && n.constant === false) throw new Error(`The constant "${this.name}" cannot be changed to a variable`);
    if (n.constant && (this.constant = n.constant, this._defValue = n.value), this._value = Qf(this._engine, n.value), n.type) {
      let i = k(n == null ? void 0 : n.type);
      if (!Sn(i)) throw new Error(`Invalid type: "${n.type}"`);
      this._type = new C(i), this.inferredType = (_a2 = n.inferred) != null ? _a2 : false;
    }
    if (this._value) {
      if (!this._type || this._type.isUnknown) this._type = this._value.type, this.inferredType = true;
      else if (!this._value.type.matches(this._type)) throw new Error([`Symbol "${this.name}"`, `The value "${this._value.toString()}" of type "${this._value.type}" is not compatible with the type "${this._type}"`].join(`
|   `));
    }
    n.eq && (this.eq = n.eq), n.neq && (this.neq = n.neq), n.cmp && (this.cmp = n.cmp), n.collection && (this.collection = eu(n.collection));
  }
  reset() {
    this.constant && (this._value = null);
  }
  get value() {
    return this._value === null && (this._value = Qf(this._engine, this._defValue)), this._value;
  }
  set value(n) {
    if (this.constant) throw new Error(`The value of the constant "${this.name}" cannot be changed`);
    if (this._defValue, n !== void 0) {
      let i = this._engine.box(n);
      this.inferredType ? (this._value = i, this._type = this._type ? new C(ke(this._type.type, i.type.type)) : i.type) : !this._type || this.type.isUnknown || !i.type || i.type.matches(this._type) ? this._value = i : this._value = void 0;
    } else this._value = void 0;
  }
  get type() {
    var _a2, _b, _c2;
    return (_c2 = (_b = this._type) != null ? _b : (_a2 = this._value) == null ? void 0 : _a2.type) != null ? _c2 : C.unknown;
  }
  set type(n) {
    var _a2, _b;
    if (this.constant) throw new Error(`The type of the constant "${this.name}" cannot be changed`);
    if (!this.inferredType && !this.type.isUnknown) throw Error(`The type of "${this.name}" cannot be changed because it has already been declared`);
    if (n instanceof C && (n = n.type), n === "unknown") {
      this._defValue = void 0, this._value = void 0, this._flags = void 0, this._type = C.unknown;
      return;
    }
    if ((_a2 = this._type) == null ? void 0 : _a2.isUnknown) {
      this._type = new C(n);
      return;
    }
    if (((_b = this._value) == null ? void 0 : _b.type) && !this._value.type.matches(n)) throw Error(`The type of "${this.name}" cannot be changed to "${n}" because its value has a type of "${this._value.type}"`);
    this._type = new C(n);
  }
  get sgn() {
    var _a2, _b, _c2;
    return (_c2 = (_a2 = this.value) == null ? void 0 : _a2.sgn) != null ? _c2 : (_b = this._flags) == null ? void 0 : _b.sgn;
  }
  set sgn(n) {
    this.updateFlags({ sgn: n });
  }
  get even() {
    var _a2, _b, _c2;
    return (_c2 = (_a2 = this.value) == null ? void 0 : _a2.isEven) != null ? _c2 : (_b = this._flags) == null ? void 0 : _b.even;
  }
  set even(n) {
    this.updateFlags({ even: n });
  }
  get odd() {
    var _a2, _b, _c2;
    return (_c2 = (_a2 = this.value) == null ? void 0 : _a2.isOdd) != null ? _c2 : (_b = this._flags) == null ? void 0 : _b.odd;
  }
  set odd(n) {
    this.updateFlags({ odd: n });
  }
  updateFlags(n) {
    var _a2;
    if (this.constant) throw Error(`The flags of "${this.name}" cannot be changed because it is a constant`);
    this._flags = Rs({ ...(_a2 = this._flags) != null ? _a2 : {}, ...n });
  }
};
function Qf(e12, n) {
  var _a2, _b;
  if (n !== void 0) return Nt(n) ? (_a2 = e12.parse(n)) != null ? _a2 : e12.symbol("Undefined") : typeof n == "function" ? e12.box((_b = n(e12)) != null ? _b : "Undefined") : n instanceof X ? n : e12.box(n);
}
var gm = /* @__PURE__ */ new Set(["description", "wikidata", "url", "lazy", "threadable", "associative", "commutative", "commutativeOrder", "idempotent", "involution", "pure", "signature", "type", "sgn", "even", "complexity", "canonical", "evaluate", "evaluateAsync", "evalDimension", "compile", "eq", "neq", "cmp", "collection"]);
var Le = class {
  constructor(n, i, t) {
    this.threadable = false;
    this.associative = false;
    this.commutative = false;
    this.idempotent = false;
    this.involution = false;
    this.pure = true;
    this.complexity = Un;
    this.lazy = false;
    this.inferredSignature = true;
    if (!n.context) throw Error("No context available");
    this.name = i, this.engine = n, this.scope = n.context, t.signature ? (this.inferredSignature = false, this.signature = new C(t.signature)) : this.signature = new C("...any -> any"), this.update(t);
  }
  infer(n) {
    let i = new C(n);
    if (!i.matches(this.signature)) throw new Error(`Function Definition "${this.name}": inferred signature "${i}" does not match current signature "${this.signature}"`);
    this.inferredSignature && (this.signature = i);
  }
  update(n) {
    var _a2, _b, _c2, _d2, _e2, _f2, _g, _h, _i2, _j, _k, _l2, _m2, _n2, _o2, _p2, _q, _r2, _s2, _t2, _u2, _v;
    if (this.engine.strict) {
      for (let s in n) if (!gm.has(s)) throw new Error(`Function Definition "${this.name}": unexpected key "${s}"`);
    }
    this.lazy = (_a2 = n.lazy) != null ? _a2 : this.lazy;
    let i = (_b = n.idempotent) != null ? _b : this.idempotent, t = (_c2 = n.involution) != null ? _c2 : this.involution;
    if (i && t) throw new Error(`Function Definition "${this.name}": the 'idempotent' and 'involution' flags are mutually exclusive`);
    if (this.idempotent = i, this.involution = t, this.description = (_d2 = n.description) != null ? _d2 : this.description, this.wikidata = (_e2 = n.wikidata) != null ? _e2 : this.wikidata, this.threadable = (_f2 = n.threadable) != null ? _f2 : this.threadable, this.associative = (_g = n.associative) != null ? _g : this.associative, this.commutative = (_h = n.commutative) != null ? _h : this.commutative, this.commutativeOrder = (_i2 = n.commutativeOrder) != null ? _i2 : this.commutativeOrder, this.commutativeOrder && !this.commutative) throw new Error(`Function Definition "${this.name}": the 'commutativeOrder' handler requires the 'commutative' flag`);
    if (n.canonical && (n.associative || n.commutative || n.idempotent || n.involution)) throw new Error(`Function Definition "${this.name}": the 'canonical' handler is incompatible with the 'associative', 'commutative', 'idempotent', and 'involution' flags`);
    if (this.pure = (_j = n.pure) != null ? _j : this.pure, this.complexity = (_k = n.complexity) != null ? _k : this.complexity, n.signature) {
      let s = n.signature, o = new C(k(n.signature));
      if (s && !o.matches(s)) throw new Error(`Function Definition "${this.name}": signature "${o}" does not match "${s}"`);
      this.inferredSignature = false, this.signature = o;
    }
    let r;
    if (n.evaluate && typeof n.evaluate != "function") {
      let s = this.engine.box(n.evaluate, { canonical: false });
      if (!s.isValid) throw Error(`Invalid function ${s.toString()}`);
      let o = ze(s);
      r = (a) => o(a), Object.defineProperty(r, "toString", { value: () => s.toString() });
    } else r = (_l2 = n.evaluate) != null ? _l2 : this.evaluate;
    this.type = (_m2 = n.type) != null ? _m2 : this.type, this.evaluate = r, this.evaluateAsync = (_n2 = n.evaluateAsync) != null ? _n2 : this.evaluateAsync, this.canonical = (_o2 = n.canonical) != null ? _o2 : this.canonical, this.evalDimension = (_p2 = n.evalDimension) != null ? _p2 : this.evalDimension, this.sgn = (_q = n.sgn) != null ? _q : this.sgn, this.even = (_r2 = n.even) != null ? _r2 : this.even, this.compile = (_s2 = n.compile) != null ? _s2 : this.compile, this.eq = (_t2 = n.eq) != null ? _t2 : this.eq, this.neq = (_u2 = n.neq) != null ? _u2 : this.neq, this.collection = (_v = n.collection) != null ? _v : this.collection;
  }
  reset() {
  }
};
function us(e12, n, i) {
  return i instanceof Le ? i : new Le(e12, n, i);
}
function ea(e12) {
  if (e12 === "all") return ea(["core", "control-structures", "logic", "collections", "relop", "numeric", "arithmetic", "trigonometry", "algebra", "calculus", "polynomials", "combinatorics", "linear-algebra", "statistics", "dimensions", "units", "physics", "other"]);
  typeof e12 == "string" && (e12 = [e12]);
  let n = [];
  for (let i of e12) {
    let t = xm[i];
    if (!t) throw Error(`Unknown library category ${i}`);
    Array.isArray(t) ? n.push(...t) : n.push(t);
  }
  return Object.freeze(n);
}
var xm = { algebra: [], arithmetic: [...Il, ...Af], calculus: Bf, collections: [Zf, bl], combinatorics: [], "control-structures": wf, core: Mf, dimensions: [], domains: [], "linear-algebra": Cf, logic: Pf, numeric: [], other: [], relop: jf, polynomials: Gf, physics: { Mu0: { description: "Vaccum permeability", constant: true, wikidata: "Q1515261", type: "real", value: 125663706212e-17 } }, statistics: Hf, trigonometry: Yf, units: [] };
function ym(e12) {
  if (e12 = e12.normalize(), xe(e12)) return e12;
  throw new Error(`Invalid definition name "${e12}": ${We(e12)}`);
}
function na(e12, n) {
  var _a2;
  var t;
  if (!e12.context) throw Error("No context available");
  (_a2 = (t = e12.context).ids) != null ? _a2 : t.ids = /* @__PURE__ */ new Map();
  let i = e12.context.ids;
  e12.strict;
  for (let [r, s] of Object.entries(n)) try {
    if (r = ym(r), St(s)) try {
      let o = us(e12, r, s);
      if (i.has(r)) throw new Error(`Duplicate function definition:
${JSON.stringify(i.get(r))}
${JSON.stringify(s)}`);
      i.set(r, o);
    } catch (o) {
      console.error([`
Error in function definition`, "", JSON.stringify(s), "", o.message].join(`
|   `) + `
`);
    }
    else if (Tt(s)) try {
      let o = new ue(e12, r, s);
      if (e12.strict && s.wikidata) {
        for (let [a, u] of i) if (u.wikidata === s.wikidata) throw new Error(`Duplicate entries with wikidata "${s.wikidata}": "${r}" and "${u.name}"`);
      }
      if (i.has(r)) throw new Error("The symbol is already defined");
      i.set(r, o);
    } catch (o) {
      console.error([`
Error in symbol definition of "${r}"`, "", JSON.stringify(s), "", o.message].join(`
|   `));
    }
    else {
      let o = new ue(e12, r, { value: e12.box(s) });
      i.set(r, o);
    }
  } catch (o) {
    console.error([`
Error in definition of "${r}"`, "", JSON.stringify(s), "", o.message].join(`
|   `) + `
`);
  }
}
function ls(e12) {
  return typeof e12 == "number" ? e12 === 0 ? 1 : Number.isInteger(e12) ? Math.floor(Math.log2(Math.abs(e12)) / Math.log2(10)) + (e12 > 0 ? 1 : 2) : 2 : e12.isZero ? 1 : e12.im !== 0 ? ls(e12.re) + ls(e12.im) + 1 : ls(e12.re);
}
function ia(e12) {
  var _a2, _b;
  if (e12.symbol) return 1;
  if (e12.isNumberLiteral) return ls(e12.numericValue);
  let n = e12.operator, i = 2;
  if (["Add"].includes(n)) i = 3;
  else if (["Subtract", "Negate"].includes(n)) i = 4;
  else if (["Square", "Sqrt"].includes(n)) i = 5;
  else {
    if (["Power", "Root"].includes(n)) return ia(e12.ops[1]);
    ["Multiply"].includes(n) ? i = 7 : ["Divide"].includes(n) ? i = 8 : ["Ln", "Exp", "Log", "Lb"].includes(n) ? i = 9 : ["Cos", "Sin", "Tan"].includes(n) ? i = 10 : i = 11;
  }
  return i + ((_b = (_a2 = e12.ops) == null ? void 0 : _a2.reduce((t, r) => t + ia(r), 0)) != null ? _b : 0);
}
var ta = ia;
var dt = class e9 {
  constructor(n) {
    n ? n instanceof e9 ? this._items = new Map(n._items) : this._items = new Map(n) : this._items = /* @__PURE__ */ new Map();
  }
  has(n) {
    for (let i of this._items.keys()) if (i.isSame(n)) return true;
    return false;
  }
  get(n) {
    for (let [i, t] of this._items) if (i.isSame(n)) return t;
  }
  clear() {
    this._items.clear();
  }
  set(n, i) {
    for (let t of this._items.keys()) if (t.isSame(n)) {
      this._items.set(t, i);
      return;
    }
    this._items.set(n, i);
  }
  delete(n) {
    this._items.delete(n);
  }
  [Symbol.iterator]() {
    return this._items.entries();
  }
  entries() {
    return this._items.entries();
  }
};
var Ae = class extends X {
  constructor(n, i, t) {
    super(n, t == null ? void 0 : t.metadata), i instanceof z || typeof i == "number" ? this._value = i : this._value = n._numericValue(i);
  }
  get hash() {
    var _a2;
    return (_a2 = this._hash) != null ? _a2 : this._hash = pn(this._value.toString()), console.info("hash BoxedNumber ", this._hash), this._hash;
  }
  get json() {
    let n = this._value;
    return typeof n == "number" ? Number.isNaN(n) ? "NaN" : Number.isFinite(n) ? n : n > 0 ? "PositiveInfinity" : "NegativeInfinity" : n.toJSON();
  }
  get operator() {
    return "Number";
  }
  get isPure() {
    return true;
  }
  get isCanonical() {
    return true;
  }
  set isCanonical(n) {
  }
  get complexity() {
    return 1;
  }
  get numericValue() {
    return this._value;
  }
  get isNumberLiteral() {
    return true;
  }
  get re() {
    return typeof this._value == "number" ? this._value : this._value.re;
  }
  get im() {
    return typeof this._value == "number" ? 0 : this._value.im;
  }
  get bignumRe() {
    if (typeof this._value != "number") return this._value.bignumRe;
  }
  get bignumIm() {
  }
  neg() {
    let n = this._value;
    return n === 0 ? this : typeof n == "number" ? this.engine.number(-n) : this.engine.number(n.neg());
  }
  inv() {
    return this.value === 1 || this.value === -1 ? this : typeof this._value == "number" ? Number.isInteger(this._value) ? this.engine.number(this.engine._numericValue({ rational: [1, this._value] })) : this.engine.number(1 / this._value) : this.engine.number(this._value.inv());
  }
  abs() {
    return this.isPositive ? this : typeof this._value == "number" ? this.engine.number(-this._value) : this.engine.number(this._value.abs());
  }
  add(n) {
    let i = this.engine;
    return this.is(0) ? i.box(n) : typeof n == "number" ? n === 0 ? this : typeof this._value == "number" ? i.number(this._value + n) : i.number(this._value.add(n)) : n.numericValue !== null ? typeof this._value == "number" ? typeof n.numericValue == "number" ? i.number(this._value + n.numericValue) : i.number(n.numericValue.add(this._value)) : i.number(this._value.add(n.numericValue)) : H(this.canonical, n.canonical);
  }
  mul(n) {
    if (this.is(1)) return this.engine.box(n);
    if (this.is(-1)) return this.engine.box(n).neg();
    let i = this.engine;
    return typeof n == "number" ? n === 1 ? this : n === 0 || this.is(0) ? this.engine.Zero : n === -1 ? this.neg() : i.number(typeof this._value == "number" ? this._value * n : this._value.mul(n)) : typeof this._value == "number" && typeof n == "number" ? i.number(this._value * n) : n instanceof z ? this.is(1) ? i.number(n) : this.is(-1) ? i.number(n.neg()) : i.number(n.mul(this._value)) : n.numericValue !== null ? i.number(i._numericValue(this._value).mul(n.numericValue)) : ae(this, n);
  }
  div(n) {
    return Hi(this, n);
  }
  pow(n) {
    return me(this, n, { numericApproximation: false });
  }
  root(n) {
    if (!this.isCanonical) return this.canonical.root(n);
    if (typeof n == "number") {
      if (n === 0) return this.engine.NaN;
      if (n === 1) return this;
      if (n === -1) return this.inv();
      if (n === 2) return this.sqrt();
      if (this.isNegative) {
        if (n % 2 === 1) return this.neg().root(n).neg();
        if (n % 2 === 0) return this.neg().root(n);
      }
    } else {
      if (n = n.canonical, n.is(0)) return this.engine.NaN;
      if (n.is(1)) return this;
      if (n.is(-1)) return this.inv();
      if (n.is(2)) return this.sqrt();
      if (this.isNegative) {
        if (n.isOdd) return this.neg().root(n).neg();
        if (n.isEven) return this.neg().root(n);
      }
    }
    let i = typeof n == "number" ? n : n.re;
    if (Number.isInteger(i)) if (typeof this._value == "number") {
      let t = this._value ** (1 / i);
      if (Number.isInteger(t)) return this.engine.number(t);
    } else {
      let t = this._value.root(i);
      if (v(t.type, "integer")) return this.engine.number(t);
    }
    return this.engine._fn("Root", [this, this.engine.box(n)]);
  }
  sqrt() {
    return typeof this._value == "number" ? this._value === 0 || this._value === 1 ? this : this._value === -1 ? this.engine.I : this._value > 0 && Number.isInteger(this._value) && this._value < O ? this.engine.number(this.engine._numericValue({ radical: this._value })) : this.engine.number(this.engine._numericValue(this._value).sqrt()) : this.is(0) || this.is(1) ? this : this.engine.number(this._value.sqrt());
  }
  ln(n) {
    let i = n ? this.engine.box(n) : void 0;
    if (!this.isCanonical) return this.canonical.ln(i);
    if (this.is(0)) return this.engine.NegativeInfinity;
    if (i && this.isSame(i)) return this.engine.One;
    if ((!i || i.symbol === "ExponentialE") && this.symbol === "ExponentialE") return this.engine.One;
    let t = this.re;
    if (Number.isInteger(t) && t > 0) {
      let r = this.engine, [s, o] = Bi(t, 3);
      if (s !== 1) return r.number(s).ln(i).mul(3).add(r.number(o).ln(i));
      if ([s, o] = Bi(t, 2), s !== 1) return r.number(s).ln(i).mul(2).add(r.number(o).ln(i));
    }
    return i && i.isInteger ? typeof this._value == "number" ? this.engine.number(Math.log(this._value) / Math.log(i.re)) : this.engine.number(this._value.ln(i.re)) : i === void 0 ? typeof this._value == "number" ? this.engine.number(Math.log(this._value)) : this.engine.number(this._value.ln()) : this.engine._fn("Ln", [this]);
  }
  get type() {
    return typeof this._value == "number" ? Number.isNaN(this._value) ? new C("number") : Number.isFinite(this._value) ? new C(Number.isInteger(this._value) ? "finite_integer" : "finite_real") : new C("non_finite_number") : new C(this._value.type);
  }
  get sgn() {
    if (this._value === 0) return "zero";
    let n;
    if (typeof this._value == "number") {
      if (Number.isNaN(this._value)) return "unsigned";
      n = Math.sign(this._value);
    } else n = this._value.sgn();
    return n === void 0 || Number.isNaN(n) ? "unsigned" : n === 0 ? "zero" : n > 0 ? "positive" : "negative";
  }
  get numerator() {
    return typeof this._value == "number" ? this : this.engine.number(this._value.numerator);
  }
  get denominator() {
    return typeof this._value == "number" ? this.engine.One : this.engine.number(this._value.denominator);
  }
  get numeratorDenominator() {
    if (typeof this._value == "number") return [this, this.engine.One];
    let n = this.engine;
    return [n.number(this._value.numerator), n.number(this._value.denominator)];
  }
  subs(n, i) {
    return this.isStructural ? this : this.structural.subs(n, i);
  }
  replace(n, i) {
    var _a2, _b;
    return (_b = (_a2 = Mn(this.structural, n, i).at(-1)) == null ? void 0 : _a2.value) != null ? _b : null;
  }
  match(n, i) {
    return st(this.structural, n, i);
  }
  get isPositive() {
    return typeof this._value == "number" ? !Number.isNaN(this._value) && this._value > 0 : ot(this.sgn);
  }
  get isNonNegative() {
    return typeof this._value == "number" ? !Number.isNaN(this._value) && this._value >= 0 : at(this.sgn);
  }
  get isNegative() {
    return typeof this._value == "number" ? !Number.isNaN(this._value) && this._value < 0 : ut(this.sgn);
  }
  get isNonPositive() {
    return typeof this._value == "number" ? !Number.isNaN(this._value) && this._value <= 0 : lt(this.sgn);
  }
  get isOdd() {
    if (this.is(1) || this.is(-1)) return true;
    if (this.is(0)) return false;
    if (!this.isFinite || !this.isInteger) return;
    if (typeof this._value == "number") return this._value % 2 !== 0;
    let [n, i] = [this._value.numerator, this._value.denominator];
    return i.isOne ? n.re % 2 !== 0 : n.re % 2 !== 0 && i.re % 2 === 0;
  }
  get isEven() {
    let n = this.isOdd;
    return n !== void 0 ? !n : void 0;
  }
  get isInfinity() {
    return typeof this._value == "number" ? !Number.isFinite(this._value) && !Number.isNaN(this._value) : Number.isFinite(this._value.im) ? this._value.isPositiveInfinity || this._value.isNegativeInfinity : true;
  }
  get isNaN() {
    return typeof this._value == "number" ? Number.isNaN(this._value) : this._value.isNaN;
  }
  get isFinite() {
    return this.isInfinity === false && this.isNaN === false;
  }
  get isNumber() {
    return true;
  }
  get isInteger() {
    return typeof this._value == "number" ? Number.isInteger(this._value) : v(this._value.type, "integer");
  }
  get isRational() {
    return typeof this._value == "number" ? Number.isInteger(this._value) : v(this._value.type, "rational");
  }
  get isReal() {
    return typeof this._value == "number" ? true : v(this._value.type, "real");
  }
  is(n) {
    return typeof n == "number" ? typeof this._value == "number" ? this._value === n : this._value.eq(n) : false;
  }
  get canonical() {
    return this;
  }
  get isStructural() {
    return typeof this._value == "number" || this.type.matches("rational") ? true : !(this._value instanceof Z);
  }
  get structural() {
    return this.isStructural ? this : this.engine.box(this.json, { canonical: false, structural: true });
  }
  toNumericValue() {
    let n = this._value;
    return typeof n == "number" ? [this.engine._numericValue(n), this.engine.One] : [n, this.engine.One];
  }
  simplify(n) {
    var _a2;
    return (_a2 = Jn(this.canonical.structural, n).at(-1).value) != null ? _a2 : this;
  }
  evaluate(n) {
    return (n == null ? void 0 : n.numericApproximation) ? this.N() : this;
  }
  N() {
    let n = this._value;
    if (typeof n == "number") return this;
    let i = n.N();
    return n === i ? this : this.engine.number(i);
  }
};
function fs(e12, n) {
  if (n == null) return NaN;
  if (n instanceof z) return n;
  if (typeof n == "number") return Number.isInteger(n) && n >= -O && n <= O || !Number.isFinite(n) ? n : e12._numericValue(n);
  if (n instanceof M) {
    let i = n.toNumber();
    return n.isInteger() && Math.abs(i) <= O ? i : n.isNaN() ? NaN : n.isFinite() ? e12._numericValue(n) : i > 0 ? 1 / 0 : -1 / 0;
  }
  if (typeof n == "bigint") return n >= -O && n <= O ? Number(n) : e12._numericValue(n);
  if (n instanceof $) return n.im === 0 ? fs(e12, n.re) : n.isNaN() ? NaN : !n.isFinite() && n.im === 0 ? n.re > 0 ? 1 / 0 : -1 / 0 : e12._numericValue({ re: n.re, im: n.im });
  if (typeof n == "object" && "num" in n) {
    if (typeof n.num == "number") return fs(e12, n.num);
    if (typeof n.num != "string") throw new Error("MathJSON `num` property should be a string of digits");
    return Xf(e12, n.num);
  }
  if (typeof n == "string") return Xf(e12, n);
  if (n[1] == 0) return NaN;
  if (typeof n[1] == "number" && !Number.isFinite(n[1])) return Number.isFinite(n[0]) ? 0 : NaN;
  if (typeof n[0] == "number" && !Number.isFinite(n[0])) {
    let i = n[0] > 0 ? 1 : -1;
    return n[0] > 0 ? i > 0 ? 1 / 0 : -1 / 0 : n[0] < 0 ? i > 0 ? -1 / 0 : 1 / 0 : NaN;
  }
  return e12._numericValue(n);
}
function Xf(e12, n) {
  var _a2;
  if (n = n.toLowerCase(), /[0-9][nd]$/.test(n) && (n = n.slice(0, -1)), n = n.replace(/[\u0009-\u000d\u0020\u00a0]/g, ""), n === "nan") return NaN;
  if (n === "infinity" || n === "+infinity") return Number.POSITIVE_INFINITY;
  if (n === "-infinity") return Number.NEGATIVE_INFINITY;
  if (n === "0") return 0;
  if (n === "1") return 1;
  if (n === "-1") return -1;
  if (/\([0-9]+\)/.test(n)) {
    let [t, r, s, o] = (_a2 = n.match(/(.+)\(([0-9]+)\)(.+)?$/)) != null ? _a2 : [];
    n = r + s.repeat(Math.ceil(e12.precision / s.length)) + (o != null ? o : "");
  }
  let i = K(n);
  return i !== null ? i >= -O && i <= O ? Number(i) : e12._numericValue(i) : e12._numericValue(e12.bignum(n));
}
var Pn = class e10 extends X {
  constructor(i, t, r) {
    var _a2, _b;
    super(i, r == null ? void 0 : r.metadata);
    this._isStructural = false;
    xe(t), `${t}${We(t)}`, this._id = t, this._def = (_a2 = r == null ? void 0 : r.def) != null ? _a2 : void 0, (r == null ? void 0 : r.structural) && (this._isStructural = true), ((_b = r == null ? void 0 : r.canonical) != null ? _b : true) !== true ? this._scope = null : this._def ? this._scope = i.context : this.bind();
  }
  get json() {
    return this._id;
  }
  get hash() {
    return this._hash === void 0 && (this._hash = pn(this._id)), this._hash;
  }
  get isPure() {
    return true;
  }
  get isStructural() {
    return this._isStructural;
  }
  get structural() {
    var _a2;
    return this.isStructural ? this : new e10(this.engine, this._id, { structural: true, def: (_a2 = this._def) != null ? _a2 : void 0 });
  }
  get scope() {
    return this._scope;
  }
  get isConstant() {
    var _a2;
    let i = (_a2 = this._def) != null ? _a2 : this.engine.lookupSymbol(this._id, this.wikidata);
    return !(i instanceof ue) || i.constant;
  }
  _lookupDef() {
    var _a2;
    let i = this.engine;
    return (_a2 = i.lookupSymbol(this._id)) != null ? _a2 : i.lookupFunction(this._id);
  }
  _getDef() {
    var _a2;
    let i = this.symbolDefinition;
    if (!i) return;
    let t = "value" in i ? i.value : void 0;
    return t && t !== this && (i = (_a2 = t.baseDefinition) != null ? _a2 : i), i;
  }
  bind() {
    var _a2, _b;
    this._scope = this.engine.context;
    let i = this._lookupDef();
    if (i) {
      this._def = i;
      return;
    }
    this._def = this.engine.defineSymbol(this._id, { type: "unknown", inferred: true }), this._id = (_b = (_a2 = this._def) == null ? void 0 : _a2.name) != null ? _b : this._id;
  }
  reset() {
    var _a2;
    (_a2 = this._def) == null ? void 0 : _a2.reset();
  }
  get isCanonical() {
    return this._scope !== null;
  }
  set isCanonical(i) {
    this._scope = i ? this.engine.context : null, this._def = void 0;
  }
  is(i) {
    var _a2, _b, _c2;
    return typeof i == "number" ? (_c2 = (_b = (_a2 = this.symbolDefinition) == null ? void 0 : _a2.value) == null ? void 0 : _b.is(i)) != null ? _c2 : false : false;
  }
  get canonical() {
    return this._scope ? this : this.engine.box(this._id);
  }
  toNumericValue() {
    this.isCanonical;
    let i = this.engine;
    return this.symbol === "ImaginaryUnit" ? [i._numericValue({ re: 0, im: 1 }), i.One] : this.symbol === "PositiveInfinity" || this.isInfinity && this.isPositive ? [i._numericValue(1 / 0), i.One] : this.symbol === "NegativeInfinity" || this.isInfinity && this.isNegative ? [i._numericValue(-1 / 0), i.One] : this.symbol === "NaN" ? [i._numericValue(NaN), i.One] : [i._numericValue(1), this];
  }
  neg() {
    return pi(this);
  }
  inv() {
    return this.engine._fn("Divide", [this.engine.One, this]);
  }
  abs() {
    return this.isNonNegative ? this : this.isNonPositive ? this.neg() : this.engine._fn("Abs", [this]);
  }
  add(i) {
    return i === 0 ? this : H(this.canonical, this.engine.box(i));
  }
  mul(i) {
    if (i === 1) return this;
    if (i === -1) return this.neg();
    if (i === 0) return this.engine.Zero;
    if (i instanceof z) {
      if (i.isOne) return this;
      if (i.isNegativeOne) return this.neg();
      if (i.isZero) return this.engine.Zero;
    }
    return ae(this.canonical, this.engine.box(i));
  }
  div(i) {
    return Hi(this, i);
  }
  pow(i) {
    return me(this, i, { numericApproximation: false });
  }
  root(i) {
    if (!this.isCanonical) return this.canonical.root(i);
    typeof i != "number" && (i = i.canonical);
    let t = typeof i == "number" ? i : i.im === 0 ? i.re : void 0, r = this.engine;
    return this.symbol === "ComplexInfinity" || t === 0 ? r.NaN : t === 1 ? this : t === 2 ? this.sqrt() : t === -1 ? this.inv() : r._fn("Root", [this, r.box(i)]);
  }
  sqrt() {
    let i = this.engine;
    return this.symbol === "ComplexInfinity" ? i.NaN : this.is(0) ? this : this.is(1) ? this.engine.One : this.is(-1) ? i.I : i._fn("Sqrt", [this]);
  }
  ln(i) {
    let t = i ? this.engine.box(i) : void 0;
    return this.isCanonical ? this.is(0) ? this.engine.NegativeInfinity : (!t || t.symbol === "ExponentialE") && this.symbol === "ExponentialE" ? this.engine.One : t ? t.re === 10 ? this.engine._fn("Log", [this]) : this.engine._fn("Log", [this, t]) : this.engine._fn("Ln", [this]) : this.canonical.ln(t);
  }
  solve(i) {
    let t = vt(i);
    return t.length !== 1 ? null : t.includes(this.symbol) ? [this.engine.Zero] : null;
  }
  get complexity() {
    return 7;
  }
  get operator() {
    return "Symbol";
  }
  get symbol() {
    return this._id;
  }
  get baseDefinition() {
    var _a2;
    return this._def === void 0 && this.bind(), (_a2 = this._def) != null ? _a2 : void 0;
  }
  get symbolDefinition() {
    return this._def === void 0 && this.bind(), this._def instanceof ue ? this._def : void 0;
  }
  get functionDefinition() {
    return this._def === void 0 && this.bind(), this._def instanceof Le ? this._def : void 0;
  }
  infer(i) {
    var _a2;
    let t = this._lookupDef();
    if (!t) {
      let r = this.engine.swapScope((_a2 = this._scope) != null ? _a2 : this.engine.context);
      return this._def = this.engine.defineSymbol(this._id, { type: i, inferred: true }), this.engine.swapScope(r), true;
    }
    return t instanceof ue && (t.inferredType || t.type.isUnknown) ? (t.type = ke(t.type.type, i), true) : false;
  }
  get value() {
    var _a2, _b;
    return (_b = (_a2 = this.symbolDefinition) == null ? void 0 : _a2.value) == null ? void 0 : _b.value;
  }
  set value(i) {
    var _a2;
    let t = this.engine;
    t.forget(this._id);
    let r;
    if (typeof i == "boolean" && (i = i ? t.True : t.False), typeof i == "string" && (i = t.string(i)), typeof i == "object") if ("re" in i && "im" in i) i = t.complex((_a2 = i.re) != null ? _a2 : 0, i.im);
    else if ("num" in i && "denom" in i) i = t.number([i.num, i.denom]);
    else if (Array.isArray(i)) i = t._fn("List", i.map((o) => t.box(o)));
    else throw new Error(`Invalid value for symbol ${this._id}: ${i}`);
    if (i !== void 0 && (r = t.box(i).evaluate()), r == null ? void 0 : r.type.matches("function")) {
      this.engine.lookupSymbol(this._id), this._def = t.defineFunction(this._id, { signature: r.type.toString(), evaluate: r });
      return;
    }
    let s = this.engine.lookupSymbol(this._id);
    s && s instanceof ue ? s.value = r : this._def = t.defineSymbol(this._id, { value: r, type: r == null ? void 0 : r.type.toString() });
  }
  get type() {
    let i = this._def;
    return i ? i instanceof ue ? i.type : i instanceof Le ? i.signature : C.unknown : C.unknown;
  }
  set type(i) {
    if (this._def) {
      if (i instanceof C && (i = i.type), this._id[0] === "_") throw new Error(`The type of the wildcard "${this._id}" cannot be changed`);
      i === "function" || Xn(i) ? (this.engine.forget(this._id), this._def = this.engine.defineFunction(this._id, { signature: i.toString() })) : this._def instanceof ue ? this._def.type = typeof i == "string" ? k(i) : i : (this.engine.forget(this._id), this._def = this.engine.defineSymbol(this._id, { type: i.toString() }));
    }
  }
  get sgn() {
    let i = this._def;
    if (!(!i || !(i instanceof ue))) return i.sgn;
  }
  has(i) {
    return typeof i == "string" ? this._id === i : i.includes(this._id);
  }
  match(i, t) {
    return st(this, i, t);
  }
  get isFunction() {
    return !!this.functionDefinition;
  }
  get isOdd() {
    var _a2;
    return (_a2 = this.symbolDefinition) == null ? void 0 : _a2.odd;
  }
  get isEven() {
    var _a2;
    return (_a2 = this.symbolDefinition) == null ? void 0 : _a2.even;
  }
  get isInfinity() {
    let i = this.sgn;
    return i === "negative-infinity" || i === "positive-infinity";
  }
  get isNaN() {
    return this.sgn === "nan";
  }
  get isPositive() {
    return ot(this.sgn);
  }
  get isNonPositive() {
    return lt(this.sgn);
  }
  get isNegative() {
    return ut(this.sgn);
  }
  get isNonNegative() {
    return at(this.sgn);
  }
  get isNumber() {
    let i = this.type;
    if (!i.isUnknown) return i.matches("number");
  }
  get isInteger() {
    var _a2;
    if ((_a2 = this.symbolDefinition) == null ? void 0 : _a2.inferredType) return;
    let i = this.type;
    if (!i.isUnknown) return i.matches("integer");
  }
  get isRational() {
    var _a2;
    if ((_a2 = this.symbolDefinition) == null ? void 0 : _a2.inferredType) return;
    let i = this.type;
    if (!i.isUnknown) return i.matches("rational");
  }
  get isReal() {
    var _a2;
    if ((_a2 = this.symbolDefinition) == null ? void 0 : _a2.inferredType) return;
    let i = this.type;
    if (!i.isUnknown) return i.matches("real");
  }
  get re() {
    var _a2, _b, _c2;
    return (_c2 = (_b = (_a2 = this.symbolDefinition) == null ? void 0 : _a2.value) == null ? void 0 : _b.re) != null ? _c2 : NaN;
  }
  get im() {
    var _a2, _b, _c2;
    return (_c2 = (_b = (_a2 = this.symbolDefinition) == null ? void 0 : _a2.value) == null ? void 0 : _b.im) != null ? _c2 : NaN;
  }
  get bignumRe() {
    var _a2, _b;
    return (_b = (_a2 = this.symbolDefinition) == null ? void 0 : _a2.value) == null ? void 0 : _b.bignumRe;
  }
  get bignumIm() {
    var _a2, _b;
    return (_b = (_a2 = this.symbolDefinition) == null ? void 0 : _a2.value) == null ? void 0 : _b.bignumIm;
  }
  simplify(i) {
    var _a2, _b;
    return (_b = (_a2 = Jn(this, i).at(-1)) == null ? void 0 : _a2.value) != null ? _b : this;
  }
  evaluate(i) {
    var _a2, _b, _c2, _d2;
    let t = this.symbolDefinition;
    if (!t) return this;
    let r = t.holdUntil;
    if (i == null ? void 0 : i.numericApproximation) {
      if (r === "never" || r === "evaluate" || r === "N") return (_b = (_a2 = t.value) == null ? void 0 : _a2.N()) != null ? _b : this;
    } else if (r === "never" || r === "evaluate") return (_d2 = (_c2 = t.value) == null ? void 0 : _c2.evaluate(i)) != null ? _d2 : this;
    return this;
  }
  N() {
    var _a2, _b;
    let i = this.symbolDefinition;
    return i && i.holdUntil === "never" ? this : (_b = (_a2 = i == null ? void 0 : i.value) == null ? void 0 : _a2.N()) != null ? _b : this;
  }
  replace(i, t) {
    var _a2, _b;
    return (_b = (_a2 = Mn(this, i, t).at(-1)) == null ? void 0 : _a2.value) != null ? _b : null;
  }
  subs(i, t) {
    var _a2;
    let r = (_a2 = t == null ? void 0 : t.canonical) != null ? _a2 : this.isCanonical;
    return i[this._id] === void 0 ? r ? this.canonical : this : this.engine.box(i[this._id], { canonical: r });
  }
  get isCollection() {
    var _a2, _b;
    return ((_b = (_a2 = this._getDef()) == null ? void 0 : _a2.collection) == null ? void 0 : _b.contains) !== void 0;
  }
  contains(i) {
    var _a2, _b, _c2, _d2;
    return (_d2 = (_c2 = (_b = (_a2 = this._getDef()) == null ? void 0 : _a2.collection) == null ? void 0 : _b.contains) == null ? void 0 : _c2.call(_b, this, i)) != null ? _d2 : false;
  }
  get size() {
    var _a2, _b, _c2, _d2;
    return (_d2 = (_c2 = (_b = (_a2 = this._getDef()) == null ? void 0 : _a2.collection) == null ? void 0 : _b.size) == null ? void 0 : _c2.call(_b, this)) != null ? _d2 : 0;
  }
  each(i, t) {
    var _a2, _b, _c2;
    let r = (_c2 = (_b = (_a2 = this._getDef()) == null ? void 0 : _a2.collection) == null ? void 0 : _b.iterator) == null ? void 0 : _c2.call(_b, this, i, t);
    return r || { next() {
      return { done: true, value: void 0 };
    } };
  }
  at(i) {
    var _a2, _b, _c2;
    return (_c2 = (_b = (_a2 = this._getDef()) == null ? void 0 : _a2.collection) == null ? void 0 : _b.at) == null ? void 0 : _c2.call(_b, this, i);
  }
  get(i) {
    var _a2, _b, _c2, _d2, _e2, _f2;
    if (typeof i == "string") return (_c2 = (_b = (_a2 = this.baseDefinition) == null ? void 0 : _a2.collection) == null ? void 0 : _b.at) == null ? void 0 : _c2.call(_b, this, i);
    if (i.string) return (_f2 = (_e2 = (_d2 = this.symbolDefinition) == null ? void 0 : _d2.collection) == null ? void 0 : _e2.at) == null ? void 0 : _f2.call(_e2, this, i.string);
  }
  indexOf(i) {
    var _a2, _b, _c2, _d2;
    return (_d2 = (_c2 = (_b = (_a2 = this._getDef()) == null ? void 0 : _a2.collection) == null ? void 0 : _b.indexOf) == null ? void 0 : _c2.call(_b, this, i)) != null ? _d2 : -1;
  }
  subsetOf(i, t) {
    var _a2, _b, _c2, _d2;
    return (_d2 = (_c2 = (_b = (_a2 = this._getDef()) == null ? void 0 : _a2.collection) == null ? void 0 : _b.subsetOf) == null ? void 0 : _c2.call(_b, this, i, t)) != null ? _d2 : false;
  }
};
function Kf(e12, n) {
  let i = e12.lookupSymbol(n);
  if ((i == null ? void 0 : i.holdUntil) === "never" && i.value) return i.value;
  if (i) return new Pn(e12, n, { canonical: true, def: i });
  let t = e12.lookupFunction(n);
  return t ? new Pn(e12, n, { canonical: true, def: t }) : new Pn(e12, n, { canonical: true });
}
var er = "\x1B[0m";
var ec = "\x1B[33m";
var nc = "\x1B[36;1m";
var ra = "\x1B[101;97m";
var bm = { "\\mathord": "", "\\mathop": "", "\\mathbin": "", "\\mathrel": "", "\\mathopen": "", "\\mathclose": "", "\\mathpunct": "", "\\mathinner": "", "\\operatorname": "", "\\mathrm": "_upright", "\\mathit": "_italic", "\\mathbf": "_bold", "\\mathscr": "_script", "\\mathcal": "_calligraphic", "\\mathfrak": "_fraktur", "\\mathsf": "_sansserif", "\\mathtt": "_monospace", "\\mathbb": "_doublestruck" };
var Em = { "\\mathring": "_ring", "\\hat": "_hat", "\\tilde": "_tilde", "\\vec": "_vec", "\\overline": "_bar", "\\underline": "_underbar", "\\dot": "_dot", "\\ddot": "_ddot", "\\dddot": "_dddot", "\\ddddot": "_ddddot", "\\acute": "_acute", "\\grave": "_grave", "\\breve": "_breve", "\\check": "_check" };
function ic(e12, n) {
  var _a2;
  if (e12.atEnd) return null;
  let i = e12.peek, t = { "\\_": "_", "\\#": "hash" }[i];
  if (!t && !n.toplevel && (t = { "+": "plus", "-": "minus", "\\plusmn": "pm", "\\pm": "pm", "\\ast": "ast", "\\dag": "dag", "\\ddag": "ddag", "\\bot": "bottom", "\\top": "top", "\\bullet": "bullet", "\\cir": "circle", "\\diamond": "diamond", "\\times": "times", "\\square": "square", "\\star": "star" }[i]), t) return e12.nextToken(), t;
  let r = sn.findIndex((s) => s[1] === i);
  return r >= 0 ? (e12.nextToken(), sn[r][0]) : (_a2 = e12.matchChar()) != null ? _a2 : e12.nextToken();
}
function cs(e12) {
  var _a2;
  let n = sa(e12), i = (_a2 = Em[e12.peek]) != null ? _a2 : null;
  if (i) {
    if (e12.nextToken(), !e12.match("<{>")) return null;
    let s = cs(e12);
    if (s === null || !e12.match("<}>")) return null;
    n = `${s}${i}`;
  }
  if (n === null) {
    for (n = ""; !e12.atEnd; ) {
      let s = e12.peek;
      if (s === "<}>" || s === "_" || s === "^") break;
      let o = ic(e12, { toplevel: false });
      if (o === null) return null;
      n += o;
    }
    for (; !e12.atEnd && /\d/.test(e12.peek); ) n += e12.nextToken();
  }
  for (; !e12.atEnd; ) if (e12.match("\\degree")) n += "_deg";
  else if (e12.matchAll(["^", "\\circ"])) n += "_deg";
  else if (e12.matchAll(["^", "\\prime"])) n += "_prime";
  else if (e12.matchAll(["^", "<{>", "\\prime", "<}>"])) n += "_prime";
  else if (e12.matchAll(["^", "<{>", "\\doubleprime", "<}>"])) n += "_dprime";
  else if (e12.matchAll(["^", "<{>", "\\prime", "\\prime", "<}>"])) n += "_dprime";
  else break;
  let t = [], r = [];
  for (; !e12.atEnd; ) if (e12.match("_")) {
    let s = e12.match("<{>"), o = cs(e12);
    if (s && !e12.match("<}>") || o === null) return null;
    r.push(o);
  } else if (e12.match("^")) {
    let s = e12.match("<{>"), o = cs(e12);
    if (s && !e12.match("<}>") || o === null) return null;
    t.push(o);
  } else break;
  return t.length > 0 && (n += "__" + t.join("")), r.length > 0 && (n += "_" + r.join("")), n;
}
function sa(e12) {
  var _a2, _b;
  let n = (_a2 = bm[e12.peek]) != null ? _a2 : null;
  if (n === null) return null;
  if (e12.nextToken(), e12.match("<{>")) {
    let i = "", t = (_b = { 0: "zero", 1: "one", 2: "two", 3: "three", 4: "four", 5: "five", 6: "six", 7: "seven", 8: "eight", 9: "nine" }[e12.peek]) != null ? _b : "";
    return t && (i = t, e12.nextToken()), i += cs(e12), i === null || !e12.match("<}>") ? null : n === "_upright" && i.length > 1 ? i : i + n;
  }
  return null;
}
function oa(e12) {
  let n = e12.index, i = sa(e12);
  return i === null || xe(i) ? null : e12.error(["invalid-identifier", { str: We(i) }], n);
}
function nr(e12) {
  if (/^[a-zA-Z]$/.test(e12.peek) || /^\p{XIDS}$/u.test(e12.peek)) return e12.nextToken();
  let n = sa(e12);
  if (!n) {
    for (n = ""; !e12.atEnd && Gi.test(n + e12.peek); ) n += e12.nextToken();
    n || (n = null);
  }
  let i = e12.index;
  return n != null ? n : n = ic(e12, { toplevel: true }), n && (n = n.normalize(), xe(n)) ? n : (e12.index = i, null);
}
var Nm = { "(": ["\\lparen", "("], ")": ["\\rparen", ")"], "[": ["\\lbrack", "\\[", "["], "]": ["\\rbrack", "\\]", "]"], "<": ["<", "\\langle"], ">": [">", "\\rangle"], "{": ["\\{", "\\lbrace"], "}": ["\\}", "\\rbrace"], ":": [":", "\\colon"], "|": ["|", "\\|", "\\lvert", "\\rvert"], "||": ["||", "\\Vert", "\\lVert", "\\rVert"] };
var ua = { "\\left": "\\right", "\\bigl": "\\bigr", "\\Bigl": "\\Bigr", "\\biggl": "\\biggr", "\\Biggl": "\\Biggr", "\\big": "\\big", "\\Big": "\\Big", "\\bigg": "\\bigg", "\\Bigg": "\\Bigg" };
var la = { "(": ")", "[": "]", "|": "|", "\\{": "\\}", "\\[": "\\]", "\\lbrace": "\\rbrace", "\\lparen": "\\rparen", "\\langle": "\\rangle", "\\lfloor": "\\rfloor", "\\lceil": "\\rceil", "\\vert": "\\vert", "\\lvert": "\\rvert", "\\Vert": "\\Vert", "\\lVert": "\\rVert", "\\lbrack": "\\rbrack", "\\ulcorner": "\\urcorner", "\\llcorner": "\\lrcorner", "\\lgroup": "\\rgroup", "\\lmoustache": "\\rmoustache", "\\llbracket": "\\rrbracket" };
var fa = class {
  constructor(n, i, t) {
    this._index = 0;
    this.symbolTable = { parent: null, ids: {} };
    this._boundaries = [];
    this._lastPeek = "";
    this._peekCounter = 0;
    this._tokens = n, this.options = t, this._dictionary = i, this._positiveInfinityTokens = de(this.options.positiveInfinity), this._negativeInfinityTokens = de(this.options.negativeInfinity), this._notANumberTokens = de(this.options.notANumber), this._decimalSeparatorTokens = de(this.options.decimalSeparator), this._wholeDigitGroupSeparatorTokens = [], this._fractionalDigitGroupSeparatorTokens = [], this.options.digitGroupSeparator && (typeof this.options.digitGroupSeparator == "string" ? (this._wholeDigitGroupSeparatorTokens = de(this.options.digitGroupSeparator), this._fractionalDigitGroupSeparatorTokens = this._wholeDigitGroupSeparatorTokens) : Array.isArray(this.options.digitGroupSeparator) && (this._wholeDigitGroupSeparatorTokens = de(this.options.digitGroupSeparator[0]), this._fractionalDigitGroupSeparatorTokens = de(this.options.digitGroupSeparator[1]))), this._exponentProductTokens = de(this.options.exponentProduct), this._beginExponentMarkerTokens = de(this.options.beginExponentMarker), this._endExponentMarkerTokens = de(this.options.endExponentMarker), this._truncationMarkerTokens = de(this.options.truncationMarker), this._imaginaryUnitTokens = de(this.options.imaginaryUnit);
  }
  pushSymbolTable() {
    this.symbolTable = { parent: this.symbolTable, ids: {} };
  }
  popSymbolTable() {
    var _a2;
    this.symbolTable = (_a2 = this.symbolTable.parent) != null ? _a2 : this.symbolTable;
  }
  addSymbol(n, i) {
    if (n in this.symbolTable.ids && this.symbolTable.ids[n] !== i) throw new Error(`Symbol ${n} already declared as a different type`);
    this.symbolTable.ids[n] = i;
  }
  get index() {
    return this._index;
  }
  set index(n) {
    this._index = n, this._lastPeek = "", this._peekCounter = 0;
  }
  getIdentifierType(n) {
    let i = this.symbolTable;
    for (; i; ) {
      if (n in i.ids) return i.ids[n];
      i = i.parent;
    }
    return this.options.getIdentifierType ? this.options.getIdentifierType(n) : "unknown";
  }
  get peek() {
    let n = this._tokens[this.index];
    if (n === this._lastPeek ? this._peekCounter += 1 : this._peekCounter = 0, this._peekCounter >= 1024) {
      let i = `Infinite loop detected while parsing "${this.latex(0)}" at "${this._lastPeek}" (index ${this.index})`;
      throw console.error(i), new Error(i);
    }
    return this._lastPeek = n, n;
  }
  nextToken() {
    return this._tokens[this.index++];
  }
  get atEnd() {
    return this.index >= this._tokens.length;
  }
  atTerminator(n) {
    var _a2;
    return this.atBoundary || ((_a2 = (n == null ? void 0 : n.condition) && n.condition(this)) != null ? _a2 : false);
  }
  get atBoundary() {
    if (this.atEnd) return true;
    let n = this.index;
    for (let i of this._boundaries) if (this.matchAll(i.tokens)) return this.index = n, true;
    return false;
  }
  addBoundary(n) {
    this._boundaries.push({ index: this.index, tokens: n });
  }
  removeBoundary() {
    this._boundaries.pop();
  }
  matchBoundary() {
    let n = this._boundaries[this._boundaries.length - 1], i = n && this.matchAll(n.tokens);
    return i && this._boundaries.pop(), i;
  }
  boundaryError(n) {
    let i = this._boundaries[this._boundaries.length - 1];
    return this._boundaries.pop(), this.error(n, i.index);
  }
  latex(n, i) {
    return tn(this._tokens.slice(n, i));
  }
  latexAhead(n) {
    return this.latex(this.index, this.index + n);
  }
  lookAhead() {
    let n = Math.min(this._dictionary.lookahead, this._tokens.length - this.index);
    if (n <= 0) return [];
    let i = [];
    for (; n > 0; ) i.push([n, this.latexAhead(n--)]);
    return i;
  }
  peekDefinitions(n) {
    if (this.atEnd) return [];
    let i = [], t = [...this.getDefs(n)];
    for (let r of t) r.latexTrigger === "" && i.push([r, 0]);
    for (let [r, s] of this.lookAhead()) for (let o of t) o.latexTrigger === s && i.push([o, r]);
    for (let r of t) if (r.identifierTrigger) {
      let s = vm(this, r.identifierTrigger);
      s > 0 && i.push([r, s]);
    }
    return i;
  }
  skipSpaceTokens() {
    for (; this.match("<space>"); ) ;
  }
  skipSpace() {
    if (!this.atEnd && this.peek === "<{>") {
      let i = this.index;
      for (this.nextToken(); this.match("<space>"); ) ;
      if (this.nextToken() === "<}>") return this.skipSpace(), true;
      this.index = i;
    }
    if (!this.options.skipSpace) return false;
    let n = false;
    for (; this.match("<space>"); ) n = true;
    return n && this.skipSpace(), n;
  }
  skipVisualSpace() {
    this.options.skipSpace && (this.skipSpace(), ["\\!", "\\,", "\\:", "\\;", "\\enskip", "\\enspace", "\\space", "\\quad", "\\qquad"].includes(this.peek) && (this.nextToken(), this.skipVisualSpace()), this.skipSpace());
  }
  match(n) {
    return this._tokens[this.index] !== n ? false : (this.index++, true);
  }
  matchAll(n) {
    if (n.length === 0) return false;
    let i, t = 0;
    do
      i = this._tokens[this.index + t] === n[t++];
    while (i && t < n.length);
    return i && (this.index += t), i;
  }
  matchAny(n) {
    return n.includes(this._tokens[this.index]) ? this._tokens[this.index++] : "";
  }
  matchLatexNumber(n = true) {
    var _a2, _b;
    let i = false, t = this.peek;
    for (; t === "<space>" || t === "+" || t === "-"; ) t === "-" && (i = !i), this.nextToken(), t = this.peek;
    let r = 10, s = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
    if (this.match("'")) r = 8, s = ["0", "1", "2", "3", "4", "5", "6", "7"], n = true;
    else if (this.match('"') || this.match("x")) r = 16, s = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"], n = true;
    else if (this.match("`")) return t = this.nextToken(), t ? t.startsWith("\\") && t.length === 2 ? (i ? -1 : 1) * ((_a2 = t.codePointAt(1)) != null ? _a2 : 0) : (i ? -1 : 1) * ((_b = t.codePointAt(0)) != null ? _b : 0) : null;
    let o = "";
    for (; s.includes(this.peek); ) o += this.nextToken();
    if (!n && this.match(".")) for (o += "."; s.includes(this.peek); ) o += this.nextToken();
    let a = n ? Number.parseInt(o, r) : Number.parseFloat(o);
    return Number.isNaN(a) ? null : i ? -a : a;
  }
  matchChar() {
    var _a2;
    let n = this.index, i = 0;
    for (; this.match("^"); ) i += 1;
    if (i < 2 && (this.index = n), i >= 2) {
      let t = "", r = 0;
      for (; r != i; ) {
        let s = this.matchAny(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"]);
        if (!s) break;
        t += s, r += 1;
      }
      if (t.length === i) return String.fromCodePoint(Number.parseInt(t, 16));
    } else if (this.match("\\char")) {
      let t = Math.floor((_a2 = this.matchLatexNumber()) != null ? _a2 : Number.NaN);
      return (!Number.isFinite(t) || t < 0 || t > 1114111) && (t = 10067), String.fromCodePoint(t);
    } else if (this.match("\\unicode")) if (this.skipSpaceTokens(), this.match("<{>")) {
      let t = this.matchLatexNumber();
      if (this.match("<}>") && t !== null && t >= 0 && t <= 1114111) return String.fromCodePoint(t);
    } else {
      let t = this.matchLatexNumber();
      if (t !== null && t >= 0 && t <= 1114111) return String.fromCodePoint(t);
    }
    return this.index = n, null;
  }
  matchDelimiter(n, i) {
    var _a2, _b;
    if (Array.isArray(n)) return Array.isArray(i), this.matchAll(n) ? (this.addBoundary(i), true) : false;
    Array.isArray(i);
    let t = this.index, r = ua[this.peek];
    return r && this.nextToken(), n === "||" && this.matchAll(["|", "|"]) ? (this.addBoundary(["|", "|"]), true) : ((_a2 = Nm[n]) != null ? _a2 : [n]).includes(this.peek) ? (n = this.nextToken(), i = (_b = la[n]) != null ? _b : i, this.addBoundary(r ? [r, i] : [i]), true) : (this.index = t, false);
  }
  parseGroup() {
    let n = this.index;
    if (this.skipSpaceTokens(), this.match("<{>")) {
      this.addBoundary(["<}>"]);
      let i = this.parseExpression();
      if (this.skipSpace(), this.matchBoundary()) return i != null ? i : "Nothing";
      for (; !this.matchBoundary() && !this.atEnd; ) this.nextToken();
      if (h(i) === "Error") return i;
      let t = this.error("expected-closing-delimiter", n);
      return i !== null ? ["InvisibleOperator", i, t] : t;
    }
    return this.index = n, null;
  }
  parseOptionalGroup() {
    let n = this.index;
    if (this.skipSpaceTokens(), this.match("[")) {
      this.addBoundary(["]"]);
      let i = this.parseExpression();
      return this.skipSpace(), this.matchBoundary() ? i : this.boundaryError("expected-closing-delimiter");
    }
    return this.index = n, null;
  }
  parseToken() {
    var _a2;
    return this.skipSpace(), [...'!"#$%&(),/;:?@[]\\`|~'.split(""), "\\left", "\\bigl"].includes(this.peek) ? null : /^[0-9]$/.test(this.peek) ? parseInt(this.nextToken(), 10) : (_a2 = this.parseGenericExpression()) != null ? _a2 : this.parseSymbol();
  }
  parseTabular() {
    var _a2;
    let n = [], i = [], t = null;
    for (; !this.atBoundary; ) if (this.skipSpace(), this.match("&")) i.push(t != null ? t : "Nothing"), t = null;
    else if (this.match("\\\\") || this.match("\\cr")) this.skipSpace(), this.parseOptionalGroup(), t !== null && i.push(t), n.push(i), i = [], t = null;
    else {
      let r = [], s = this.peek;
      for (; s !== "&" && s !== "\\\\" && s !== "\\cr" && !this.atBoundary; ) t = this.parseExpression({ minPrec: 0, condition: (o) => {
        let a = o.peek;
        return a === "&" || a === "\\\\" || a === "\\cr";
      } }), t !== null ? r.push(t) : (r.push(["Error", "'unexpected-token'", { str: tn(s) }]), this.nextToken()), this.skipSpace(), s = this.peek;
      r.length > 1 ? t = ["Sequence", ...r] : t = (_a2 = r[0]) != null ? _a2 : "Nothing";
    }
    return t !== null && i.push(t), i.length > 0 && n.push(i), n;
  }
  parseStringGroupContent() {
    let n = this.index, i = "", t = 0;
    for (; !this.atBoundary || t > 0; ) {
      let r = this.nextToken();
      if (r === "<$>" || r === "<$$>") return this.index = n, "";
      r === "<{>" ? (t += 1, i += "\\{") : r === "<}>" ? (t -= 1, i += "\\}") : r === "<space>" ? i += " " : (r[0], i += r);
    }
    return i;
  }
  parseStringGroup(n) {
    n === void 0 && (n = false);
    let i = this.index;
    for (; this.match("<space>"); ) ;
    if (this.match(n ? "[" : "<{>")) {
      this.addBoundary([n ? "]" : "<}>"]);
      let t = this.parseStringGroupContent();
      if (this.matchBoundary()) return t;
      this.removeBoundary();
    }
    return this.index = i, null;
  }
  parseEnvironment(n) {
    var _a2;
    let i = this.index;
    if (!this.match("\\begin")) return null;
    let t = (_a2 = this.parseStringGroup()) == null ? void 0 : _a2.trim();
    if (!t) return this.error("expected-environment-name", i);
    this.addBoundary(["\\end", "<{>", ...t.split(""), "<}>"]);
    for (let r of this.getDefs("environment")) if (r.identifierTrigger === t) {
      let s = r.parse(this, n);
      return this.skipSpace(), this.matchBoundary() ? s !== null ? this.decorate(s, i) : (this.index = i, null) : this.boundaryError("unbalanced-environment");
    }
    return this.parseTabular(), this.skipSpace(), this.matchBoundary() ? this.error(["unknown-environment", { str: t }], i) : this.boundaryError("unbalanced-environment");
  }
  parseOptionalSign() {
    let n = !!this.matchAny(["-", "\u2212"]);
    for (; this.matchAny(["+", "\uFE62"]) || this.skipSpace(); ) this.matchAny(["-", "\u2212"]) && (n = !n);
    return n ? "-" : "+";
  }
  parseDecimalDigits(n = "whole") {
    let i = [], t = false;
    for (; !t; ) {
      for (; /^[0-9]$/.test(this.peek); ) i.push(this.nextToken()), this.skipVisualSpace();
      t = true;
      let r = n === "whole" ? this._wholeDigitGroupSeparatorTokens : this._fractionalDigitGroupSeparatorTokens;
      if (n !== "none" && r.length > 0) {
        let s = this.index;
        this.skipVisualSpace(), this.matchAll(r) && (this.skipVisualSpace(), /^[0-9]$/.test(this.peek) ? t = false : this.index = s);
      }
    }
    return i.join("");
  }
  parseSignedInteger(n) {
    let i = this.index, t = this.parseOptionalSign(), r = this.parseDecimalDigits(n);
    return r ? t === "-" ? "-" + r : r : (this.index = i, "");
  }
  parseExponent() {
    let n = this.index;
    if (this.skipVisualSpace(), this.matchAny(["e", "E"])) {
      let i = this.parseSignedInteger("none");
      if (i) return i;
    }
    if (this.index = n, this.match("\\times") && (this.skipVisualSpace(), this.matchAll(["1", "0"]) && (this.skipVisualSpace(), this.match("^")))) {
      if (this.skipVisualSpace(), /^[0-9]$/.test(this.peek)) return this.nextToken();
      if (this.match("<{>")) {
        this.skipVisualSpace();
        let i = this.parseSignedInteger("whole");
        if (this.skipVisualSpace(), i && this.match("<}>")) return i;
      }
    }
    if (this.index = n, this.skipVisualSpace(), this.match("\\%")) return "-2";
    if (this.index = n, this.matchAll(this._exponentProductTokens) && (this.skipVisualSpace(), this.matchAll(this._beginExponentMarkerTokens))) {
      this.skipVisualSpace();
      let i = this.parseSignedInteger("none");
      if (this.skipVisualSpace(), i && this.matchAll(this._endExponentMarkerTokens)) return i;
    }
    return this.index = n, "";
  }
  parseRepeatingDecimal() {
    let n = this.index, i = this.options.repeatingDecimal, t = "";
    if ((i === "auto" || i === "parentheses") && this.match("(")) return t = this.parseDecimalDigits("fraction"), t && this.match(")") ? `(${t})` : (this.index = n, "");
    if (this.index = n, (i === "auto" || i === "parentheses") && this.matchAll(["\\left", "("])) return t = this.parseDecimalDigits("fraction"), t && this.matchAll(["\\right", ")"]) ? `(${t})` : (this.index = n, "");
    if (this.index = n, (i === "auto" || i === "vinculum") && this.matchAll(["\\overline", "<{>"])) return t = this.parseDecimalDigits("fraction"), t && this.match("<}>") ? `(${t})` : (this.index = n, "");
    if (this.index = n, (i === "auto" || i === "arc") && (this.matchAll(["\\wideparen", "<{>"]) || this.matchAll(["\\overarc", "<{>"]))) return t = this.parseDecimalDigits("fraction"), t && this.match("<}>") ? `(${t})` : (this.index = n, "");
    if (this.index = n, i === "auto" || i === "dots") {
      let r = rc(this);
      if (r !== null) {
        if (t = this.parseDecimalDigits("fraction"), !t) return `(${r})`;
        let s = rc(this);
        if (s !== null) return `(${r}${t}${s})`;
      }
    }
    return this.index = n, "";
  }
  parseNumber() {
    if (this.options.parseNumbers === false || this.options.parseNumbers === "never") return null;
    let n = this.index;
    this.skipVisualSpace();
    let i = 1;
    for (; this.peek === "-" || this.peek === "+"; ) this.match("-") ? i = -i : this.match("+"), this.skipVisualSpace();
    let t = "", r = "", s = false;
    if (this.match(".") || this.matchAll(this._decimalSeparatorTokens)) {
      let f = this.peek;
      (/^[\d]$/.test(f) || Sm(this)) && (s = true, t = "0");
    } else t = this.parseDecimalDigits("whole");
    if (!t) return this.index = n, null;
    let o = this.index, a = false;
    (s || this.match(".") || this.matchAll(this._decimalSeparatorTokens)) && (r = this.parseDecimalDigits("fraction"), a = true);
    let u = false;
    if (a) {
      let f = this.parseRepeatingDecimal();
      f && (r += f, u = true), this.match("\\ldots") || this.matchAll(this._truncationMarkerTokens);
    }
    if (a && !r) return this.index = o, t.length < 10 ? aa(i * parseInt(t, 10)) : { num: i < 0 ? "-" + t : t };
    let l = this.parseExponent();
    if (!a && !l && t.length < 10) return aa(i * parseInt(t, 10));
    if (!u && this.options.parseNumbers === "rational") {
      let f = parseInt(t, 10);
      if (!r) return l ? ["Multiply", i * f, ["Power", 10, l]] : aa(i * f);
      let c = parseInt(r, 10), p = r.length, m = f * 10 ** p + c, y = 10 ** p;
      return l ? ["Multiply", ["Rational", i * m, y], ["Power", 10, l]] : ["Rational", i * m, y];
    }
    return { num: (i < 0 ? "-" : "") + t + (a ? "." + r : "") + (l ? "e" + l : "") };
  }
  parsePrefixOperator(n) {
    n || (n = { minPrec: 0 }), n.minPrec || (n = { ...n, minPrec: 0 });
    let i = this.index;
    for (let [t, r] of this.peekDefinitions("prefix")) {
      this.index = i + r;
      let s = t.parse(this, { ...n, minPrec: t.precedence + 1 });
      if (s !== null) return s;
    }
    return this.index = i, null;
  }
  parseInfixOperator(n, i) {
    i != null ? i : i = { minPrec: 0 }, i.minPrec, i.minPrec === void 0 && (i = { ...i, minPrec: 0 });
    let t = this.index;
    for (let [r, s] of this.peekDefinitions("infix")) if (r.precedence >= i.minPrec) {
      this.index = t + s;
      let o = r.parse(this, n, i);
      if (o !== null) return o;
    }
    return this.index = t, null;
  }
  parseArguments(n = "enclosure", i) {
    var _a2;
    if (this.atTerminator(i)) return null;
    let t = this.index, r = this.parseEnclosure();
    if (n === "enclosure") return r === null ? null : (_a2 = wn(r)) != null ? _a2 : [];
    if (n === "implicit") {
      if (h(r) === "Delimiter") {
        let o = d(r, 1);
        return h(o) === "Sequence" ? N(o) : o === null ? [] : [o];
      }
      if (r !== null) return [r];
      let s = this.parseExpression({ ...i, minPrec: 390 });
      return s === null ? null : [s];
    }
    return this.index = t, null;
  }
  parseEnclosure() {
    let n = this.getDefs("matchfix"), i = this.index;
    for (let t of n) {
      if (this.index = i, !this.matchDelimiter(t.openTrigger, t.closeTrigger)) continue;
      let r = this.index;
      this.skipSpace();
      let s = this.parseExpression();
      if (this.skipSpace(), !this.matchBoundary()) {
        let a = this._boundaries[this._boundaries.length - 1].tokens;
        if (this.removeBoundary(), this.index = r, this.skipSpace(), s = this.parseExpression(), this.skipSpace(), !this.matchAll(a)) {
          if (this.index = i, !this.atEnd) continue;
          return null;
        }
      }
      let o = t.parse(this, s != null ? s : "Nothing");
      if (o !== null) return o;
    }
    return this.index = i, null;
  }
  parseGenericExpression(n) {
    var _a2;
    if (this.atTerminator(n)) return null;
    let i = this.index, t = null, r = (_a2 = this.peekDefinitions("expression")) != null ? _a2 : [];
    for (let [s, o] of r) if (this.index = i + o, typeof s.parse == "function") {
      if (t = s.parse(this, n), t !== null) return t;
    } else return s.name;
    return this.index = i, null;
  }
  parseFunction(n) {
    if (this.atTerminator(n)) return null;
    let i = this.index, t = null;
    for (let [s, o] of this.peekDefinitions("function")) if (this.index = i + o, typeof s.parse == "function") {
      if (t = s.parse(this, n), t !== null) return t;
    } else {
      t = s.name;
      break;
    }
    if (t === null && (this.index = i, t = nr(this), !this.isFunctionOperator(t))) return this.index = i, null;
    do {
      let s = this.parsePostfixOperator(t, n);
      if (s === null) break;
      t = s;
    } while (true);
    let r = this.parseArguments("enclosure", n);
    return r === null ? t : typeof t == "string" ? [t, ...r] : ["Apply", t, ...r];
  }
  parseSymbol(n) {
    if (this.atTerminator(n)) return null;
    let i = this.index;
    for (let [r, s] of this.peekDefinitions("symbol")) if (this.index = i + s, typeof r.parse == "function") {
      let o = r.parse(this, n);
      if (o !== null) return o;
    } else return r.name;
    this.index = i;
    let t = nr(this);
    return t !== null && this.getIdentifierType(t) === "symbol" ? t : (this.index = i, null);
  }
  parseSupsub(n) {
    var _a2, _b, _c2;
    if (this.atEnd) return n;
    let i = this.index;
    this.skipSpace();
    let t = [], r = [], s = i;
    for (; this.peek === "_" || this.peek === "^"; ) {
      if (this.match("_")) if (s = this.index, this.match("_") || this.match("^")) r.push(this.error("syntax-error", s));
      else {
        let a = (_b = (_a2 = this.parseGroup()) != null ? _a2 : this.parseToken()) != null ? _b : this.parseStringGroup();
        if (a === null) return this.error("missing", i);
        r.push(a);
      }
      else if (this.match("^")) if (s = this.index, this.match("_") || this.match("^")) t.push(this.error("syntax-error", s));
      else {
        let a = (_c2 = this.parseGroup()) != null ? _c2 : this.parseToken();
        if (a === null) return this.error("missing", i);
        t.push(a);
      }
      s = this.index, this.skipSpace();
    }
    if (t.length === 0 && r.length === 0) return this.index = i, n;
    let o = n;
    if (r.length > 0) {
      let a = [...this.getDefs("infix")].filter((u) => u.latexTrigger === "_");
      if (a) {
        let u = ["Subscript", o, r.length === 1 ? r[0] : ["List", ...r]];
        for (let l of a) if (typeof l.parse == "function" ? o = l.parse(this, u, { minPrec: 0 }) : o = u, o !== null) break;
      }
    }
    if (t.length > 0) {
      let a = [...this.getDefs("infix")].filter((u) => u.latexTrigger === "^");
      if (a) {
        let u = t.filter((l) => !U(l));
        if (u.length !== 0) {
          let l = u.length === 1 ? u[0] : ["List", ...u], f = ["Superscript", o, l];
          for (let c of a) if (typeof c.parse == "function" ? o = c.parse(this, f, { minPrec: 0 }) : o = f, o !== null) break;
        }
      }
    }
    return o === null && (this.index = i), o;
  }
  parsePostfixOperator(n, i) {
    if (n === null || this.atEnd) return null;
    let t = this.index;
    for (let [r, s] of this.peekDefinitions("postfix")) {
      this.index = t + s;
      let o = r.parse(this, n, i);
      if (o !== null) return o;
    }
    return this.index = t, null;
  }
  parseSyntaxError() {
    var _a2;
    let n = this.index;
    if (this.peek === "^") return this.index += 1, ["Superscript", this.error("missing", n), F(this.parseGroup())];
    let i = this.peekDefinitions("operator");
    if (i.length > 0) {
      if (i = this.peekDefinitions("postfix"), i.length > 0) {
        let [a, u] = i[0];
        if (this.index += u, typeof a.parse == "function") {
          let l = a.parse(this, this.error("missing", n));
          if (l !== null) return l;
        }
        return a.name ? [a.name, this.error("missing", n)] : this.error("unexpected-operator", n);
      }
      if (i = this.peekDefinitions("prefix"), i.length > 0) {
        let [a, u] = i[0];
        if (this.index += u, typeof a.parse == "function") {
          let l = a.parse(this, { minPrec: 0 });
          if (l !== null) return l;
        }
        return a.name ? [a.name, (_a2 = this.parseExpression()) != null ? _a2 : this.error("missing", n)] : this.error("unexpected-operator", n);
      }
      if (i = this.peekDefinitions("infix"), i.length > 0) {
        let [a, u] = i[0];
        this.index += u;
        let l = a.parse(this, this.error("missing", n), { minPrec: 0 });
        return l !== null ? l : this.error("unexpected-operator", n);
      }
    }
    let t = this.index, r = oa(this);
    if (r !== null) return r;
    if (r = nr(this), r !== null) return this.error(["unexpected-identifier", { str: r }], t);
    let s = this.peek;
    if (!s) return this.error("syntax-error", n);
    if (Tm(this)) return this.error("unexpected-delimiter", n);
    if (s[0] !== "\\") return this.error(["unexpected-token", { str: tn(s) }], n);
    let o = this.nextToken();
    if (this.skipSpaceTokens(), o === "\\end") {
      let a = this.parseStringGroup();
      return a === null ? this.error("expected-environment-name", n) : this.error(["unbalanced-environment", { str: a }], n);
    }
    for (; this.match("["); ) {
      let a = 0;
      for (; !this.atEnd && a === 0 && this.peek !== "]"; ) this.peek === "[" && (a += 1), this.peek === "]" && (a -= 1), this.nextToken();
      this.match("]");
    }
    for (; this.match("<{>"); ) {
      let a = 0;
      for (; !this.atEnd && a === 0 && this.peek !== "<}>"; ) this.peek === "<{>" && (a += 1), this.peek === "<}>" && (a -= 1), this.nextToken();
      this.match("<}>");
    }
    return this.error(["unexpected-command", { str: tn(o) }], n);
  }
  parsePrimary(n) {
    var _a2, _b, _c2, _d2, _e2, _f2;
    if (this.atBoundary || this.atTerminator(n)) return null;
    let i = null, t = this.index;
    if (this.match("<}>")) return this.error("unexpected-closing-delimiter", t);
    if (i != null ? i : i = this.parseGroup(), i != null ? i : i = this.parseNumber(), i != null ? i : i = this.parseEnclosure(), i != null ? i : i = this.parseEnvironment(n), i === null && this.matchAll(this._positiveInfinityTokens) && (i = "PositiveInfinity"), i === null && this.matchAll(this._negativeInfinityTokens) && (i = "NegativeInfinity"), i === null && this.matchAll(this._notANumberTokens) && (i = "NaN"), i === null && this.matchAll(this._imaginaryUnitTokens) && (i = "ImaginaryUnit"), i != null ? i : i = (_c2 = (_b = (_a2 = this.parseGenericExpression(n)) != null ? _a2 : this.parseFunction(n)) != null ? _b : this.parseSymbol(n)) != null ? _c2 : oa(this), i !== null) {
      i = this.decorate(i, t);
      let r = null, s = this.index;
      do {
        if (r = this.parsePostfixOperator(i, n), i = r != null ? r : i, this.index === s && r !== null) {
          this.index;
          break;
        }
        s = this.index;
      } while (r !== null);
    }
    return i !== null && (i = this.parseSupsub(i)), i === null && (i = (_f2 = (_e2 = (_d2 = this.options).parseUnexpectedToken) == null ? void 0 : _e2.call(_d2, null, this)) != null ? _f2 : null, i === null && this.peek.startsWith("\\") && (this.nextToken(), i = this.error("unexpected-command", t))), this.decorate(i, t);
  }
  parseExpression(n) {
    var _a2, _b, _c2;
    this.skipSpace();
    let i = this.index;
    if (this.atBoundary) return this.index = i, null;
    n != null ? n : n = { minPrec: 0 }, n.minPrec, n.minPrec === void 0 && (n = { ...n, minPrec: 0 });
    let t = this.parsePrefixOperator({ ...n, minPrec: 0 });
    if (t === null && (t = this.parsePrimary(n), U(t) && (t = null)), t !== null) {
      let r = false;
      for (; !r && !this.atTerminator(n); ) {
        this.skipSpace();
        let s = this.parseInfixOperator(t, n);
        if (s === null && n.minPrec <= 650 && this.peekDefinitions("operator").length === 0) {
          let o = this.parseExpression({ ...n, minPrec: 651 });
          o !== null ? h(t) === "InvisibleOperator" ? h(o) === "InvisibleOperator" ? s = ["InvisibleOperator", ...N(t), ...N(o)] : s = ["InvisibleOperator", ...N(t), o] : h(o) === "InvisibleOperator" ? s = ["InvisibleOperator", t, ...N(o)] : s = ["InvisibleOperator", t, o] : s === null && (s = (_c2 = (_b = (_a2 = this.options).parseUnexpectedToken) == null ? void 0 : _b.call(_a2, t, this)) != null ? _c2 : null);
        }
        s !== null ? t = s : r = true;
      }
    }
    return this.decorate(t, i);
  }
  decorate(n, i) {
    if (n === null) return null;
    if (!this.options.preserveLatex) return n;
    let t = this.latex(i, this.index);
    return Array.isArray(n) ? n = { latex: t, fn: n } : typeof n == "number" ? n = { latex: t, num: Number(n).toString() } : typeof n == "string" ? n = { latex: t, sym: n } : typeof n == "object" && n !== null && (n.latex = t), n;
  }
  error(n, i) {
    let t;
    typeof n == "string" ? (n.startsWith("'"), t = { str: n }) : (n[0].startsWith("'"), t = ["ErrorCode", { str: n[0] }, ...n.slice(1)]);
    let r = this.latex(i, this.index);
    return r ? ["Error", t, ["LatexString", { str: r }]] : ["Error", t];
  }
  isFunctionOperator(n) {
    return n === null ? false : this.getIdentifierType(n) === "function";
  }
  *getDefs(n) {
    if (n === "operator") for (let i = this._dictionary.defs.length - 1; i >= 0; i--) {
      let t = this._dictionary.defs[i];
      /^prefix|infix|postfix/.test(t.kind) && (yield t);
    }
    else for (let i = this._dictionary.defs.length - 1; i >= 0; i--) {
      let t = this._dictionary.defs[i];
      t.kind === n && (yield t);
    }
  }
};
function vm(e12, n) {
  var _a2;
  let i = e12.index, t = (_a2 = nr(e12)) == null ? void 0 : _a2.trim();
  if (t === null) return 0;
  let r = t !== n ? 0 : e12.index - i;
  return e12.index = i, r;
}
function Tm(e12) {
  let n = e12.peek;
  return Object.values(la).includes(n) || la[n] ? (e12.nextToken(), true) : ua[n] || Object.values(ua).includes(n) ? (e12.nextToken(), e12.nextToken(), true) : false;
}
function rc(e12) {
  let n = e12.index;
  if (e12.matchAll(["\\overset", "<{>"]) && (e12.match(".") || e12.match("\\cdots")) && e12.matchAll(["<}>", "<{>"])) {
    let i = e12.nextToken();
    if (i && /^\d$/.test(i) && e12.match("<}>")) return i;
  }
  return e12.index = n, null;
}
function Sm(e12) {
  let n = e12.peek;
  return n === "\\overline" || n === "\\overset" || n === "\\wideparent" || n === "\\overarc" || n === "(" || n === "\\left";
}
function sc(e12, n, i) {
  let t = new fa(de(e12), n, i), r = t.parseExpression();
  if (!t.atEnd) {
    let s = t.parseSyntaxError();
    r = r !== null ? ["Sequence", r, s] : s;
  }
  return r != null ? r : r = "Nothing", i.preserveLatex && (Array.isArray(r) ? r = { latex: e12, fn: r } : typeof r == "number" ? r = { latex: e12, num: Number(r).toString() } : typeof r == "string" && r.startsWith("'") && r.endsWith("'") ? r = { latex: e12, str: r.slice(1, -1) } : typeof r == "string" ? r = { latex: e12, sym: r } : typeof r == "object" && r !== null && (r.latex = e12)), r;
}
function aa(e12) {
  return e12 === 0 ? { num: "0" } : Number.isInteger(e12) && Math.abs(e12) < O ? e12 : { num: e12.toString() };
}
var ac = ["\\varphi -> \\frac{1+\\sqrt{5}}{2}", _m, Im, (e12) => {
  let n = Pe(e12);
  return n ? { value: n, because: "expand" } : void 0;
}, (e12) => {
  if (e12.operator === "Add") return { value: H(...e12.ops.map((n) => n.canonical.simplify())), because: "addition" };
}, (e12) => {
  if (e12.operator === "Negate") return { value: e12.op1.neg(), because: "negation" };
}, (e12) => {
  if (e12.operator === "Multiply") return { value: ae(...e12.ops.map((n) => n.canonical.simplify())), because: "multiplication" };
}, (e12) => {
  if (e12.operator === "Divide") return { value: e12.op1.div(e12.op2), because: "division" };
  if (e12.operator === "Rational" && e12.nops === 2) return { value: e12.op1.div(e12.op2), because: "rational" };
}, (e12) => {
  if (!e12.op1.isNumberLiteral) return;
  if (e12.operator === "Sqrt") {
    if (e12.op1.isNegative) return { value: e12.engine.box(["Multiply", ["Sqrt", e12.op1.neg()], "ImaginaryUnit"]).simplify(), because: "sqrt" };
    let t = e12.op1.sqrt();
    return oc(t.numericValue) ? { value: t, because: "sqrt" } : void 0;
  }
  let n = e12.op1, i = e12.op2;
  if (i.isNumberLiteral && n.isInteger && i.isInteger && n.re < O && i.re < O) {
    if (e12.operator === "Power") return { value: e12.op1.pow(e12.op2), because: "power" };
    if (e12.operator === "Root") {
      let t = e12.op1.root(e12.op2);
      if (oc(t.numericValue)) return { value: e12.op1.root(e12.op2), because: "root" };
    }
  }
}, (e12) => {
  if (e12.operator !== "Abs") return;
  let n = e12.op1;
  if (n.isNonNegative) return { value: n, because: "|x| -> x" };
  if (n.isNegative) return { value: n.neg(), because: "|x| -> -x" };
}, (e12) => {
  if (e12.operator !== "Sign") return;
  let n = e12.sgn, i = e12.engine;
  if (n !== void 0) {
    if (n === "positive") return { value: i.One, because: "sign positive" };
    if (n === "negative") return { value: i.One, because: "sign negative" };
    if (n === "zero") return { value: i.Zero, because: "sign zero" };
    if (n === "unsigned") return { value: i.NaN, because: "sign unsinged" };
  }
}, (e12) => {
  var _a2;
  if (e12.operator === "Ln") return { value: e12.op1.ln(e12.ops[1]), because: "ln" };
  if (e12.operator === "Log") return { value: e12.op1.ln((_a2 = e12.ops[1]) != null ? _a2 : 10), because: "log" };
}, (e12) => {
  if (e12.operator === "Max") {
    if (e12.nops === 0) return { value: e12.engine.NegativeInfinity, because: "max" };
    if (e12.nops === 1) return { value: e12.op1, because: "max" };
  } else if (e12.operator === "Min") {
    if (e12.nops === 0) return { value: e12.engine.PositiveInfinity, because: "min" };
    if (e12.nops === 1) return { value: e12.op1, because: "min" };
  } else if (e12.operator === "Supremum") {
    if (e12.nops === 0) return { value: e12.engine.NegativeInfinity, because: "sup" };
    if (e12.nops === 1) return { value: e12.op1, because: "sup" };
  } else if (e12.operator === "Infimum") {
    if (e12.nops === 0) return { value: e12.engine.PositiveInfinity, because: "inf" };
    if (e12.nops === 1) return { value: e12.op1, because: "inf" };
  }
}, (e12) => {
  if (e12.operator !== "Derivative") return;
  let n = e12.engine, [i, t] = e12.ops;
  if (e12.nops === 2) return { value: n.function("Derivative", [i.simplify(), t]), because: "derivative" };
  if (e12.nops === 1) return { value: n.function("Derivative", [i.simplify()]), because: "derivative" };
}, (e12) => e12.operator !== "Hypot" ? void 0 : { value: e12.engine.box(["Sqrt", ["Add", ["Square", e12.op1], ["Square", e12.op2]]]).simplify(), because: "hypot(x,y) -> sqrt(x^2+y^2)" }, (e12) => {
  if (e12.operator !== "Congruent" || e12.nops < 3) return;
  let n = e12.engine;
  return { value: n._fn("Equal", [n.function("Mod", [e12.ops[0], e12.ops[2]]).simplify(), n.function("Mod", [e12.ops[1], e12.ops[2]]).simplify()]).simplify(), because: "congruent" };
}, (e12) => {
  e12.operator;
}, (e12) => {
  if (!Ko(e12)) return;
  let n = Kt(e12.operator, e12.op1);
  if (n) return { value: n, because: "constructible value" };
}, (e12) => {
  if (e12.operator !== "InverseFunction") return;
  let n = Xt(e12.engine, e12.ops);
  if (n) return { value: n, because: "inverse function" };
}, (e12) => {
  if (e12.operator !== "Arctan2") return;
  let [n, i] = e12.ops, t = e12.engine;
  return n.isFinite === false && i.isFinite === false ? { value: t.NaN, because: "arctan2" } : n.is(0) && i.is(0) ? { value: t.Zero, because: "arctan2" } : i.isFinite === false ? { value: i.isPositive ? t.Zero : t.Pi, because: "arctan2" } : n.isFinite === false ? { value: n.isPositive ? t.Pi.div(2) : t.Pi.div(-2), because: "arctan2" } : n.is(0) ? { value: i.isPositive ? t.Zero : t.Pi, because: "arctan2" } : { value: t.function("Arctan", [n.div(i)]).simplify(), because: "arctan2" };
}, "\\arcsinh(x) -> \\ln(x+\\sqrt{x^2+1})", "\\arccosh(x) -> \\ln(x+\\sqrt{x^2-1})", "\\arctanh(x) -> \\frac{1}{2}\\ln(\\frac{1+x}{1-x})", "\\arccoth(x) -> \\frac{1}{2}\\ln(\\frac{x+1}{x-1})", "\\arcsech(x) -> \\ln(\\frac{1+\\sqrt{1-x^2}}{x})", "\\arccsch(x) -> \\ln(\\frac{1}{x} + \\sqrt{\\frac{1}{x^2}+1})", Vf];
function _m(e12) {
  var _a2;
  if (!zn(e12) && !As(e12)) return;
  let n = e12, i = e12.engine, t = e12.op1.simplify(), r = e12.op2.simplify();
  if (e12 = i.function(e12.operator, [t, r]), e12 = (_a2 = Yn(e12)) != null ? _a2 : e12, we(e12.operator), e12.nops === 2 && !e12.op2.is(0)) {
    let s = Yn(i.function(e12.operator, [e12.op1.sub(e12.op2), i.Zero]));
    i.costFunction(s) < i.costFunction(e12) && (e12 = s);
  }
  if (!e12.isSame(n)) return { value: e12, because: "simplify-relational-operator" };
}
function Im(e12) {
  return e12.operator !== "List" || !e12.ops.every((i) => As(i) || zn(i)) ? void 0 : { value: e12.engine.function("List", e12.ops.map((i) => i.simplify())), because: "simplify-system-of-equations" };
}
function oc(e12) {
  return e12 === null ? false : typeof e12 == "number" ? Number.isInteger(e12) : e12.isExact;
}
var ir = class e11 {
  constructor(n) {
    var _a2, _b, _c2;
    this.decimalSeparator = ".";
    this._cache = {};
    this._commonSymbols = { True: null, False: null, All: null, Nothing: null, None: null, Undefined: null, Pi: null, ImaginaryUnit: null, ExponentialE: null };
    this._commonNumbers = { "-5": null, "-4": null, "-3": null, "-2": null, 2: null, 3: null, 4: null, 5: null, 6: null, 7: null, 8: null, 9: null, 10: null, 11: null, 12: null, 36: null };
    this.generation = 0;
    this._timeLimit = 2e3;
    this._deadline = void 0;
    this._iterationLimit = 1024;
    this._recursionLimit = 1024;
    if (n !== void 0 && typeof n != "object") throw Error("Unexpected argument");
    this.strict = true, this._stats = { highwaterMark: 0, symbols: /* @__PURE__ */ new Set(), expressions: /* @__PURE__ */ new Set() };
    let i = (_a2 = n == null ? void 0 : n.precision) != null ? _a2 : ws;
    i === "machine" && (i = Math.floor(cn)), this._bignum = M.clone({ precision: i }), this._precision = i, this.tolerance = (_b = n == null ? void 0 : n.tolerance) != null ? _b : "auto", this._angularUnit = "rad", this.Zero = new Ae(this, 0), this.One = new Ae(this, 1), this.Half = new Ae(this, { rational: [1, 2] }), this.NegativeOne = new Ae(this, -1), this.Two = new Ae(this, 2), this.NaN = new Ae(this, Number.NaN), this.PositiveInfinity = new Ae(this, Number.POSITIVE_INFINITY), this.NegativeInfinity = new Ae(this, Number.NEGATIVE_INFINITY), this.I = new Ae(this, { im: 1 }), this.ComplexInfinity = new Ae(this, { re: 1 / 0, im: 1 / 0 }), this.reset(), this.context = { assumptions: new dt() };
    for (let r of e11.getStandardLibrary("domains")) na(this, r);
    let t = (_c2 = n == null ? void 0 : n.ids) != null ? _c2 : e11.getStandardLibrary();
    for (let r of t) na(this, r);
    for (let r of Object.keys(this._commonSymbols)) {
      let s = new Pn(this, r, { canonical: true });
      s.bind(), this._commonSymbols[r] = s;
    }
    this.True = this._commonSymbols.True, this.False = this._commonSymbols.False, this.Pi = this._commonSymbols.Pi, this.E = this._commonSymbols.ExponentialE, this.Nothing = this._commonSymbols.Nothing, this.pushScope(), pf(this);
  }
  static getStandardLibrary(n = "all") {
    return ea(n);
  }
  static getLatexDictionary(n = "all") {
    return il(n);
  }
  toString() {
    return "[ComputeEngine]";
  }
  get latexDictionary() {
    var _a2;
    return (_a2 = this._latexDictionaryInput) != null ? _a2 : e11.getLatexDictionary();
  }
  set latexDictionary(n) {
    this._latexDictionaryInput = n, this._indexedLatexDictionary = to(n, (i) => {
      throw Error(typeof i.message == "string" ? i.message : i.message.join(","));
    });
  }
  get indexedLatexDictionary() {
    var _a2;
    return (_a2 = this._indexedLatexDictionary) != null ? _a2 : this._indexedLatexDictionary = to(this.latexDictionary, (n) => console.error(n)), this._indexedLatexDictionary;
  }
  reset() {
    var _a2;
    this._bignum, this.generation += 1, this._BIGNUM_NEGATIVE_ONE = this.bignum(-1), this._BIGNUM_NAN = this.bignum(NaN), this._BIGNUM_ZERO = this.bignum(0), this._BIGNUM_ONE = this.bignum(1), this._BIGNUM_TWO = this.bignum(2), this._BIGNUM_HALF = this._BIGNUM_ONE.div(this._BIGNUM_TWO), this._BIGNUM_PI = this._BIGNUM_NEGATIVE_ONE.acos();
    let n = this._stats.symbols.values(), i = this._stats.expressions.values();
    this._stats.symbols = /* @__PURE__ */ new Set(), this._stats.expressions = /* @__PURE__ */ new Set();
    for (let r of n) r.reset();
    for (let r of i) r.reset();
    for (let r of Object.values(this._commonSymbols)) r == null ? void 0 : r.reset();
    let t = this.context;
    for (; t; ) {
      if (t.ids) for (let [r, s] of t.ids) s.reset();
      t = (_a2 = t.parentScope) != null ? _a2 : null;
    }
    for (let r of Object.keys(this._cache)) this._cache[r].value && (this._cache[r].purge ? this._cache[r].value = this._cache[r].purge(this._cache[r].value) : delete this._cache[r]);
  }
  _register(n) {
    this._stats.highwaterMark += 1;
  }
  _unregister(n) {
  }
  get stats() {
    let n = this._stats.expressions;
    return this._stats.expressions = null, this._stats.expressions = n, { ...this._stats };
  }
  get precision() {
    return this._precision;
  }
  set precision(n) {
    n === "machine" && (n = cn), n === "auto" && (n = ws);
    let i = this._precision;
    if (n !== i) {
      if (typeof n != "number" || n <= 0) throw Error('Expected "machine" or a positive number');
      this._precision = Math.max(n, cn), this._bignum = this._bignum.config({ precision: this._precision }), this.tolerance = "auto", this.reset();
    }
  }
  get angularUnit() {
    return this._angularUnit;
  }
  set angularUnit(n) {
    if (n !== this._angularUnit) {
      if (typeof n != "string") throw Error("Expected a string");
      this._angularUnit = n, this.reset();
    }
  }
  get timeLimit() {
    return this._timeLimit;
  }
  set timeLimit(n) {
    n <= 0 && (n = Number.POSITIVE_INFINITY), this._timeLimit = n;
  }
  get _timeRemaining() {
    return this.deadline === void 0 ? Number.POSITIVE_INFINITY : this.deadline - Date.now();
  }
  get iterationLimit() {
    return this._iterationLimit;
  }
  set iterationLimit(n) {
    n <= 0 && (n = Number.POSITIVE_INFINITY), this._iterationLimit = n;
  }
  get recursionLimit() {
    return this._recursionLimit;
  }
  set recursionLimit(n) {
    n <= 0 && (n = Number.POSITIVE_INFINITY), this._recursionLimit = n;
  }
  get tolerance() {
    return this._tolerance;
  }
  set tolerance(n) {
    n === "auto" && (n = Ds), (!Number.isFinite(n) || n < 0) && (n = Math.pow(10, -this._precision + 2)), this._tolerance = n, this._bignumTolerance = this.bignum(n), this._negBignumTolerance = this.bignum(-n);
  }
  chop(n) {
    return typeof n == "number" ? Math.abs(n) <= this._tolerance ? 0 : n : n instanceof M ? n.isPositive() && n.lte(this._bignumTolerance) || n.isNegative() && n.gte(this._negBignumTolerance) || n.isZero() ? 0 : n : n instanceof $ && Math.abs(n.re) <= this._tolerance && Math.abs(n.im) <= this._tolerance ? 0 : n;
  }
  bignum(n) {
    if (typeof n == "bigint") return new this._bignum(n.toString());
    try {
      return new this._bignum(n);
    } catch (i) {
      console.error(i.message);
    }
    return this._BIGNUM_NAN;
  }
  complex(n, i) {
    return n instanceof M && (n = n.toNumber()), i instanceof M && (i = i.toNumber()), new $(n, i);
  }
  _numericValue(n) {
    var _a2;
    if (n instanceof z) return (_a2 = n.asExact) != null ? _a2 : n;
    let i = (r) => this.bignum(r), t = this._precision > cn ? (r) => new di(r, i) : (r) => new mi(r, i);
    if (typeof n == "number") return Number.isInteger(n) ? new Z(n, t, i) : t(n);
    if (typeof n == "bigint") return new Z(n, t, i);
    if (Bn(n)) return new Z({ rational: n }, t, i);
    if (n instanceof M) return n.isInteger() && n.e <= Wa ? new Z(K(n.toString()), t, i) : t(n);
    if (n instanceof $) return n.im === 0 ? this._numericValue(n.re) : t({ re: n.re, im: n.im });
    if ("im" in n || "re" in n) return n.im !== void 0 && n.im !== 0 ? t(n) : n.re instanceof M && n.re.isInteger() ? new Z({ rational: [K(n.re.toString()), BigInt(1)] }, t, i) : typeof n.re == "number" && Number.isInteger(n.re) ? new Z({ rational: [n.re, 1] }, t, i) : t(n);
    if ("radical" in n || "rational" in n) {
      if (n.radical !== void 0 && (!Number.isInteger(n.radical) || n.radical >= O)) throw Error("Unexpected value for radical part:" + n.radical);
      return n.rational && te(n.rational) && (!Number.isInteger(n.rational[0]) || !Number.isInteger(n.rational[1])) ? t(n) : new Z(n, t, i);
    }
    throw Error("Unexpected value");
  }
  get costFunction() {
    var _a2;
    return (_a2 = this._cost) != null ? _a2 : ta;
  }
  set costFunction(n) {
    typeof n != "function" && (this._cost = ta), this._cost = n;
  }
  lookupSymbol(n, i, t) {
    var _a2, _b, _c2;
    if (!this.strict) {
      for (t != null ? t : t = (_a2 = this.context) != null ? _a2 : void 0; t; ) {
        let s = (_b = t.ids) == null ? void 0 : _b.get(n);
        if (s && s instanceof ue) return s;
        t = t.parentScope;
      }
      return;
    }
    if (typeof n != "string") throw Error("Expected a string");
    if (n.length === 0 || !this.context) return;
    let r = t != null ? t : this.context;
    if (i) for (t = r; t; ) {
      if (t.ids) {
        for (let [s, o] of t.ids) if (o instanceof ue && o.wikidata === i) return o;
      }
      t = t.parentScope;
    }
    for (t = r; t; ) {
      let s = (_c2 = t.ids) == null ? void 0 : _c2.get(n);
      if (s instanceof ue) return s;
      t = t.parentScope;
    }
  }
  lookupFunction(n, i) {
    var _a2;
    if (typeof n == "string" && this.context) for (i != null ? i : i = this.context; i; ) {
      let t = (_a2 = i.ids) == null ? void 0 : _a2.get(n);
      if (t instanceof Le) return t;
      i = i.parentScope;
    }
  }
  defineSymbol(n, i) {
    if (!this.context) throw Error("Symbol cannot be defined: no scope available");
    if (n.length === 0 || !xe(n)) throw Error(`Invalid identifier "${n}": ${We(n)}}`);
    return this._defineSymbol(n, i);
  }
  _defineSymbol(n, i) {
    var _a2;
    var r;
    (_a2 = (r = this.context).ids) != null ? _a2 : r.ids = /* @__PURE__ */ new Map();
    let t = new ue(this, n, i);
    return t.name && this.context.ids.set(t.name, t), this.generation += 1, t;
  }
  defineFunction(n, i) {
    if (!this.context) throw Error("Function cannot be defined: no scope available");
    if (n.length === 0 || !xe(n)) throw Error(`Invalid identifier "${n}": ${We(n)}}`);
    return this._defineFunction(n, i);
  }
  _defineFunction(n, i) {
    var _a2;
    var r;
    (_a2 = (r = this.context).ids) != null ? _a2 : r.ids = /* @__PURE__ */ new Map();
    let t = us(this, n, i);
    return t.name && this.context.ids.set(t.name, t), this.generation += 1, t;
  }
  pushScope(n) {
    if (this.context === null) throw Error("No parent scope available");
    return this.context = { ...n != null ? n : {}, parentScope: this.context, assumptions: new dt(this.context.assumptions) }, this;
  }
  popScope() {
    var _a2;
    if (!this.context) throw Error("No scope available");
    return this.context = (_a2 = this.context.parentScope) != null ? _a2 : null, this.context, this;
  }
  swapScope(n) {
    let i = this.context;
    return n && (this.context = n), i;
  }
  _printScope(n, i, t = 0) {
    var _a2, _b, _c2;
    if (n != null ? n : n = { details: false, maxDepth: 1 }, i != null ? i : i = this.context, !i || n.maxDepth && t > n.maxDepth) return null;
    let r = `${ec}[undefined]${er}`;
    if (t === 0 ? console.group("current scope - level 0") : console.groupCollapsed(i.parentScope ? `scope - level ${t}` : `root scope - level ${t}`), i.ids) {
      let s = 0;
      for (let [o, a] of i.ids) {
        let u = `${nc}${o}${er}`;
        try {
          if (a instanceof ue) {
            let l = ((_a2 = a.value) == null ? void 0 : _a2.isValid) ? a.value.toString() : a.value ? `${ra}${a.value.toString()}${er}` : r;
            console.info(`${u}: ${(_c2 = (_b = a.type) == null ? void 0 : _b.toString()) != null ? _c2 : r} = ${l}`);
          } else a instanceof Le && (typeof a.evaluate == "function" ? console.info(`${u}(): ${n.details ? a.evaluate.toString() : "[native-code]"}`) : a.evaluate === void 0 ? console.info(`${u}(): ${r}`) : console.info(`${u}(): ${a.toString()}`));
          s === 11 && console.groupCollapsed(`... and ${i.ids.size - s} more`), s += 1;
        } catch (l) {
          console.info(`${u}: ${ra}${l.message}${er}`);
        }
      }
      s >= 11 && console.groupEnd();
    }
    if (i.assumptions) {
      let s = [...i.assumptions.entries()].map(([o, a]) => `${o}: ${a}`);
      if (s.length > 0) {
        console.groupCollapsed(`${s.length} assumptions)`);
        for (let o of s) console.info(o);
        console.groupEnd();
      }
    }
    return i.parentScope && this._printScope(n, i.parentScope, t + 1), console.groupEnd(), this.context;
  }
  resetContext() {
    var _a2;
    if (this.context) for (let [n, i] of (_a2 = this.context.ids) != null ? _a2 : []) i instanceof ue ? i.constant || (i.value = void 0) : i instanceof Le && (i.evaluate = void 0, i.canonical = void 0);
  }
  declare(n, i) {
    var _a2, _b;
    if (typeof n != "string" || i === void 0) {
      for (let [o, a] of Object.entries(n)) this.declare(o, a);
      return this;
    }
    let [t, r] = xo(n);
    if (r !== void 0) throw Error(`Unexpected arguments "${n}". It should be a plain identifier. Use 'ce.assign()' instead to assign a value, or a use a function definition with 'ce.declare()'.`);
    if (t === "Nothing") return this;
    if (!i) throw Error(`Expected a definition or type for "${t}"`);
    if ((_b = (_a2 = this.context) == null ? void 0 : _a2.ids) == null ? void 0 : _b.get(t)) {
      let o = this.context.ids.get(t);
      this.generation += 1;
      let a = false, u = false;
      try {
        a = St(i), u = Tt(i);
      } catch (l) {
        console.error([`
Invalid definition for "${t}"`, l.message].join(`
|   `) + `
`);
      }
      if (o instanceof ue && o.inferredType) {
        if (a) throw new Error(`Cannot redeclare the symbol "${t}" as a function`);
        return u ? o.update(i) : (o.type = k(i), o.inferredType = false), this;
      }
      if (o instanceof Le && o.inferredSignature) {
        if (a) o.update(i);
        else {
          if (u) throw new Error(`Cannot redeclare the function "${t}" as a symbol`);
          o.update({ signature: k(i) });
        }
        return this;
      }
      throw o instanceof Le ? Error([`The symbol "${t}" has already been declared in the current scope as a function with signature ${o.signature}.`, `You may use 'ce.assign("${t}", ...)' to assign a new value to this function.`].join(`
|   `)) : Error([`The symbol "${t}" has already been declared in the current scope.`, `You may use 'ce.assign("${t}", ...)' to assign a new value to this symbol.`].join(`
|   `));
    }
    let s = i;
    if (typeof s == "object" && "type" in s && (typeof s.type == "string" && v(s.type, "function") || s.type && !Sn(s.type))) throw new Error(`Invalid definition for "${t}": use a FunctionDefinition to define a function or use 'ce.declare("${t}", "function")'`);
    if (Tt(s)) return this.defineSymbol(t, s), this;
    if (St(s)) return this.defineFunction(t, s), this;
    {
      let o = k(s);
      if (!Sn(o)) throw typeof s == "object" && "N" in s ? Error([`Invalid argument for "${t}"`, "Use `evaluate` handler instead of `N`"].join(`
|   `)) : Error([`Invalid argument for "${t}"`, JSON.stringify(s), "Use a type, a `FunctionDefinition` or a `SymbolDefinition`"].join(`
|   `));
      o === "function" ? this.defineFunction(t, { signature: "...unknown -> unknown" }) : Xn(o) ? this.defineFunction(t, { signature: o }) : this.defineSymbol(t, { type: o });
    }
    return this;
  }
  assign(n, i) {
    var _a2, _b, _c2;
    if (typeof n == "object") {
      for (let [u, l] of Object.entries(n)) this.assign(u, l);
      return this;
    }
    let [t, r] = xo(n);
    if (t === "Nothing") return this;
    let s = i;
    typeof s == "boolean" && (s = s ? this.True : this.False);
    let o = this.lookupSymbol(t);
    if (o) {
      if (o.constant) throw Error(`Cannot change the value of the constant "${t}"`);
      if (!o.type.isUnknown && !o.inferredType && ca(s)) throw Error(`Cannot assign a function to symbol "${t}"`);
      let u = o.scope;
      if ((_a2 = u == null ? void 0 : u.ids) == null ? void 0 : _a2.delete(o.name), !r && !ca(s)) return s == null ? o.value = void 0 : o.value = this.box(s), (_b = u == null ? void 0 : u.ids) == null ? void 0 : _b.set(o.name, o), this.generation += 1, this;
    }
    let a = this.lookupFunction(t);
    if (a) {
      let u = a.scope;
      if ((_c2 = u == null ? void 0 : u.ids) == null ? void 0 : _c2.delete(a.name), s == null) return this;
      if (typeof s == "function") {
        let p = this.swapScope(u);
        return this.defineFunction(t, { evaluate: s }), this.swapScope(p), this;
      }
      if (r && ca(s)) throw Error(`Unexpected arguments for "${t}"`);
      let l = r ? this.box(["Function", s, ...r]) : this.box(s);
      if (!l.isValid) throw Error(`Invalid function ${l.toString()}`);
      let f = this.swapScope(u), c = ze(l);
      return this.defineFunction(t, { evaluate: (p) => c(p) }), this.swapScope(f), this.generation += 1, this;
    }
    if (s == null) return this.declare(t, { inferred: true, type: "unknown" }), this;
    if (typeof s == "function") return this.defineFunction(t, { evaluate: s }), this;
    if (s instanceof X && (s.type.type === "function" || Xn(s.type.type))) return this.defineFunction(t, { evaluate: s, signature: s.type.type }), this;
    if (Array.isArray(s) || s instanceof X || r) {
      let u = this.box(s, { canonical: false });
      if (u.operator === "Hold") return this.defineSymbol(t, { value: u, type: "unknown" }), this;
      if (u.operator === "Function") return u = this.box(["Function", ...u.ops, ...(r != null ? r : []).map((f) => this.symbol(f))]), this.defineFunction(t, { evaluate: u, signature: u.type.type }), this;
      let l = [...u.unknowns].sort();
      if (l.length === 0) {
        let f = u.evaluate();
        return this.defineSymbol(t, { value: f }), this;
      }
      if (l.some((f) => /\_[\d]+/.test(f))) return u = this.box(["Function", u]), this.defineFunction(t, { evaluate: u, signature: u.type.type }), this;
      if (r && r.length > 0) return this.pushScope(), u = this.box(["Function", u, ...r]), this.popScope(), this.defineFunction(t, { evaluate: u, signature: u.type.type }), this;
      this.pushScope(), s = u.evaluate(), this.popScope();
    }
    return this.defineSymbol(t, { value: s }), this;
  }
  _assign(n, i) {
    let t = this.lookupSymbol(n);
    if (t) {
      t.value = i.evaluate(), this.generation += 1;
      return;
    }
    let r = this.lookupFunction(n);
    if (r) {
      r.canonical = void 0, r.evaluate = i, this.generation += 1;
      return;
    }
    `${n}`;
  }
  shouldContinueExecution() {
    return this.deadline === void 0 || this.deadline >= Date.now();
  }
  checkContinueExecution() {
    if (!this.shouldContinueExecution()) throw new Error("timeout");
  }
  cache(n, i, t) {
    var _a2;
    if (this._cache[n] === void 0) try {
      this._cache[n] = { build: i, purge: t, value: i() };
    } catch (r) {
      console.error(`Fatal error building cache "${n}":
	 ${r.toString()}`);
    }
    return (_a2 = this._cache[n]) == null ? void 0 : _a2.value;
  }
  box(n, i) {
    return on(this, n, i);
  }
  function(n, i, t) {
    return os(this, n, i, t);
  }
  error(n, i) {
    let t;
    typeof n == "string" ? t = this.string(n) : t = this._fn("ErrorCode", n.map((o) => this.string(o)));
    let r;
    i && Nt(i) ? r = this._fn("LatexString", [this.string(Vn(i))]) : typeof i == "string" && i.length > 0 && (r = this.string(i));
    let s = [this.box(t)];
    return r && s.push(r), new Ge(this, "Error", s, { canonical: false });
  }
  typeError(n, i, t) {
    return i ? this.error(["incompatible-type", ne(n), i.toString()], t) : this.error(["incompatible-type", ne(n)], t);
  }
  hold(n) {
    return this._fn("Hold", [this.box(n, { canonical: false })]);
  }
  tuple(...n) {
    return new Ge(this, "Tuple", n.map((i) => typeof i == "number" ? this.number(i) : i.canonical), { canonical: true });
  }
  type(n) {
    return n instanceof C ? n : new C(n);
  }
  string(n, i) {
    return new Nn(this, n, i);
  }
  symbol(n, i) {
    var _a2, _b, _c2;
    if (i = i ? { ...i } : {}, "canonical" in i || (i.canonical = true), n = n.normalize(), n === "NaN") return this.NaN;
    if (n === "Infinity" || n === "+Infinity" || n === "PositiveInfinity") return this.PositiveInfinity;
    if (n === "-Infinity" || n === "NegativeInfinity") return this.NegativeInfinity;
    if (n === "Half") return this.Half;
    if (this.strict && !xe(n)) {
      let r = (_a2 = i == null ? void 0 : i.metadata) == null ? void 0 : _a2.latex;
      return this.error(["invalid-identifier", We(n)], r ? `$$${r}$$` : n);
    }
    if (((_b = i == null ? void 0 : i.metadata) == null ? void 0 : _b.latex) !== void 0 && i.canonical !== true) return new Pn(this, n, i);
    let t = this._commonSymbols[n];
    return t && (!((_c2 = i == null ? void 0 : i.metadata) == null ? void 0 : _c2.wikidata) || !t.wikidata || t.wikidata === i.metadata.wikidata) ? t : i.canonical === true ? Kf(this, n) : new Pn(this, n, i);
  }
  number(n, i) {
    var _a2;
    var s;
    let t = i == null ? void 0 : i.metadata, r = false;
    if ((!i || i.canonical === void 0 || i.canonical === "Number" || i.canonical === true || Array.isArray(i.canonical) && i.canonical.includes("Number")) && (r = true), !r && Bn(n)) return this._fn("Rational", [this.number(n[0]), this.number(n[1])], { ...t, canonical: false });
    if (n = fs(this, n), t === void 0) {
      if (typeof n == "number") {
        let o = n;
        if (o === 1) return this.One;
        if (o === 0) return this.Zero;
        if (o === -1) return this.NegativeOne;
        if (o === 2) return this.Two;
        if (Number.isInteger(o) && this._commonNumbers[o] !== void 0) return (_a2 = (s = this._commonNumbers)[o]) != null ? _a2 : s[o] = new Ae(this, n), this._commonNumbers[o];
        if (Number.isNaN(o)) return this.NaN;
        if (!Number.isFinite(o)) return o < 0 ? this.NegativeInfinity : this.PositiveInfinity;
      } else if (n instanceof z) {
        if (n.isZero) return this.Zero;
        if (n.isOne) return this.One;
        if (n.isNegativeOne) return this.NegativeOne;
        if (n.isNaN) return this.NaN;
        if (n.isNegativeInfinity) return this.NegativeInfinity;
        if (n.isPositiveInfinity) return this.PositiveInfinity;
      }
    }
    return new Ae(this, n, { metadata: t });
  }
  rules(n, i) {
    return jt(this, n, i);
  }
  getRuleSet(n) {
    if (n != null ? n : n = "standard-simplification", n === "standard-simplification") return this.cache("standard-simplification-rules", () => jt(this, ac, { canonical: true }));
    if (n === "solve-univariate") return this.cache("univariate-roots-rules", () => jt(this, Pl));
    if (n === "harmonization") return this.cache("harmonization-rules", () => jt(this, Ol));
  }
  _fn(n, i, t) {
    var _a2;
    let r = (_a2 = t == null ? void 0 : t.canonical) != null ? _a2 : true;
    return new Ge(this, n, i, { ...t, canonical: r });
  }
  parse(n, i) {
    var _a2, _b;
    if (n == null) return null;
    if (typeof n != "string") throw Error("ce.parse(): expected a LaTeX string");
    let t = { imaginaryUnit: "\\imaginaryI", positiveInfinity: "\\infty", negativeInfinity: "-\\infty", notANumber: "\\operatorname{NaN}", decimalSeparator: this.decimalSeparator, digitGroup: 3, digitGroupSeparator: "\\,", exponentProduct: "\\cdot", beginExponentMarker: "10^{", endExponentMarker: "}", truncationMarker: "\\ldots", repeatingDecimal: "auto", skipSpace: true, parseNumbers: "auto", getIdentifierType: (s) => this.lookupFunction(s) ? "function" : "symbol", parseUnexpectedToken: (s, o) => null, preserveLatex: false }, r = sc((_a2 = Vn(n)) != null ? _a2 : n, this.indexedLatexDictionary, { ...t, ...i });
    if (r === null) throw Error("Failed to parse LaTeX string");
    return this.box(r, { canonical: (_b = i == null ? void 0 : i.canonical) != null ? _b : true });
  }
  get assumptions() {
    if (!this.context) throw Error("No scope available");
    return this.context.assumptions ? this.context.assumptions : (this.context.assumptions = new dt(), this.context.assumptions);
  }
  ask(n) {
    let i = this.box(n, { canonical: false }), t = [];
    for (let [r, s] of this.assumptions) {
      let o = i.match(r);
      o !== null && s === true && t.push(o);
    }
    return t;
  }
  verify(n) {
    return false;
  }
  assume(n) {
    try {
      let i = Nt(n) ? this.parse(n, { canonical: false }) : this.box(n, { canonical: false });
      return this.generation += 1, Ll(i);
    } catch (i) {
      throw console.error(i.message.toString()), i;
    }
  }
  forget(n) {
    if (!this.context) throw Error("No scope available");
    if (n === void 0) {
      if (this.context.ids) for (let i of this.context.ids.keys()) this.forget(i);
      this.generation += 1, this.assumptions.clear();
      return;
    }
    if (Array.isArray(n)) {
      for (let i of n) this.forget(i);
      return;
    }
    if (typeof n == "string") {
      if (this.context.ids) {
        let i = this.context.ids.get(n);
        i instanceof ue ? i.value = void 0 : i instanceof Le && (i.evaluate = void 0, i.canonical = void 0);
      }
      for (let [i, t] of this.assumptions) i.symbols.includes(n) && this.assumptions.delete(i);
    }
    this.generation += 1;
  }
};
function ca(e12) {
  return !!(typeof e12 == "function" || e12 instanceof X && v(e12.type.type, "function"));
}
globalThis[Symbol.for("io.cortexjs.compute-engine")] = { ComputeEngine: ir.prototype.constructor, version: "0.29.1" };

// src/editor.ts
var CalctexHintRenderer = class {
  constructor(view) {
    this.decorations = this.buildDecorations(view);
  }
  update(update) {
    this.decorations = this.buildDecorations(update.view);
  }
  destroy() {
  }
  buildDecorations(view) {
    const builder = new import_state.RangeSetBuilder();
    for (const { from, to: to2 } of view.visibleRanges) {
      const cursorPos = view.state.selection.main.from;
      let mathBegin = null;
      (0, import_language.syntaxTree)(view.state).iterate({
        from,
        to: to2,
        enter(node) {
          var _a2;
          const nodeTags = node.type.name.split("_");
          if (nodeTags.contains("formatting-math-begin"))
            mathBegin = node.to;
          if (nodeTags.contains("formatting-math-end") && mathBegin != null) {
            const mathEnd = node.from;
            if (cursorPos < mathBegin || mathEnd < cursorPos) return;
            const relativeCursorPos = cursorPos - mathBegin;
            const latexContentLines = view.state.sliceDoc(mathBegin, mathEnd).split("\n");
            const focusedLatexLine = (_a2 = latexContentLines.find(
              (_line, i) => relativeCursorPos < latexContentLines.slice(0, i + 1).join("\n").length + 1
            )) != null ? _a2 : "";
            const trimmedLatexLine = focusedLatexLine.replace("\\\\", "").trim();
            const previousLatexLines = latexContentLines.slice(0, latexContentLines.indexOf(focusedLatexLine));
            if (!trimmedLatexLine.endsWith(CalctexPlugin.INSTANCE.settings.calculationTriggerString) && !trimmedLatexLine.endsWith(CalctexPlugin.INSTANCE.settings.approxCalculationTriggerString)) return;
            const calcTrigger = new RegExp(`${CalctexPlugin.INSTANCE.settings.calculationTriggerString}|${CalctexPlugin.INSTANCE.settings.approxCalculationTriggerString.replace("\\", "\\\\")}`);
            const isApproximation = trimmedLatexLine.endsWith(CalctexPlugin.INSTANCE.settings.approxCalculationTriggerString);
            const splitFormula = focusedLatexLine.split(calcTrigger).filter((part) => part.replace("\\\\", "").trim().length > 0);
            const formula = splitFormula[splitFormula.length - 1];
            const calculationEngine = new ir();
            const latexOptions = {
              prettify: true,
              multiply: CalctexPlugin.INSTANCE.settings.multiplicationSymbol,
              decimalSeparator: CalctexPlugin.INSTANCE.settings.decimalSeparator,
              digitGroupSeparator: CalctexPlugin.INSTANCE.settings.groupSeparator,
              fractionalDigits: isApproximation && CalctexPlugin.INSTANCE.settings.approxDecimalPrecision !== -1 ? CalctexPlugin.INSTANCE.settings.approxDecimalPrecision : "auto"
            };
            const formattedFormula = formula.replace("\\\\", "").replace("&", "");
            let expression = calculationEngine.parse(formattedFormula);
            for (const previousLine of previousLatexLines) {
              try {
                const formattedPreviousLine = previousLine.replace("\\\\", "").replace("&", "");
                const lineExpression = calculationEngine.parse(formattedPreviousLine).simplify();
                const lineExpressionParts = lineExpression.latex.split("=");
                if (lineExpressionParts.length <= 1) continue;
                const jsonValue = calculationEngine.parse(lineExpressionParts[lineExpressionParts.length - 1].trim()).json;
                expression = expression.subs({
                  [lineExpressionParts[0].trim()]: jsonValue
                });
              } catch (e12) {
                console.error(e12);
              }
            }
            let result = null;
            if (expression.isValid) {
              const evaluation = expression.evaluate();
              result = (isApproximation ? evaluation.N() : evaluation).toLatex(latexOptions);
            } else {
              expression.print();
              result = "\u26A1";
            }
            let insertIndex = mathBegin + previousLatexLines.join("\n").length + focusedLatexLine.replace("\\\\", "").trimEnd().length;
            if (previousLatexLines.length > 0) insertIndex += 1;
            builder.add(
              insertIndex,
              insertIndex,
              import_view2.Decoration.replace({
                widget: new ResultWidget(view, insertIndex, ` ${result}`)
              })
            );
          }
        }
      });
    }
    return builder.finish();
  }
};
var pluginSpec = {
  decorations: (value) => value.decorations
};
var calctexHintRenderer = import_view2.ViewPlugin.fromClass(
  CalctexHintRenderer,
  pluginSpec
);

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  calculationTriggerString: "=",
  approxCalculationTriggerString: "\\approx",
  approxDecimalPrecision: 3,
  completionTriggerKey: "Tab",
  multiplicationSymbol: "*",
  groupSeparator: "'",
  decimalSeparator: "."
};
var CalctexSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Calculation Trigger String").setDesc("The string that triggers calculation.").addText(
      (text) => text.setPlaceholder("Type a string here").setValue(this.plugin.settings.calculationTriggerString).onChange(async (value) => {
        this.plugin.settings.calculationTriggerString = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Approximation Trigger String").setDesc("The string that triggers approximation.").addText(
      (text) => text.setPlaceholder("Type a string here").setValue(this.plugin.settings.approxCalculationTriggerString).onChange(async (value) => {
        this.plugin.settings.approxCalculationTriggerString = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Approximation Precision").setDesc("The precision used when approximating (-1 for max).").addText(
      (text) => text.setPlaceholder("Type a number here").setValue(this.plugin.settings.approxDecimalPrecision.toString()).onChange(async (value) => {
        this.plugin.settings.approxDecimalPrecision = parseInt(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Completion Trigger Key").setDesc("The key that triggers completion.").addText(
      (text) => text.setPlaceholder("Type name of a key here").setValue(this.plugin.settings.completionTriggerKey).onChange(async (value) => {
        this.plugin.settings.completionTriggerKey = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Multiplication Symbol").setDesc("The symbol used for multiplication (e.g. * or \\times).").addText(
      (text) => text.setPlaceholder("Type a symbol here").setValue(this.plugin.settings.multiplicationSymbol).onChange(async (value) => {
        this.plugin.settings.multiplicationSymbol = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Group Separator").setDesc("The symbol used for grouping numbers (e.g. ' or ,).").addText(
      (text) => text.setPlaceholder("Type a symbol here").setValue(this.plugin.settings.groupSeparator).onChange(async (value) => {
        this.plugin.settings.groupSeparator = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Decimal Separator").setDesc("The symbol used for defining where the decimal point is (e.g. , or .)").addText(
      (text) => text.setPlaceholder("Type a symbol here").setValue(this.plugin.settings.decimalSeparator).onChange(async (value) => {
        this.plugin.settings.decimalSeparator = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/main.ts
var CalctexPlugin = class _CalctexPlugin extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new CalctexSettingTab(this.app, this));
    this.registerEditorExtension([calctexHintRenderer]);
    _CalctexPlugin.INSTANCE = this;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
/*! Bundled license information:

@cortex-js/compute-engine/dist/compute-engine.min.esm.js:
  (*! Bundled license information:
  
  complex-esm/dist/src/complex.js:
    (**
     * @license Complex.js v2.1.1 12/05/2020
     *
     * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
     * Dual licensed under the MIT or GPL Version 2 licenses.
     **)
  
  decimal.js/decimal.mjs:
    (*!
     *  decimal.js v10.5.0
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     *)
  *)
*/

/* nosourcemap */